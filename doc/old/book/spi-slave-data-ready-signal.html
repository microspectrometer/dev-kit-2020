<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mike Gazes" />
  <title>Implement a SPI Slave Data Ready Signal On a 4-Wire SPI Bus</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Implement a SPI Slave <em>Data Ready</em> Signal On a 4-Wire SPI Bus</h1>
<p class="author">Mike Gazes</p>
<p class="date">March 4th, 2019</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#pain-point">Pain Point</a></li>
<li><a href="#solutions">Solutions</a><ul>
<li><a href="#the-5-wire-spi-bus-solution">The 5-wire SPI Bus solution</a><ul>
<li><a href="#when-this-is-not-an-option">When this is not an option</a></li>
</ul></li>
<li><a href="#four-wire-solution-if-slave-select-pins-are-tied-together-use-miso.">Four-wire solution: if Slave Select pins are tied together, use MISO.</a></li>
<li><a href="#the-slave-select-pin-in-multi-master-spi-systems.">The Slave Select pin in multi-master SPI systems.</a></li>
<li><a href="#repurposing-the-automatic-switch-from-master-to-slave">Repurposing the automatic switch from Master-to-Slave</a></li>
<li><a href="#four-wire-solution-do-not-connect-to-slave-select-pin-on-spi-master.">Four-wire solution: do not connect to Slave Select pin on SPI master.</a></li>
</ul></li>
<li><a href="#spi-slave-function-to-signal-data-is-ready">SPI Slave Function to signal data is ready</a><ul>
<li><a href="#this-function-uses-the-following-strategy-to-overcome-this-problem.">This function uses the following strategy to overcome this problem.</a></li>
<li><a href="#my-first-attempt-to-explain-why-the-waveform-is-this-way.">My first attempt to explain why the waveform is this way.</a></li>
</ul></li>
<li><a href="#protocol">Protocol</a><ul>
<li><a href="#intent-for-the-spimaster.">Intent for the SpiMaster.</a></li>
<li><a href="#control-over-the-timeout-for-when-spislave-hangs.">Control over the timeout for when SpiSlave hangs.</a></li>
<li><a href="#causes-of-spislave-timeout-and-the-expected-response-by-the-usbhost.">Causes of SpiSlave timeout and the expected response by the UsbHost.</a></li>
</ul></li>
</ul>
</nav>
<h1 id="pain-point">Pain Point</h1>
<p>Signaling when the slave is ready to send data is the pain point of SPI communication in the general case where the SPI slave does <em>not</em> collect data synchronized to the SPI clock.</p>
<p>An example where the SPI slave <em>is</em> synchronized is a SPI-interface SAR ADC. The ADC uses the SPI clock as the SAR clock. The SPI master knows <em>exactly</em> when the data is ready because the SPI master controls the generation of the data. Instead of the usual <em>eight clocks is a byte of data</em> protocol, the SPI master clocks the ADC as much as the ADC requires to do a conversion, ignoring the data that is coming out, and then it clocks another 16 times to read out the converted value.</p>
<p>But in the general case, when the SPI master asks for data it has no control over when the data is ready. So how does the SPI master know when to start readout?</p>
<h1 id="solutions">Solutions</h1>
<h2 id="the-5-wire-spi-bus-solution">The 5-wire SPI Bus solution</h2>
<p>The usual solution in a single-master SPI system is to use an additional general purpose I/O pin on the SPI slave that drives an additional general purpose I/O pin on the SPI master. Thus the four-wire SPI bus becomes a five-wire SPI bus: MOSI, MISO, SCK, SS, DR (data ready).</p>
<p>Be lazy. Do it this way if you can. The readout PCBs in the <code>20190429-dev-kit</code> project do it this way. (The previous PCBs do not, hence I had to come up with a 4-wire solution.)</p>
<p>Example: I have <code>seven</code> required signals.</p>
<ul>
<li>4-wire SPI</li>
<li>2-wire power</li>
<li><code>RST</code> for programming the microcontroller</li>
</ul>
<p>Seven is a weird number for a connector. For example, the <em>3M D2500 Series</em> only come in even numbers of pins. Use an eight-pin connector. Then there is an extra pin anyway. Also, both microcontrollers have a spare I/O pin <code>PORTB</code> pin <code>B1</code>, which is the same port shared by <code>MISO</code>. There is no reason to stick with a 4-wire bus.</p>
<h3 id="when-this-is-not-an-option">When this is not an option</h3>
<p>But an additional I/O pin is not an option if the SPI master and SPI slave do not have enough general purpose I/O pins. Even if pin count is not a problem, using additional I/O pins is undesirable if the SPI master and SPI slave are on different circuit boards because this requires an extra dedicated signal wire between the two boards.</p>
<p>Again, this is a <em>weird</em> problem to have. I had the problem because past me goofed. So I came up with a solution. I share it here because it works. But I will probably never do it this way again.</p>
<h2 id="four-wire-solution-if-slave-select-pins-are-tied-together-use-miso.">Four-wire solution: if Slave Select pins are tied together, use MISO.</h2>
<p>The eval kit hardware <em>does</em> tie the Slave select of the SPI slave to the slave select of the SPI master. Therefore, I cannot use the Slave Select pin on the SPI slave as my <em>Data Ready</em> signal. The SPI master drives this pin. If the SPI master reconfigures it as an input inbetween transmissions, then when the SPI slave drives the pin low, it will automatically switch the SPI master to a SPI slave. This is undesirable because it prevents me from adding other SPI slaves to the eval kit hardware, such as an LED driver.</p>
<p>Instead, use the MISO pin as the <em>Data Ready</em> signal. The SPI hardware module forces MISO to be an input on the SPI master. But MISO can be an input or an output on the SPI slave. Be aware that even as an output, MISO is tri-stated on the SPI slave unless there is a tranmission.</p>
<p>The SPI master transmits a request for data to the SPI slave and then waits for the slave to send the data ready signal. The SPI master watches MISO, either by polling it, or by disabling SPI functionality and enabling the pin-change interrupt on the MISO pin.</p>
<p>The SPI slave signals data is ready by disabling SPI, then spiking MISO low by driving it low (MISO is already configured as an output), and then re-enabling SPI. This tri-states MISO and the pin slowly rises back up. Alternatively, driving MISO high again before re-enabling SPI and the waveform becomes a clean step.</p>
<p>The SPI master sees MISO go low and knows the data is ready. The SPI master then watches for MISO to go high again to know for sure that the SPI slave has re-enabled its SPI module and is ready for a transmission.</p>
<h2 id="the-slave-select-pin-in-multi-master-spi-systems.">The Slave Select pin in multi-master SPI systems.</h2>
<p>Usually the Slave Select pin on the SPI master is configured as an output. It is disconnected from the SPI hardware module and behaves like a general purpose I/O pin.</p>
<p>In multi-master systems, the data direction of the SPI master is configured as an input. This avoids contention on the slave select pin. As an input, it is normally high via an external pull-up. Either SPI master can temporarily configure its slave select as an output and drive the slave select line low.</p>
<p>When one master switches direction to output and drives the pin low, the other master is automatically changed to a SPI slave. After communication is over, the SPI slave manually changes itself back to a SPI master. If the other master wasn’t finished communicating, Slave Select is still low (or a synchronizing pulse pulls it low again) and the SPI master is automatically knocked back into being a SPI slave.</p>
<p>Multi-master SPI systems are neat. They can be used to implement a fault-tolerant distributed network of concurrent processes by sharing a common SPI bus.</p>
<ul>
<li>[ ] Rethink multi-master as the solution for sending a frame of data from the <code>sensor</code> to the <code>bridge</code>: let the <code>sensor</code> become the <code>SpiMaster</code> when sending lots of data back</li>
</ul>
<h2 id="repurposing-the-automatic-switch-from-master-to-slave">Repurposing the automatic switch from Master-to-Slave</h2>
<p>Repurpose the functionality that enables multi-master SPI to give a single-master SPI network a super power: a way for the SPI slave to signal to the SPI master that it is ready to send data.</p>
<h2 id="four-wire-solution-do-not-connect-to-slave-select-pin-on-spi-master.">Four-wire solution: do not connect to Slave Select pin on SPI master.</h2>
<p>Rethink this later: when the SPI slave temporarily becomes a SPI master, is their a possibility of bus contention?</p>
<p>There is another four-wire SPI bus solution besides using MISO.</p>
<p>Do not connect the SPI Slave Select pins of the SPI master and SPI slave. I have always connected these pins because they have the same name, so connecting them <em>seemed</em> like the intent. It is the intent for a multi-master system. It is not the intent for a single-master system.</p>
<p>Instead, connect the Slave Select pin on the SPI Slave to a general purpose I/O pin on the SPI master. Place an external pull-up resistor on this pin so that it is normally high, independent of what the SPI master does. The SPI master makes this general purpose pin I/O pin an output and drives it low to transmit to the SPI slave.</p>
<p>To recap: use Slave Select on the SPI slave but do not use Slave Select on the SPI Master pin. Or use it as an output pin for some other purpose. But do not use it as an input (or else a low on this pin causes the SPI module switches from master to slave). When waiting for a response from the SPI slave, the SPI master drives the pin high, then makes it an input and watches for a low on this pin, either by polling the pin or using an interrupt.</p>
<p>The general purpose I/O on the SPI Master that connects to the Slave Select on the SPI slave is the dedicated <em>Data Ready</em> pin for this particular SPI slave. The SPI slave pulls the pin low when it is ready to send data.</p>
<p>Since the SPI hardware forces the data direction of Slave Select to be an input, the SPI slave must first change itself into a SPI master, then change the data direction of this pin. The idea is the same as using MISO to signal <em>Data Ready</em>.</p>
<p>The SPI slave (now temporarily a SPI master) spikes the pin low by changing its data direction to output, and then back to input.</p>
<p>The SPI slave should hold the pin low for at least a few clock cycles of the SPI master’s CPU clock to make sure the SPI master <em>hears</em> it. There is no danger in holding the pin low for longer.</p>
<p>The SPI slave can change itself back to a slave, or it can leave itself as a master. If it is still a master, it will be automatically changed back to a SPI slave when the <em>true</em> SPI master pulls Slave Select low.</p>
<p>The low on <em>Data Ready</em> is the signal for the SPI master that the SPI slave is ready. The SPI master then waits for this general purpose I/O pin to go high again before beginning the SPI transmission.</p>
<h1 id="spi-slave-function-to-signal-data-is-ready">SPI Slave Function to signal data is ready</h1>
<h2 id="this-function-uses-the-following-strategy-to-overcome-this-problem.">This function uses the following strategy to overcome this problem.</h2>
<ol type="1">
<li><p>Disable the SPI module to restore general purpose I/O functionality.</p></li>
<li><p>Pin <code>Spi_Miso</code> is driven low because the PORT register has a 0 in this bit. This is a sudden voltage step from high to low.</p></li>
<li><p>Enable the SPI module in preparation to receive a transmission from the SPI master. This is a slow voltage rise from low to high because the the capacitance on the SPI bus is charged by the small current available from the power supply via the pull-up resistor. Optionally, drive the pin high before re-enabling SPI. This is faster, but now the SPI master must add an extra small delay after seeing the pin go high to be sure the SPI slave is ready.</p></li>
</ol>
<h2 id="my-first-attempt-to-explain-why-the-waveform-is-this-way.">My first attempt to explain why the waveform is this way.</h2>
<p>The SpiSlave uses <code>Spi_Miso</code> to signal <code>data_ready</code> to the SpiMaster. This requests the SpiMaster to start a SPI transmission.</p>
<p>But the SpiSlave cannot drive pin <code>Spi_Miso</code> outside of a transmission while the ATmega SPI module is enabled. When there is no transmission, <code>Spi_Miso</code> is weakly pulled high via a resistor. When the ATmega SPI module is enabled in SPI Slave mode, the MISO pin is driven by the SPI hardware module instead of the general purpose PORT register.</p>
<h1 id="protocol">Protocol</h1>
<h2 id="intent-for-the-spimaster.">Intent for the SpiMaster.</h2>
<p>Every time the SpiMaster sends a message to the SpiSlave, the SpiSlave responds. The message from the SpiMaster may be multiple bytes. The first byte is the <code>spi_CmdFn_key</code> byte. The SpiSlave looks up the key in its jump-table and finds out how many more bytes, if any, to expect from the SpiMaster. After receiving all bytes, the SpiSlave executes the command and signals to the SpiMaster on <code>Spi_Miso</code> that it is ready to respond.</p>
<p>The signal is that <code>Spi_Miso</code> is driven low. SpiMaster then waits for <code>Spi_Miso</code> to go high before it starts the transmission.</p>
<p>The SpiMaster determines the number of bytes in the response from the the first two bytes sent by the SpiSlave. These two bytes form a 16-bit word, most-significant byte first. Therefore, the SpiMaster always knows how many bytes to read from the SpiSlave.</p>
<p>This is necessary because the SpiSlave might have had an error. For example, if the SpiMaster sends an invalid command. In this case, the SpiSlave responds with two bytes: [StatusInvalid, <code>invalid_cmd</code>]. If the SpiMaster thought it was requesting a frame data, it would expect 784 bytes. Instead, the SpiSlave sends [0x00, 0x02] indicating that only two bytes are coming back: [StatusInvalid, <code>invalid_cmd</code>].</p>
<p>Note that even knowing how many bytes to expect, the SpiSlave sends the <em>Data-Ready</em> signal between every byte. This is because the SPI data register is not double-buffered in the transmit direction. The SpiSlave cannot, therefore, load the next byte until the transmission is finished. The SpiMaster must wait to clock the SpiSlave for the start of the next byte until it receives the <em>Data-Ready</em> signal.</p>
<p>The SpiMaster stops checking for <em>Data-Ready</em> after it receives all of the bytes the SpiSlave said it was sending.</p>
<p>After the SpiMaster sends a message, it must wait until the SpiSlave signals that a response is ready. The SpiMaster polls MISO continuously until MISO goes low. Alternatively, the SpiMaster can disable its SPI hardware module and enable the pin change interrupt PCINT4. In this case, the SpiMaster re-enables SPI in the interrupt routine.</p>
<p>The SpiMaster can carry out any other task while the SpiSlave is busy and then read from the SpiSlave at its leisure. The only exception is that the SpiMaster <em>should not</em> communicate with other SPI slaves while the SpiSlave is busy because this opens the possibility of bus contention. The SpiSlave can share the SPI bus with other SPI slaves as long as the SpiMaster does not attempt communication with the other SPI slaves after it sends a message to the SpiSlave.</p>
<p>The low on MISO signals that the SpiSlave is ready. The SpiMaster proceeds with readout. Based on the first two bytes received, the SpiMaster knows how many bytes remain for readout and continues SPI transmissions until all bytes are collected. The SpiMaster waits for MISO low on every byte.</p>
<h2 id="control-over-the-timeout-for-when-spislave-hangs.">Control over the timeout for when SpiSlave hangs.</h2>
<p>There is one flaw in this strategy. If the SpiSlave hangs after receiving the message from the SpiMaster, the SpiMaster also hangs because it is waiting for the SpiSlave to respond.</p>
<p>Less likely, but also a possibility, is getting out of sync on the number of bytes sent during a long transmission:</p>
<ol type="1">
<li><p>If the SpiMaster thinks there are still more bytes coming, but the SpiSlave has sent all the bytes, the SpiSlave will stop signaling <em>Data-Ready</em> and the SpiMaster will hang waiting for <em>Data-Ready</em>.</p></li>
<li><p>If the SpiMaster thinks it already received all the bytes, but the SpiSlave still has bytes to send, the SpiSlave will still be in a state where it is waiting for the SpiMaster to do another SPI transmission. The SpiSlave will not be listening for new communications from the SpiMaster.</p></li>
</ol>
<p>For these two unlikely cases described above, the simple solution is to wait a more-than-reasonable amount of time and then give up on the transmission.</p>
<p>In case 1, the SpiMaster tells the UsbHost that the request timed out. It is up to the UsbHost to resend the command.</p>
<p>In case 2, the SpiSlave just returns to the main loop and does not try to notify the SpiMaster of an error. For a nasty <em>silent</em> error like this, turn three out of the four Debug LEDs red. This indicates a silent error occurred and the system just went on about its business.</p>
<p>Back to the more likely scenario that the SpiSlave is taking too long in attempting to carry out a task requested by the SpiMaster.</p>
<p>The SpiMaster cannot simply timeout and give up on the SpiSlave because the response may still come at some future time, in which case the SpiSlave will pull MISO low when the master does not expect it. This is OK, unless it happens while the SpiMaster is communicating with another SpiSlave. In this case, there is the possibility for bus contention.</p>
<p>Even without other SPI slaves, this case needs to be dealt with anyway because now the SpiSlave is hung and the SpiMaster cannot talk to it! The SpiSlave has a timer (to be implemented), but its timeout is relatively long. The following solution gives the SpiMaster control over the timeout period. The SpiMaster needs the power to decide when to timeout on the unresponsive SpiSlave.</p>
<p>The solution is that after timeout, the SpiMaster sends a new message to the SpiSlave telling it to abandon whatever it’s doing. For this to work, the SpiSlave must be checking for this message while it works.</p>
<p>Therefore, if a <code>spi_CmdFn</code> in the SpiSlave jump-table has a while loop, it must poll the SPI interrupt flag on every iteration. If the SpiMaster sent 0xFF, the SpiSlave abandons its task by doing the following:</p>
<ol type="1">
<li><p>Perform any necessary clean-up prior to abandoning its task. For example, if it is in the middle of a frame readout, put the LIS-770i back in its idle state.</p></li>
<li><p>Abandon the task by returning an error all the way up the call chain to get back to the <code>spi_CmdFn</code>.</p></li>
</ol>
<p>To return to the <code>spi_CmdFn</code>, each function call in the path returns an error status. When the hung task abandons, it returns an error. It’s caller uses that error to return as an error, and so on. Eventually, execution returns to the function in the jump table.</p>
<p>The <code>spi_CmdFn</code> sees the task was abandoned and prepares to send [0x00, 0x02] indicating that two more bytes are coming. The two bytes are [StatusTaskKilled, cmd]. The SpiMaster is expecting this since it killed the task. The SpiMaster has to read out this status signal for execution in the SpiSlave to return to its main loop.</p>
<ol start="3" type="1">
<li>Drive MISO low as usual to signal data-ready. In this context, the SpiMaster already knows what is waiting for it, but it has to read it out anyway. The SpiSlave reports that the task was killed, and it reports which <code>spi_CmdFn</code> it was executing when the command was killed.</li>
</ol>
<p>As with the usual data-ready signal, disable SPI, output a low on MISO, re-enable SPI. This results in a brief spike low, followed by a slow rise via the pull-up.</p>
<h2 id="causes-of-spislave-timeout-and-the-expected-response-by-the-usbhost.">Causes of SpiSlave timeout and the expected response by the UsbHost.</h2>
<p>The most likely cause for the timeout is that the SpiSlave takes too long to AutoExpose. In this case, after sending 0xFF, when the SpiMaster receives the signal that the SpiSlave has abandoned task, the SpiMaster sends a StatusTimedOut error to the UsbHost. Normally, auto-expose results in the SpiMaster sending back the updated integration time. In this case, the task was abandoned, so the integration time on the SpiSlave is unknown.</p>
<p>The UsbHost reponds by sending a new command to set the integration time. The SpiMaster responds with the updated integration time on the SpiSlave, and the system is once again in sync.</p>
</body>
</html>
