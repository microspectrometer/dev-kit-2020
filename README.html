<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">README</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#communication-protocol">Communication Protocol</a></li>
<li><a href="#status">Status</a><ul>
<li><a href="#old-external-user-notes-i-wrote-in-initial-osram-repo">Old <code>external user notes</code> I wrote in initial Osram repo</a><ul>
<li><a href="#context">Context</a></li>
<li><a href="#spectrometer-chip-digital-interface-protocol">Spectrometer Chip Digital Interface Protocol</a></li>
</ul></li>
<li><a href="#bugs">Bugs</a></li>
<li><a href="#next-step">Next step</a></li>
<li><a href="#saturation-threshold-lower-than-expected">Saturation Threshold Lower Than Expected</a><ul>
<li><a href="#data-and-notes-are-here">data and notes are here</a></li>
</ul></li>
<li><a href="#optical-background">Optical background</a><ul>
<li><a href="#data-and-notes-are-here-1">data and notes are here</a></li>
</ul></li>
<li><a href="#latest-improvements">Latest improvements</a><ul>
<li><a href="#lib-usb-passed-its-embedded-system-tests">lib USB passed its embedded system tests</a></li>
</ul></li>
<li><a href="#lib-organization">lib organization</a><ul>
<li><a href="#libs-for-communication">libs for communication</a></li>
<li><a href="#other-libs">other libs</a></li>
</ul></li>
<li><a href="#estimate-progress">estimate progress</a><ul>
<li><a href="#estimate-details">estimate details:</a></li>
<li><a href="#system-tests">system tests</a></li>
<li><a href="#embedded-tests">embedded tests</a></li>
</ul></li>
<li><a href="#track-progress-by-lib">track progress by lib</a><ul>
<li><a href="#x-ft1248">[x] Ft1248</a></li>
</ul></li>
<li><a href="#deliverables-for-august">Deliverables for August</a></li>
<li><a href="#deadline">Deadline</a><ul>
<li><a href="#embedded-development">embedded development</a></li>
<li><a href="#measurement-interface">measurement interface</a></li>
<li><a href="#estimating-time-per-test">Estimating time per test</a></li>
</ul></li>
</ul></li>
<li><a href="#lis-770i-project-code-organization">LIS-770i project code organization</a></li>
<li><a href="#abstract-memory-mapped-io-for-tests">Abstract memory-mapped-io for tests</a><ul>
<li><a href="#faking-io-registers">Faking io registers</a><ul>
<li><a href="#test-code-as-a-client">test code as a client</a></li>
<li><a href="#embedded-system-as-a-client">embedded system as a client</a></li>
</ul></li>
<li><a href="#thought-process-on-faking-io-this-way">Thought process on faking io this way</a><ul>
<li><a href="#run-time-injection-is-stupid-complicated">run time injection is stupid complicated</a></li>
<li><a href="#optimizing-for-sanity-and-simplicity">optimizing for sanity and simplicity</a></li>
<li><a href="#my-old-notes-on-this-from-mock-object">my old notes on this from mock-object</a></li>
</ul></li>
</ul></li>
<li><a href="#tdd">TDD</a></li>
<li><a href="#mockist-tdd">Mockist TDD</a><ul>
<li><a href="#mocks-are-not-fakes">Mocks are not fakes</a><ul>
<li><a href="#update-only-mock-when-the-test-requires-it">2017-07-19 Update: only mock when the test requires it</a></li>
<li><a href="#this-section-was-copied-from-repo-mock-object">This section was copied from repo <code>mock-object</code></a></li>
<li><a href="#example">Example</a></li>
<li><a href="#i-wrap-these-inside-functions">I wrap these inside functions</a></li>
<li><a href="#compiling-lib-code-with-avr-asm-macros">Compiling lib code with AVR asm macros</a></li>
</ul></li>
<li><a href="#interrupts">Interrupts</a></li>
<li><a href="#read-a-register-and-throw-away-the-value">Read a register and throw away the value</a></li>
<li><a href="#clobbering-large-arrays-when-making-structs">clobbering large arrays when making structs?</a><ul>
<li><a href="#wait-but-why">wait but why</a></li>
</ul></li>
<li><a href="#pointer-signedness">pointer signedness</a></li>
</ul></li>
<li><a href="#ft1248-1">FT1248</a><ul>
<li><a href="#how-ft1248-relates-to-usb">How FT1248 relates to USB</a><ul>
<li><a href="#usb-1">USB</a></li>
<li><a href="#ft1248-2">FT1248</a></li>
<li><a href="#the-usb-bridge-abstracts-the-usb-hardware-interface">The USB-bridge abstracts the USB hardware interface</a></li>
<li><a href="#usb-host-and-ft1248-master-both-initiate-communication-with-the-usb-bridge">USB host and FT1248 master both initiate communication with the USB-bridge</a></li>
<li><a href="#contract-between-the-usb-host-application-and-the-ft1248-master-firmware">Contract between the USB host application and the FT1248 master firmware</a></li>
</ul></li>
<li><a href="#ft1248-overview">FT1248 overview</a><ul>
<li><a href="#bus-turnaround">Bus-turnaround</a></li>
<li><a href="#ack-and-nak">ACK and NAK</a></li>
</ul></li>
<li><a href="#ft1248-protocol-and-ft1248-c-library">FT1248 protocol and Ft1248 C library</a><ul>
<li><a href="#polling-in-the-inactive-state">Polling in the inactive state</a></li>
<li><a href="#activate-the-interface">Activate the interface</a></li>
<li><a href="#read-command">Read Command</a></li>
<li><a href="#bus-turnaround-after-the-read-command">Bus-turnaround after the read command</a></li>
<li><a href="#write-command">Write Command</a></li>
<li><a href="#bus-turnaround-after-the-write-command">Bus-turnaround after the write command</a></li>
</ul></li>
<li><a href="#ft1248-setup">FT1248 setup</a></li>
<li><a href="#ft1248-starts-communication-with-a-combined-command-and-bus-width-byte">FT1248 starts communication with a combined command and bus-width byte</a></li>
<li><a href="#how-the-mcu-manages-usb-communication-using-ft1248">How the MCU manages USB communication using FT1248</a><ul>
<li><a href="#check-if-there-is-any-unread-data-from-the-usb-host">Check if there is any unread data from the USB host</a></li>
<li><a href="#read-the-data-from-the-usb-host">Read the data from the USB host</a></li>
</ul></li>
<li><a href="#ft1248-reference">FT1248 reference</a><ul>
<li><a href="#hardware-specific-ft1248-settings-in-ftprog">Hardware Specific Ft1248 Settings in ftprog</a></li>
<li><a href="#ft1248-format-of-combined-command-and-bus-width-byte">FT1248 format of combined command and bus-width byte</a></li>
<li><a href="#ft1248-combined-command-and-bus-width-byte-for-an-8-bit-bus">FT1248 combined command and bus-width byte for an 8-bit bus</a></li>
</ul></li>
</ul></li>
<li><a href="#spi">SPI</a><ul>
<li><a href="#spi-dev-tasklist">SPI dev tasklist</a><ul>
<li><a href="#this-is-the-dev-cycle">This is the dev cycle</a></li>
</ul></li>
<li><a href="#spi-dev-overview">SPI dev overview</a><ul>
<li><a href="#spi-and-spi">SPI and Spi</a></li>
<li><a href="#master-and-slave">Master and Slave</a></li>
<li><a href="#spi-overview">SPI overview</a></li>
<li><a href="#spi-communication-for-requesting-a-frame">SPI communication for requesting a frame</a></li>
<li><a href="#setup-the-spi-registers">Setup the SPI registers</a></li>
<li><a href="#spi-errata">SPI Errata</a></li>
<li><a href="#detection-logic-for-spi-data-ready-signal-includes-tri-state">Detection logic for SPI data-ready signal includes tri-state</a></li>
<li><a href="#todo-code-for-bad-actor-spi-scenarios">TODO: code for bad actor SPI scenarios</a></li>
</ul></li>
<li><a href="#spi-simbrd-and-mbrd-hardware">SPI simBrd and mBrd hardware</a></li>
<li><a href="#old-but-useful-spi-master-writes-to-spi-slave">Old but useful: SPI master writes to SPI slave</a></li>
<li><a href="#old-notes-that-are-probably-not-useful-anymore">Old notes that are probably not useful anymore</a><ul>
<li><a href="#old-reference-docs">Old Reference docs</a></li>
<li><a href="#standard-spi">Standard SPI</a></li>
<li><a href="#spi-with-slavechip-select">SPI with Slave/Chip Select</a></li>
</ul></li>
</ul></li>
<li><a href="#uart-spi">UART SPI</a><ul>
<li><a href="#spi-communication-with-ltc1864ladc">SPI communication with LTC1864LADC</a></li>
</ul></li>
<li><a href="#lis">LIS</a><ul>
<li><a href="#one-frame-of-data">one frame of data</a></li>
<li><a href="#power-down">power down</a></li>
<li><a href="#power-up">power up</a></li>
<li><a href="#programmable-setup">programmable setup</a></li>
<li><a href="#frame-readout">frame readout</a></li>
</ul></li>
<li><a href="#program-flash">Program Flash</a><ul>
<li><a href="#quick-summary">Quick Summary</a></li>
<li><a href="#compiler-options">Compiler options</a></li>
<li><a href="#memory-on-the-atmega328">Memory on the ATmega328</a><ul>
<li><a href="#ram-layout-and-stack-heap-collisions">RAM layout and stack-heap collisions</a></li>
<li><a href="#size-of-the-final-.elf-files">Size of the final <code>.elf</code> files</a></li>
</ul></li>
<li><a href="#cable-connections-and-switch-settings">Cable connections and switch settings</a></li>
<li><a href="#verify-programming-communication-link">Verify programming communication link</a><ul>
<li><a href="#correct-output">Correct output</a></li>
<li><a href="#do-not-invoke-from-command-line">Do not invoke from command line</a></li>
<li><a href="#invoke-from-vim">Invoke from Vim</a></li>
</ul></li>
<li><a href="#do-not-manually-program-flash-from-the-command-line">Do not manually program flash from the command line</a></li>
<li><a href="#programming-flash-with-make">Programming flash with <code>make</code></a><ul>
<li><a href="#build-and-download">Build and Download</a></li>
</ul></li>
<li><a href="#look-at-the-disassembly-instructions">Look at the disassembly instructions</a><ul>
<li><a href="#read-the-.lst-file">read the .lst file</a></li>
<li><a href="#view-disassembly-in-gdb">view disassembly in <code>gdb</code></a></li>
</ul></li>
</ul></li>
<li><a href="#usb-host-application">USB Host Application</a><ul>
<li><a href="#new-python-application">New Python application</a></li>
<li><a href="#lissweep">LisSweep</a></li>
<li><a href="#eval-kit-example-python-interface">2017 eval kit <code>Example Python Interface</code></a><ul>
<li><a href="#use-legacy-python-environment">Use legacy Python environment</a></li>
<li><a href="#needs-py27-to-write-unicode">needs py27 to write unicode</a></li>
<li><a href="#needs-windows-to-acces-the-com-port">needs Windows to acces the <code>COM</code> port</a></li>
<li><a href="#configure-the-ft221xa-for-vcp">Configure the FT221XA for VCP</a></li>
<li><a href="#run-at-the-python-repl">Run at the Python REPL</a></li>
</ul></li>
<li><a href="#dev-kit-redesign">Dev kit redesign</a><ul>
<li><a href="#notes-from-2018-08-16-meeting-with-nadia">Notes from 2018-08-16 meeting with Nadia</a></li>
</ul></li>
</ul></li>
<li><a href="#repo-links">Repo links</a></li>
</ul>
</nav>
<h1 id="communication-protocol">Communication Protocol</h1>
<ul>
<li><strong>USB Host</strong> communicates with the <strong>sensor-interface</strong> via the <strong>usb-bridge</strong></li>
<li>all action starts with the USB Host</li>
<li>USB Host sends a command to the usb-bridge</li>
<li>usb-bridge passes the command to the sensor-interface</li>
<li>the number of bytes in the command depends on the command</li>
<li>the first byte of the command is <em>always</em> the <code>spi_CmdFn_key</code></li>
<li>given the command key, the sensor-interface knows how many bytes are in the message
<ul>
<li>this is hard-coded into whichever function the <code>key</code> jumps to</li>
</ul></li>
<li>after it receives all bytes, the sensor interface:
<ul>
<li>executes the command (if it is a command to do something)</li>
<li>sends a response to the usb-bridge</li>
</ul></li>
<li>sensor-interface responds to <em>all</em> messages, even if the command does not require the sensor-interface to return sensor data</li>
<li>sensor-interface is a SpiSlave, so it cannot directly respond</li>
<li>sensor-interface signals to usb-bridge when it is ready to respond</li>
<li>then the usb-bridge sends dummy bytes to read the data from the sensor-interface</li>
<li>there are two ways to send the <strong>data-ready</strong> signal</li>
<li>the old <strong>4-wire</strong> way:
<ul>
<li><code>Spi_Miso</code> is driven low</li>
<li>usb-bridge (SpiMaster) then waits for <code>Spi_Miso</code> to go high before it starts the transmission</li>
</ul></li>
<li>new <strong>5-wire</strong> way:
<ul>
<li>signal is on <code>Spi_DataReady</code> (net <code>DR</code> on EAGLE schematic)</li>
<li>I have no idea yet exactly what this signal will do</li>
</ul></li>
<li>usb-bridge starts reading the response, but does not know beforehand how long the response will be</li>
<li>usb-bridge uses the <strong>first two bytes</strong> of this response to determine the number of bytes in the response
<ul>
<li>these two bytes form a 16-bit word, MSB first</li>
</ul></li>
<li>these two bytes are necessary because the sensor-interface might have had an error
<ul>
<li>example: the usb-bridge thinks it is requesting frame data, but actually sends an invalid command</li>
<li>sensor-interface responds to an invalid command with two bytes: [StatusInvalid, <code>invalid_cmd</code>]</li>
<li>usb-bridge expects 784 bytes</li>
<li>instead, sensor-interface first sends [0x00, 0x02] indicating that only two bytes are coming back</li>
<li>then it sends the two bytes: [StatusInvalid, <code>invalid_cmd</code>]</li>
<li>so a total of four bytes are sent:
<ul>
<li>two bytes of message length</li>
<li>two bytes of actual message</li>
</ul></li>
</ul></li>
<li>between every byte, the sensor-interface sends a <em>Data-Ready</em> signal:
<ul>
<li>SPI data register is not double-buffered</li>
<li>SPI slave cannot load next byte until this transfer is finished</li>
<li>SpiMaster has to wait for SpiSlave to load next byte before it starts the next transmission</li>
</ul></li>
<li>in 4-wire SPI:
<ul>
<li>the usb-bridge must not attempt any other SPI communication while it waits for a SpiSlave response because <em>Data-Ready</em> is a SPI pin</li>
</ul></li>
<li>in 5-wire SPI:
<ul>
<li>the usb-bridge can do whatever it wants because <em>Data-Ready</em> is not a SPI bus wire, and the sensor-interface will sit and wait with its data ready until the usb-bridge reads it</li>
</ul></li>
<li>after receiving the message, the usb-bridge passes it to the USB Host</li>
<li>usb-bridge pushes all data from sensor-interface to USB Host, including the 2-byte header from the sensor-interface stating how many bytes it is sending</li>
<li>see the rest of section <code>Protocol</code> in <code>LIS-770i/doc/book/spi-slave-data-ready-signal.md</code> to see how I intend to handle a timeout</li>
</ul>
<h1 id="status">Status</h1>
<h2 id="old-external-user-notes-i-wrote-in-initial-osram-repo">Old <code>external user notes</code> I wrote in initial Osram repo</h2>
<h3 id="context">Context</h3>
<p>I must have wrote this up imagining I was about to freeze the API. It talks about a protocol (the SPI slave) that doesn’t actually exist. We have a working SPI slave, but the API is not ready for external use.</p>
<h3 id="spectrometer-chip-digital-interface-protocol">Spectrometer Chip Digital Interface Protocol</h3>
<ul>
<li>the digital interface makes it easy for client hardware to obtain raw spectra from the spectrometer chip</li>
<li>the digital interface protocol describes how to:
<ul>
<li>request a frame of pixel data</li>
<li>detect when the data is ready</li>
<li>read the data out #### A raw spectrum is a frame of dark-corrected pixel data</li>
</ul></li>
<li>each spectrum is a frame of pixel data
<ul>
<li>there are 784 pixels</li>
<li>starting from pixel 1 and reading to pixel 784, there are:
<ul>
<li>13 optically black</li>
<li>1 dummy between the black and active</li>
<li>770 optically active</li>
</ul></li>
<li>each pixel is a 16-bit value</li>
</ul></li>
<li>the pixel values are dark-corrected in hardware
<ul>
<li>the dark-correction is done prior to digital conversion</li>
<li>this is unlike most other spectrometers which require the user to perform a dark-correciton step by collecting a separate frame of dark data to subtract from all subsequent data</li>
<li>the dark reference voltage comes from the optically black pixels, so any changes to the dark voltage are accounted for at the time of pixel readout</li>
<li>this makes dark-correction more convenient since it is done for you and more accurate since it is based on the real-time dark voltage</li>
</ul></li>
<li>the frame of pixel data is <em>raw</em> only in the sense that it is not power-calibrated, i.e., the magnitude of each pixel response is weighted by:
<ul>
<li>the spectral responsivities of the photodiode array and photonic crystal</li>
<li>and as a second-order consideration, any non-linearities in the amplifier and ADC of the digital interface
<ul>
<li>at the time of this writing, 2018-09-05, there is saturation, either in the output stage of the linear photodiode array or in the ADC input stage on the digital interface PCB, that causes gain to have a nonlinear effect</li>
<li>the nonlinearity is only dependent on the amplitude of the output signal, e.g., gain through increased integration time, increased amplifier gain, or increased pixel height all manifest this nonlinearity</li>
<li>the digital interface is being revised to eliminate this saturation and restore the expected linearity</li>
</ul></li>
</ul></li>
</ul>
<h4 id="context-how-pixel-data-is-collected">Context: how pixel data is collected</h4>
<h5 id="light-inside-the-spectrometer-chip">light inside the spectrometer chip</h5>
<ul>
<li>the spectrometer chip is a linear photodiode array of pixels mated with an optical device</li>
<li>the optical device consists of a photonic crystal and mirrors to structure the input light before it interacts with the photonic crystal</li>
<li>the photonic crystal operation is similar to a diffraction grating in that it separates the input light into a continuous spectrum of wavelengths</li>
<li>each pixel subtends some angular spread of the continuous spectrum, thus the continuous spectrum is binned into pixels at the plane where it is incident upon the linear photodiode array ##### control of the linear photodiode array</li>
<li>the linear photodiode array has signal lines for:
<ul>
<li>controlling exposure time</li>
<li>clocking out the pixel voltages after exposure</li>
</ul></li>
<li>the pixel voltages are available one-at-a-time on an analog output pin during the high-time of the pixel clock</li>
<li>the dark reference voltage is available at all times on an analog output pin ##### pixel data is collected by the digital interface</li>
<li>the digital interface is idle until it receives a request for a frame of pixel data</li>
<li>the digital interface collects a frame of pixel data by:
<ul>
<li>exposing the pixels for the desired exposure time</li>
<li>running the pixel clock to access all of the pixels for digital conversion</li>
</ul></li>
<li>for each pixel accessed, the digital interface:
<ul>
<li>takes the difference between the analog pixel and dark voltages</li>
<li>converts this differential voltage to a 16-bit value</li>
<li>stores that 16-bit value in memory</li>
</ul></li>
<li>after the entire frame is in memory, the digital interface signals it is ready to transmit the data</li>
<li>the digital interface ignores any further commands send to it until it has transmitted the entire frame of data</li>
<li>the digital interface begins <em>listening</em> again to incoming data from the client hardware during the last byte of pixel data transferred out ##### exposure time ranges from 200us to 13.1s</li>
<li>exposure time:
<ul>
<li>defaults to 10ms</li>
<li>is easily changed by the client hardware (see next section)</li>
<li>can be set to any value between 200us and 13.1s in increments of 200us</li>
<li>2018-09-05 update:
<ul>
<li>the version sent to Tyler works in 20us steps</li>
<li>the range of integration times is 20us to 1.31s</li>
<li>this was a mistake, but I did not have time to fix it</li>
<li>there was no reason to make this a priority:
<ul>
<li>the output runs into saturation issues when output is large</li>
<li>Tyler can also use the gain control to increase signal</li>
<li>in my tests with a 5mm LED, I never needed integration times beyond 200ms</li>
</ul></li>
<li>when we ship Tyler the new spectrometers, we will send new PCBs with corrected firmware and a new LabVIEW application that sends the correct integration time value #### Communication with the digital interface</li>
</ul></li>
</ul></li>
<li>the spectrometer chip digital interface is a SPI slave</li>
<li>see Spi-Commands.h for the list of commands recognized by the SPI slave #### SPI overview</li>
<li>one SPI master communicates with N SPI slaves</li>
<li>SPI is synchronous meaning that the SPI master controls the speed of communication by controlling the SPI clock</li>
<li>there are two uni-directional data lines: MOSI (master out slave in) and MISO (master in slave out)</li>
<li>there are four possible modes for the relationship between clock and data
<ul>
<li>all SPI slaves expect to operate in one of these four modes #### Special considerations for the spectrometer chip digital interface ##### SPI mode</li>
</ul></li>
<li>the SPI slave uses the mode known as <code>CPOL=0 CPHA=0</code> meaning that:
<ul>
<li>the SPI clock is idle low</li>
<li>the data lines are sampled on the rising edge of the clock</li>
<li>the next bit to transfer is set up on the data lines on the falling edge of the clock</li>
</ul></li>
<li>data is sent MSB (most significant bit) first ##### transfer bytes one at a time and synchronize between transfers</li>
<li>SPI transfers are done on a byte-by-byte basis:
<ul>
<li>the SPI master starts a byte transfer by pulling Slave Select low</li>
<li>the SPI master runs the clock for a total of eight rising edges</li>
<li>the master ends the byte transfer by pulling Slave Select high</li>
</ul></li>
<li>therefore if multiple bytes are sent, Slave Select pulses high between every byte
<ul>
<li>pulsing Slave Select in between byte transfers adds redundancy in keeping the SPI master and slave synchronized ##### delay between transfers when writing consecutive bytes</li>
</ul></li>
<li>when the SPI master is writing consecutive bytes to the SPI slave, leave Slave Select high for 16.5us betweeen every byte
<ul>
<li>this guarantees the SPI slave has time to move the received byte into memory before receiving the next byte</li>
<li>16.5us is a conservatively long time to wait, but the SPI master never needs to write more than a few bytes to the SPI slave for a given command, so there is no harm in using a conservatively long delay to guarantee the SPI slave is ready for the next byte ##### wait for data-ready signal when reading bytes</li>
</ul></li>
<li>when the SPI master is reading bytes from the SPI slave, wait for the SPI slave to signal the data is ready before starting each byte transfer
<ul>
<li>for example, when requesting a frame, the master waits for the slave to signal the data is ready
<ul>
<li>this initial wait is relatively long as the SPI slave has to conduct a frame readout with the spectrometer chip to buffer a frame of pixel data</li>
</ul></li>
<li>after transferring the first byte of data, the master again waits for the slave to signal the data is ready, and so on for all 1568 bytes
<ul>
<li>this guarantees the slave always has the next byte of data ready in the SPI transmit buffer before the master reads the byte ##### checking the data-ready signal requires awareness of the tri-state</li>
</ul></li>
</ul></li>
<li>the SPI slave signals data is ready by pulling MISO low for 4.5us</li>
<li>the SPI master guarantees it correctly detects this signal using the following macro:</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#define MacroSpiResponseIsReady() MacroBitIsClear(Spi_pin, Spi_Miso)</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="pp">#define MacroSpiMasterWaitForResponse() do { \</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="pp">    while(  MacroSpiResponseIsReady() ); \</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="pp">    while( !MacroSpiResponseIsReady() ); \</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="pp">    while(  MacroSpiResponseIsReady() ); \</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="pp">} while (0)</span></a></code></pre></div>
<ul>
<li>this guarantees that
<ul>
<li>low is detected on <code>MISO</code> because the SPI slave pulled <code>MISO</code> low
<ul>
<li>and not because <code>MISO</code> is still recovering from a final low at the end of a SPI transmission</li>
<li>the first two while loops provide this guarantee</li>
</ul></li>
<li>the SPI slave is ready for the next data transfer
<ul>
<li>the last while loop is the SPI master waiting for <code>MISO</code> to slowly pull high</li>
<li>the SPI slave has plenty of time to re-enable its SPI hardware module while this happens</li>
<li>this last while loop guarantees the SPI master does not attempt to communicate until the SPI slave is ready for another SPI transfer</li>
</ul></li>
</ul></li>
</ul>
<h4 id="commands-affect-the-state-of-the-spectrometer-chip-digital-interface">Commands affect the state of the spectrometer chip digital interface</h4>
<ul>
<li>the interface is normally in an idle state</li>
<li>in this state it responds to the commands listed in <code>Spi-Commands.h</code></li>
<li>once the interface receives a command, it enters a state that must be carried to completion before it can hear new commands
<ul>
<li>if the SPI slave expects the command to be followed by additional data from the master, then the master must send that data for the SPI slave to return to its idle state</li>
<li>for example the command to set to exposure time must be followed by two bytes (and the SPI slave interprets these two bytes as the desired exposure time)</li>
<li>if the command requests data from the SPI slave, then the master must carry out the expected number of SPI transfers for the slave to shift out all of the requested data</li>
<li>for example, setting exposure time and requesting a frame both cause the SPI slave to send data back to the SPI master</li>
</ul></li>
<li>there is no command to abort a data frame once it has been requested</li>
</ul>
<h4 id="set-the-exposure-time">Set the exposure time</h4>
<ul>
<li>set the exposure time by sending the byte <code>0x02</code></li>
<li>the <code>Spi</code> lib defines this as:</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">uint8_t</span> <span class="dt">const</span> cmd_set_exposure_time     = <span class="bn">0x02</span>;</a></code></pre></div>
<ul>
<li>follow the command with the exposure time as a 16-bit value</li>
<li>for example, to set the exposure time to 40ms, send <code>0x02</code> <code>0x07</code> <code>0xD0</code>
<ul>
<li>40ms is <code>2000</code> 20us ticks</li>
<li>TODO: revise this example for the 200us ticks</li>
<li><code>2000</code> as two bytes is <code>7</code> for the <em>MSB</em> and <code>208</code> for the <em>LSB</em></li>
<li><code>7</code> in hexadecimal is <code>0x07</code> and <code>208</code> in hexadecimal is <code>0xD0</code></li>
</ul></li>
<li>the spectrometer chip digital interface echoes back the 16-bit exposure time:
<ul>
<li>the spectrometer chip signals that it has data to send by pulling <code>MISO</code> low for 4.3us</li>
<li>the SPI master waits for this signal, then does two SPI transfers to read the two bytes</li>
<li>in the eval kit, the SPI master relays this values back to the USB host for the application user to verify that the spectrometer is using the desired exposure time</li>
</ul></li>
<li>client hardware <em>must</em> read this data:
<ul>
<li>the SPI slave ignores any further commands from the SPI master until the SPI master does two SPI transfers to shift out these two bytes #### Request a frame of data</li>
</ul></li>
<li>request a frame by sending the byte <code>0x01</code></li>
<li>the <code>Spi</code> lib defines this as:</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">uint8_t</span> <span class="dt">const</span> cmd_send_lis_frame        = <span class="bn">0x01</span>;</a></code></pre></div>
<ul>
<li>wait</li>
</ul>
<h2 id="bugs">Bugs</h2>
<ul>
<li>[ ] fix bug found on 2018-11-04:
<ul>
<li>spectrometer USB communication times out if only one row is selected and the auto-expose command is sent</li>
<li>probably a problem with the firmware, not the host PC application</li>
<li>also times out on integration times around 300ms with all rows selected</li>
</ul></li>
</ul>
<h2 id="next-step">Next step</h2>
<ul>
<li>[ ] fix bugs</li>
<li>[ ] failed to add parameters to auto-expose SPI command
<ul>
<li>this should have been straight-forward</li>
<li>the fact I could not get it to work suggests a problem with the SPI interface itself</li>
<li>I worked on this at the 11th hour in getting the California kits ready, so attack this again with more time and patience</li>
</ul></li>
<li>[ ] Provide a trigger signal for Tyler at Osram
<ul>
<li>triggers an LED driver</li>
<li>use the SDA and GND pin on the USB-Spi PCB</li>
<li>I looked up LED driver solutions for machine vision to answer the trigger-requirements question because Tyler has gone silent on this</li>
<li>I had two takeaways:
<ol type="1">
<li>the trigger signal is simply an LED on/off signal, i.e., sketch “B” in my email to Tyler</li>
<li>driver delay time is negligible compared with the spectrometer integration time</li>
</ol>
<ul>
<li>conclusion:
<ul>
<li>the trigger signal goes high just before exposure starts</li>
<li>the trigger signal goes low just after exposure ends</li>
</ul></li>
</ul></li>
<li>waiting to hear back a confirmation from Tyler that this sounds good</li>
<li>if I do not hear back, I think it is safe to proceed with this design</li>
</ul></li>
<li>[ ] design an LED driver circuit with the LT3805 LDO or LT3932 buck to demostrate the trigger</li>
<li>[ ] redesign readout board to have the trigger breakout</li>
<li>[ ] convert Fluttershy into customer-ready kits:
<ul>
<li>remove dies to paint minor faces</li>
<li>paint over Nadia’s original black paint job</li>
<li>reassemble with gorilla glue</li>
<li>place a machined light-block over the assembly</li>
<li>characterize with the monochromator and wide-angle, wide-bandwidth LEDs</li>
</ul></li>
<li>[ ] wavelength sweep characterization setup</li>
<li>[x] revise firmware on simBrd and mBrd to use the correct number of bytes in a frame
<ul>
<li>summing mode on: pixels are binned (392)</li>
<li>summing mode off: pixels are not binned (784)</li>
<li>[x] correct number of bytes in a frame is driven by the number of pixels</li>
<li>[x] revise firmware on mBrd to use the correct number of pixels during LIS readout</li>
<li>[x] revise firmware on mBrd to send the correct number of bytes in a frame</li>
<li>[x] revise firmware on simBrd to request the correct number of bytes in a frame</li>
<li>[x] host PC app reads the correct number of bytes, driven by the UI setting for pixel binning</li>
<li>[x] host PC app initializes the LIS config immediately after opening communication
<ul>
<li>ensures the host PC app and the two MCU all agree on the number of pixels in a frame before any frames are acquired</li>
</ul></li>
</ul></li>
<li>[x] find sources of optical background in Fluttershy
<ul>
<li>started 2018-09-05, see email update</li>
<li>finished 2018-10-12:
<ul>
<li>reflection off minor faces of die creates structured stray light around pixel 300</li>
<li>the light input at the input aperture is not completely blocked by the black paint Nadia used and this creates a large smooth stray light hump at the low pixels</li>
</ul></li>
</ul></li>
<li>[x] discover the cause of saturation to inform revising the readout circuit
<ul>
<li>I was loading the output of the LIS-770i with the poorly chosen capacitor value for the clock filter</li>
</ul></li>
<li>[x] embedded test of debug LEDs on the <code>mBrd</code>
<ul>
<li>the debug LED demonstrates I can program the <code>mBrd</code></li>
</ul></li>
<li>[x] write a lib to control these four debug LEDs
<ul>
<li>the debug LED is a way to run tests on the <code>mBrd</code></li>
<li>the easiest thing to do is:
<ul>
<li>eliminate <code>static uint8_t debug_led_</code> as a value passed in by <code>DebugLedInit()</code></li>
<li>instead make this a value passed into the actual calls, for example:</li>
<li><code>DebugLedTurnOn()</code> becomes <code>DebugLedTurnOn(uint8_t pin_number)</code> where the <code>pin_number</code> is defined in <code>DebugLed-Hardware.h</code>.</li>
<li>for the existing <code>simBrd</code> code, this changes to <code>DebugLedTurnOn(</code>debug_led`) since the hardware only defines one debug LED.</li>
<li>do not go back and change existing code now
<ul>
<li>it is a little messy</li>
</ul></li>
<li>make a new version of the DebugLed lib just for the mBrd</li>
<li>call it DebugLeds</li>
</ul></li>
</ul></li>
<li>[x] embedded test of lib DebugLeds on the <code>mBrd</code></li>
<li>[x] Spi
<ul>
<li>[x] document Spi stuff in the <code>README</code>, just like you did for <code>FT1248</code></li>
<li>[x] develop the Spi lib</li>
<li>[x] testing the SPI lib is a little more tricky:
<ul>
<li>both the SPI master and SPI slave need working code</li>
<li>this is why I need the debug LED on the <code>mBrd</code> working first</li>
</ul></li>
</ul></li>
<li>[x] then next embedded test application:
<ul>
<li>control the mBrd debug LED through the simBrd using lib Usb and lib Spi</li>
</ul></li>
</ul>
<h2 id="saturation-threshold-lower-than-expected">Saturation Threshold Lower Than Expected</h2>
<h3 id="data-and-notes-are-here">data and notes are here</h3>
<blockquote>
<p><code>C:\chromation-dropbox\Dropbox\ChromationBD\customers\Osram\demo-collaboration\spectrometer-tests\2018-09-07-saturation-investigation\readme.md</code> <code>/cygdrive/c/chromation-dropbox/Dropbox/ChromationBD/customers/Osram/demo-collaboration/spectrometer-tests/2018-09-07-saturation-investigation/readme.md</code> - NERDTree Bookmark: <code>fluttershy-saturation-investigation</code> - online repo: <code>https://rainbots@bitbucket.org/rainbots/fluttershy-saturation-investigation.git</code></p>
</blockquote>
<h2 id="optical-background">Optical background</h2>
<h3 id="data-and-notes-are-here-1">data and notes are here</h3>
<blockquote>
<p><code>C:\chromation-dropbox\Dropbox\ChromationBD\customers\Osram\demo-collaboration\spectrometer-tests\2018-09-06-optical-background</code> <code>/cygdrive/c/chromation-dropbox/Dropbox/ChromationBD/customers/Osram/demo-collaboration/spectrometer-tests/2018-09-06-optical-background</code> - NERDTree Bookmark: <code>fluttershy-optical-background</code> - online repo: <code>https://rainbots@bitbucket.org/rainbots/fluttershy-optical-background.git</code></p>
</blockquote>
<h2 id="latest-improvements">Latest improvements</h2>
<h3 id="lib-usb-passed-its-embedded-system-tests">lib USB passed its embedded system tests</h3>
<ul>
<li>[x] PASS embedded system tests of lib Usb
<ul>
<li>This was a major hurdle to overcome.</li>
<li>There is Python code for the USB host to receive bytes from the embedded system.</li>
<li>The FT1248 hardware settings are proven. They are different from the Earhart FT1248 settings.</li>
</ul></li>
<li>This <code>simBrd.c</code> file will probably become a <code>test-simBrd-Usb.c</code> file.</li>
<li>[x] The final test is to echo bytes
<ul>
<li>[x] create <code>EchoByte()</code>
<ul>
<li>this combines <code>UsbWrite</code> and <code>UsbRead</code></li>
</ul></li>
<li>[x] <code>EchoByte()</code> works for read buffers large enough to read the entire rx buffer in one call</li>
<li>[x] <code>EchoByte()</code> works when the read buffers is only 1-byte in length
<ul>
<li>in this case, each <code>UsbRead</code> terminates after reading a single byte because the read buffer is full</li>
<li>after writing the byte, <code>UsbRead</code> is called again because the rx buffer still has data</li>
<li>my implementation of <code>UsbRead()</code> is robust: it terminates after reading all bytes or after running out of space in its read buffer</li>
<li>this made writing <code>EchoByte()</code> shockingly easy</li>
</ul></li>
</ul></li>
</ul>
<h2 id="lib-organization">lib organization</h2>
<h3 id="libs-for-communication">libs for communication</h3>
<h4 id="ft1248">Ft1248</h4>
<ul>
<li>communication between the MCU and the USB bridge</li>
<li>split into porcelain and plumbing</li>
<li>porcelain calls are for interfacing with a higher-level lib</li>
<li>plumbing calls eliminate comment-noise in the porcelain calls</li>
<li>lib Usb only touches the porcelain</li>
</ul>
<h4 id="usb">Usb</h4>
<ul>
<li>encapsulates Ft1248</li>
<li>user never needs to know about Ft1248 communication at the firmware level:
<ul>
<li>use writes a USB host application with the FTDI d2xx lib</li>
<li>these libraries have nothing to do with Ft1248 communication</li>
<li>my goal was to keep the interface as simple as possible</li>
<li>write the USB host application looking at the embedded <code>main</code> code:
<ul>
<li><code>main</code> code makes calls to Usb lib</li>
<li>Ft1248 lib calls are hidden</li>
</ul></li>
</ul></li>
<li>nothing to do with USB protocol
<ul>
<li>all USB protocol is done by the USB bridge</li>
<li>so no <code>open</code>, <code>close</code>, or <code>device-name</code> functionality
<ul>
<li>that all happens at the application level on the USB host</li>
</ul></li>
</ul></li>
<li>but I call this lib <em>Usb</em> because that is the connecting cable
<ul>
<li>Usb is a bad name because this has nothing to do with USB</li>
<li>but it is the natural name for the USB host application developer to look for when searching the embedded code to develop their USB communication code</li>
<li>what else could I call it? Ft1248 naturally divided into three levels of abstraction:
<ul>
<li>bottom: each bare-metal bit-push
<ul>
<li>example: <code>FtActivateInterface</code> to <em>pull SS low</em></li>
</ul></li>
<li>middle: coordinated bit-pushes that achieve a single purpose and so are wrapped into a single function
<ul>
<li>example: <code>FtRead</code> to read one byte from the receive buffer</li>
</ul></li>
<li>top: combining and looping those many functions into three simple abstractions: ready, read, write
<ul>
<li>example: <code>UsbRead</code> to read all bytes from the receive buffer</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="spimaster-and-spislave">SpiMaster and SpiSlave</h4>
<ul>
<li>master SPI on simBrd talks to slave SPI on mBrd</li>
</ul>
<h4 id="uartspi">UartSpi</h4>
<ul>
<li>USART module on <code>mBrd</code> is the SPI master</li>
<li>For reading data from the <em>ADC</em> on the <code>mBrd</code></li>
<li>see PDF sketch <code>mcu-usart-in-spi-mode-for-adc-spi.pdf</code>
<ul>
<li>explains USART configuration for MSPIM</li>
</ul></li>
</ul>
<h5 id="adc">ADC</h5>
<ul>
<li>LTC1864L</li>
</ul>
<h5 id="analog-overview">analog overview</h5>
<ul>
<li>16-bit SAR ADC with a differential input and a unipolar transfer function
<ul>
<li>Differential input means the analog voltage is the difference between inputs IN+ and IN-
<ul>
<li>IN- connects to the LIS-770i VREF (dark reference) output</li>
<li>the difference between IN+ and IN- is the dark-corrected pixel voltage</li>
</ul></li>
<li>Unipolar transfer function means the allowed analog voltages range from 0V to 2.5V.</li>
</ul></li>
<li>~use a 2.5V external reference~
<ul>
<li>original build uses 2.5V, then switched to 2.048V</li>
</ul></li>
<li>new design: use a 1.8V external reference</li>
</ul>
<h5 id="digital-interface">digital interface</h5>
<ul>
<li>communicate with ADC over SPI to read the pixel voltages as 16-bit values:
<ul>
<li>ADC is the SPI slave</li>
<li>ATmega328 on <code>mBrd</code> is the SPI master
<ul>
<li>uses the USART in SPI master mode</li>
<li>Slave select (or chip select) is just a general purpose i/o</li>
<li>the clock is USART XCK</li>
<li>MISO is USART RxD</li>
<li>there is no MOSI connection: the ADC is a read-only device</li>
</ul></li>
</ul></li>
</ul>
<h4 id="lis-io">Lis-io</h4>
<ul>
<li>readout</li>
<li>programmable setup</li>
</ul>
<h4 id="i2c">I2c</h4>
<ul>
<li>talks to the i2c slave LED driver on the RGB LED board</li>
<li>RGB LED board connection is available on both the mBrd and simBrd</li>
<li>useful for dev and demos</li>
<li>this lib was dropped because the LED driver part is obsolete
<ul>
<li>use these pins for a hardware LED driver trigger signal instead</li>
</ul></li>
</ul>
<h3 id="other-libs">other libs</h3>
<h4 id="debugled">DebugLed</h4>
<ul>
<li>controls the DebugLed</li>
<li>simBrd has one debug LED</li>
<li>mBrd has four debug LEDs</li>
</ul>
<h4 id="readwritebits">ReadWriteBits</h4>
<ul>
<li>reads and writes bits given a register name and a bit number</li>
<li>abstracts one level above the bit-mask operations</li>
<li>eliminates comment-noise in the low-level libs</li>
</ul>
<h2 id="estimate-progress">estimate progress</h2>
<ul>
<li>estimate percentage finished: <code>18%</code></li>
</ul>
<h3 id="estimate-details">estimate details:</h3>
<ul>
<li><em>number of tests written</em> is a crude progress indicator</li>
<li>for the purposes of estimating:</li>
<li>assume 50 tests per module
<ul>
<li>this is a bit of an over-estimate</li>
<li>it is crude fudge factor to allow for system tests and embedded tests</li>
</ul></li>
<li>treat Usb and Ft1248 as one module split into two libs</li>
<li>ignore ReadWriteBits because it is done</li>
<li>ignore DebugLed because it works for one LED</li>
<li>number of module used in estimate: <code>5</code></li>
<li>estimated number of tests total: <code>250</code></li>
<li>number of tests written so far: <code>57</code></li>
<li>number of tests written that are part of the estimated total: <code>45</code></li>
</ul>
<h3 id="system-tests">system tests</h3>
<ul>
<li><em>system tests</em> are done as needed and become part of the test suite</li>
<li>these are part of the automated test suite</li>
<li>uses hardware fakes</li>
<li>no mocks:
<ul>
<li>high-level lib makes call to <em>actual</em> low-level lib</li>
</ul></li>
</ul>
<h3 id="embedded-tests">embedded tests</h3>
<h4 id="overview">overview</h4>
<ul>
<li><em>embedded tests</em> are done each time a lib is finished and there is a new testable something</li>
<li>these are manual test applications</li>
<li>runs on actual hardware</li>
<li>testing requires reprogramming the MCU and manually interacting with the hardware:
<ul>
<li>look at debug LED</li>
<li>read response on screen in serial communication script</li>
</ul></li>
<li>the embedded test code is structured like a series of tests even though there is no test runner. I am the test runner.</li>
<li>This means I can revisit past embedded tests, I don’t just see it pass and then delete it.
<ul>
<li>example: revisiting passing embedded tests helped me identify the correct <code>FT1248 Hardware Settings</code> #### comparison of embedded tests and lib unit tests ##### manual vs automated</li>
</ul></li>
<li>lib unit tests are automated, so they are easy to run</li>
<li>embedded tests are manual, making them a pain in the ass to check</li>
<li>all lib unit tests are run anytime the lib code base changes to confirm that the code base still behaves as promised</li>
<li>once an embedded test passes, it is only run again when trying to debug some unexpected behavior by revisiting past behaviors to sanity check that they have not broken ##### code examples vs code as the specification doc</li>
<li>lib unit tests read as a specification of the lib functionality</li>
<li>an embedded test reads as a contract: run this test to see this behavior</li>
<li>embedded tests sometimes read as checks on the lib functionality, but not always
<ul>
<li>example of a check on lib functionality: <code>UsbWrite_took_the_happy_path_if_debug_led_is_green</code></li>
<li>in actual applications, the debug LED really will be green if <code>UsbWrite</code> follows its happy path</li>
</ul></li>
<li>sometimes the test name is just me doing something to make the test result observable</li>
<li>in this case, the test is not confirming any lib functionality, it is just illustrating a code snippet with some behavior under some use case and describing how to verify that the correct behavior occurs
<ul>
<li>example: <code>Turn_debug_led_red_when_there_is_a_byte_to_read</code></li>
<li>in actual applications, the debug LED will not turn red when there is a byte to read</li>
<li>but turning the LED red made it easy to check that the embedded system is able to detect when there is a byte to read</li>
</ul></li>
</ul>
<h2 id="track-progress-by-lib">track progress by lib</h2>
<h3 id="x-ft1248">[x] Ft1248</h3>
<ul>
<li>28 unit tests</li>
<li>26 functions
<ul>
<li>7 API functions for Usb</li>
<li>19 plumbing functions
<ul>
<li>some legitimate plumbing, i.e., low-level functionality that is occassionally useful</li>
<li>some only exposed for tests</li>
</ul></li>
<li>0 private functions
<ul>
<li>I was learning how to mock while writing this lib, so I exposed everything for mocking!</li>
</ul></li>
</ul></li>
<li>0 embedded system tests (Usb is the API)</li>
<li>[ ] TODO: decide if applications using lib <code>Usb</code> need to include lib <code>Ft1248</code>
<ul>
<li>final application definitely needs to include <code>Ft1248-Hardware.h</code></li>
<li>but does it need to include <code>Ft1248.h</code>? ### [x] Usb</li>
</ul></li>
<li>17 unit tests</li>
<li>5 API functions</li>
<li>0 private functions (Usb is the API for Ft1248)</li>
<li>6 embedded system tests ### [x] Spi</li>
<li>16 unit tests</li>
<li>17 functions
<ul>
<li>5 API</li>
<li>2 plumbing to wrap AVR asm macros</li>
<li>10 private
<ul>
<li>not counting private implementations for public function pointers</li>
</ul></li>
</ul></li>
<li>break down by Master and Slave</li>
<li>SpiMaster
<ul>
<li>11 unit tests</li>
<li>10 embedded system tests
<ul>
<li>8 manual embedded system tests</li>
<li>2 automated embedded system tests
<ul>
<li>tests run on power-up</li>
<li>read tests on a USB host by reading all available bytes on the USB port</li>
<li>automated tests use lib Usb, so these only run on the <code>simBrd</code></li>
</ul></li>
</ul></li>
<li>2 API functions</li>
</ul></li>
<li>SpiSlave
<ul>
<li>5 unit tests</li>
<li>9 embedded system tests
<ul>
<li>5 embedded system tests showing application examples</li>
<li>4 embedded system tests</li>
</ul></li>
<li>3 API functions</li>
<li>2 plumbing functions
<ul>
<li>one function to wrap each AVR asm macro ### [x] UartSpi</li>
</ul></li>
</ul></li>
<li>12 unit tests</li>
<li>21 functions
<ul>
<li>2 API</li>
<li>1 plumbing to wrap AVR asm delay loop</li>
<li>18 private
<ul>
<li>not counting private implementations for public function pointers ### LisIo</li>
</ul></li>
</ul></li>
<li>[ ] Lis-io
<ul>
<li>[x] initialization</li>
<li>[x] clock signal generation</li>
<li>[ ] frame readout ### ReadWriteBits</li>
</ul></li>
<li>[x] ReadWriteBits
<ul>
<li>10 tests</li>
<li>5 functions ### DebugLed</li>
</ul></li>
<li>[x] DebugLed for one LED
<ul>
<li>2 tests</li>
<li>9 functions</li>
<li>TODO: rewrite this test code
<ul>
<li>simplify hardware interface and eliminate dumb initialization</li>
<li>pin down all the behaviors of this lib
<ul>
<li>split <code>init</code> into two tests:
<ul>
<li><code>init turns led on</code></li>
<li><code>init turns led green</code></li>
</ul></li>
<li>add tests for the plumbing behavior ### DebugLeds</li>
</ul></li>
</ul></li>
</ul></li>
<li>[x] DebugLeds for four LEDs
<ul>
<li><em>goal</em>:
<ul>
<li>indicate a four-bit error code redefinable on a per-test basis</li>
<li>combine with lib <code>DebugLed</code> into a single lib where you say how many LEDs there are</li>
</ul></li>
<li><em>minimum viable</em>:
<ul>
<li>[x] just use one LED!</li>
<li>[x] provide plumbing for all four LEDs! ### I2c</li>
</ul></li>
</ul></li>
<li>[-] I2c
<ul>
<li>I am not writing this lib anymore</li>
<li>the part it was for communication with is now obsolete! # Internal deadline ## Context</li>
</ul></li>
<li>This was originally a writeup for Kulite.
<ul>
<li>Kulite went with a TSL1401 prototype instead, so they never saw this.</li>
</ul></li>
<li>But the time breakdown is still useful internally:
<ul>
<li>use the 16-day estimate to finish embedded work</li>
<li>final deliverable describes minimum viable to further internal goals</li>
</ul></li>
<li>The crossed-out dates are from the original estimate.
<ul>
<li>I assumed my first working day back from Sensors Expo would be <code>7/2</code></li>
<li>But after Sensors Expo follow-up, meetings, July 4th, and Kurt’s birthday on July 6th, my first day back on this project ended up being <code>7/9</code></li>
</ul></li>
</ul>
<h2 id="deliverables-for-august">Deliverables for August</h2>
<ul>
<li>High-resolution spectrometer prototype using LIS-770i and n=7 die with custom-machined housing to mate with 20mm x 20mm LIS-770i daughterboard and an attachment for a #8-32 set-screw for mounting on an optical post.</li>
<li>Wavelength map.</li>
<li>Instructions on acquiring a single frame of data over USB.</li>
</ul>
<h2 id="deadline">Deadline</h2>
<p>[x] Estimated deadline for deliverable prototype to <del>ship to Kulite</del> use internally: <del><code>8/14</code></del> <code>8/17</code></p>
<ul>
<li>broken into two deadlines
<ul>
<li>Embedded development</li>
<li>measurement interface</li>
</ul></li>
</ul>
<h3 id="embedded-development">embedded development</h3>
<p>[x] Estimated deadline for embedded development: <code>8/7</code></p>
<h4 id="updated-estimate-for-embedded-development">2018-07-19 updated estimate for embedded development</h4>
<ul>
<li>total number of tests: <code>205</code></li>
<li>find total labor time: <code>205 tests * 15 min/test = 3075 minutes = 51.25 hours</code>
<ul>
<li>estimate number of actual days: <code>62.5 hours / 4 hours/day = 12.8125 days</code></li>
</ul></li>
<li>plot days on calendar to find finished date
<ul>
<li>start the clock <code>7/19</code></li>
<li>count forward 13 days to <code>8/7</code> #### 2018-07-09 estimate for embedded development</li>
</ul></li>
<li>total number of tests: <code>250</code>
<ul>
<li>estimate tests per module: <code>50</code></li>
<li>estimate number of modules: <code>5</code></li>
<li>total number of tests: <code>50 tests/module * 5 modules = 250</code></li>
</ul></li>
<li>labor time and actual time are different</li>
<li>convert labor time to actual time using productive percentage of day: <code>50%</code>
<ul>
<li>this percentage accounts for any-time not spent on this project</li>
<li>e.g., meetings, PCB design, eval kits</li>
</ul></li>
<li>estimate actual labor time per day: <code>8 hours/day * 50% = 4 hours/day</code></li>
<li>find total labor time: <code>250 tests * 15 min/test = 3750 minutes = 62.5 hours</code>
<ul>
<li>estimate number of actual days: <code>62.5 hours / 4 hours/day = 15.625 days</code></li>
</ul></li>
<li>plot days on calendar to find finished date
<ul>
<li>start the clock the week after SensorsExpo: first day is <del><code>7/2</code></del> <code>7/9</code></li>
<li>count forward 16 days to <del><code>7/25</code></del> <code>7/31</code></li>
</ul></li>
</ul>
<h3 id="measurement-interface">measurement interface</h3>
<p>[x] Estimate deadline for measurement interface:<code>8/16</code> #### 2018-07-19 estimate for measurement interface - goal is to finish in time for board meeting - start date: <code>Deadline for Embedded development</code> - that gives me 7 days - let the time limit set the goals - Estimate deadline for measurement interface: <code>8/16</code></p>
<ul>
<li>goal: modified monochromator setup for generating a map
<ul>
<li>main hurdle:
<ul>
<li>modify LabVIEW communication for the new firmware</li>
</ul></li>
<li>approach:
<ul>
<li>this is throw-away code to <del>meet the Kulite deliverable</del> demo to PVP</li>
<li>Python interface is longer term</li>
</ul></li>
<li>Tanya is handling machining of custom housing
<ul>
<li>this mounts to the LIS-770i daughterboard</li>
</ul></li>
<li>laser cut base plates to hold the readout electronics:
<ul>
<li>mBrd</li>
<li>simBrd</li>
</ul></li>
<li>no MacroFab orders are required to meet the goal
<ul>
<li>we have several LIS-770i daughterboards</li>
<li>we have two of each of the readout boards</li>
</ul></li>
<li>but I do need to order MacroFab daughterboards to try the <em>QuikPak</em> part</li>
</ul></li>
</ul>
<h3 id="estimating-time-per-test">Estimating time per test</h3>
<h4 id="velocity-is-1-hour">2018-07-10 velocity is 1 hour</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="im">import</span> datetime <span class="im">as</span> dt</a>
<a class="sourceLine" id="cb4-2" title="2">start <span class="op">=</span> dt.datetime.strptime(<span class="st">&quot;11:26:01&quot;</span>,  <span class="st">&quot;%H:%M:%S&quot;</span>)</a>
<a class="sourceLine" id="cb4-3" title="3">stop  <span class="op">=</span> dt.datetime.strptime(<span class="st">&quot;15:14:32&quot;</span>, <span class="st">&quot;%H:%M:%S&quot;</span>)</a>
<a class="sourceLine" id="cb4-4" title="4">total <span class="op">=</span> stop <span class="op">-</span> start</a>
<a class="sourceLine" id="cb4-5" title="5">mean <span class="op">=</span> (total.seconds<span class="op">-</span> <span class="dv">1800</span>)<span class="op">/</span><span class="dv">9</span></a></code></pre></div>
<p>I subtracted 1800 seconds to account for a 30-minute lunch break. <em>The mean time per test development is 3970 seconds, or 1 hour and 7 minutes.</em> - This is much longer than previously. It is two effects: - these tests are on a high-level lib <code>Usb</code> - the high-level lib requires mocking of functions I already had defined which requires doing some manual operations - this was my first day <em>back</em> after Sensors Expo - also, some work went into another test that I am not counting in this total because the test was not finished – I realized it was better to implement the functionality in these simpler tests first - Even with those caveats, I should readjust my prediction with a more conservative velocity.</p>
<h4 id="velocity-is-15-minutes">2018-06-20 velocity is 15 minutes</h4>
<ul>
<li>look at git log: what is the average time per test?
<ul>
<li>Vim <code>gL</code> logs timestamped commits to <code>git-commits.md</code></li>
<li>2018-06-20 11:48:45 -0400 79 minutes ago FtDeactivateInterface pulls SS high.</li>
<li>2018-06-20 11:43:11 -0400 84 minutes ago FtReadData returns the value on MIOSIO.</li>
<li>2018-06-20 11:27:07 -0400 2 hours ago FtRead reads bytes from MIOSIO.</li>
<li>2018-06-20 10:56:00 -0400 2 hours ago FtIsBusOk returns false if MISO is high.</li>
<li>2018-06-20 10:53:49 -0400 2 hours ago FtIsBusOk returns true if MISO is low.</li>
<li>2018-06-20 10:33:57 -0400 3 hours ago TDD FtBusTurnaround.</li>
<li>2018-06-20 10:12:03 -0400 3 hours ago TDD FtLetSlaveDriveBus.</li>
<li>2018-06-20 10:02:23 -0400 3 hours ago TDD FtPullData.</li>
<li>2018-06-20 09:56:22 -0400 3 hours ago TDD FtLetMasterDriveBus.</li>
<li>2018-06-20 09:40:11 -0400 3 hours ago Document how to abstract memory-mapped io.</li>
</ul></li>
<li>count the earliest commit here as commit 0
<ul>
<li>I don’t know how long it took to do the work for this commit</li>
<li>I am just using its timestamp to measure how long it took before the next commit</li>
<li>then there are 9 commits</li>
<li>each is a test that I wrote and made pass</li>
<li>the total time spanned is</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="im">import</span> datetime <span class="im">as</span> dt</a>
<a class="sourceLine" id="cb5-2" title="2">start <span class="op">=</span> dt.datetime.strptime(<span class="st">&quot;9:40:11&quot;</span>,  <span class="st">&quot;%H:%M:%S&quot;</span>)</a>
<a class="sourceLine" id="cb5-3" title="3">stop  <span class="op">=</span> dt.datetime.strptime(<span class="st">&quot;11:48:45&quot;</span>, <span class="st">&quot;%H:%M:%S&quot;</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">total <span class="op">=</span> stop <span class="op">-</span> start</a>
<a class="sourceLine" id="cb5-5" title="5">mean <span class="op">=</span> total.seconds<span class="op">/</span><span class="dv">9</span></a></code></pre></div>
<em>The mean time per test development is 857 seconds, or 14.3 minutes.</em></li>
</ul>
<p>Display the total time in HH:MM:SS by simply printing <code>total</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="bu">print</span>(total)</a></code></pre></div>
<p>This yields <code>2:08:34</code> (2 hours, 8 mnutes, 34 seconds).</p>
<p>Access the total time in seconds with <code>total.seconds</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1"><span class="bu">print</span>(total.seconds)</a></code></pre></div>
<p>This yields <code>7714</code> seconds.</p>
<h1 id="lis-770i-project-code-organization">LIS-770i project code organization</h1>
<p>Separate project code into sub-folders by board name:</p>
<ul>
<li>simBrd</li>
<li>mBrd</li>
</ul>
<p>Libraries are shared:</p>
<ul>
<li>libraries are not in a project folder</li>
<li>the libraries are developed in their own folder called <code>lib</code></li>
<li>the projects link against the object files in <code>lib</code></li>
</ul>
<h1 id="abstract-memory-mapped-io-for-tests">Abstract memory-mapped-io for tests</h1>
<p><em>The <code>avr</code> headers and libraries set up the memory-mapped I/O registers as if their name is a dereferenced pointer.</em></p>
<p>See the ATmega328 header for definitions: <code>/cygdrive/c/Program Files (x86)/Atmel/Studio/7.0/toolchain/avr8/avr8-gnu-toolchain/avr/include/avr/iom328p.h</code></p>
<p>Each library has a <code>lib-Hardware.h</code> file that includes <code>avr/io.h</code> which I think then uses the <code>iom328p.h</code> file via the <code>-mmcu</code> compiler flag:</p>
<pre class="make"><code>#=====[ AVR ]=====
# atmega328_lib has the .o and .a lib files and the spec file.
atmega328_lib = &#39;/cygdrive/c/Program Files (x86)/Atmel/Studio/7.0/packs/atmel/ATmega_DFP/1.2.203/gcc/dev/atmega328p/&#39;

-mmcu=atmega328p -B ${atmega328_lib}</code></pre>
<p>And for standard C libraries like <code>stdint</code> and <code>stdbool</code>, <code>avrgcc</code> defines its own implementations. For example, here is <code>stdint.h</code>:</p>
<p><code>/cygdrive/c/Program Files (x86)/Atmel/Studio/7.0/toolchain/avr8/avr8-gnu-toolchain/avr/include/stdint.h</code></p>
<p>The <code>_BV()</code> macro for the <code>bit-value of</code> is here:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="co">// /cygdrive/c/Program Files (x86)/Atmel/Studio/7.0/toolchain/avr8/avr8-gnu-toolchain/avr/include/avr/sfr_defs.h</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="pp">#define _BV(bit) (1 &lt;&lt; (bit))</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="pp">#define bit_is_set(sfr, bit) (_SFR_BYTE(sfr) &amp; _BV(bit))</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="pp">#define bit_is_clear(sfr, bit) (!(_SFR_BYTE(sfr) &amp; _BV(bit)))</span></a></code></pre></div>
<p>Of course you cannot use <code>_BV()</code> in your libs because they are cross-compiled.</p>
<ul>
<li>Use I/O register names and pin names specific to the embedded project instead of names specific to the AVR microcontroller.</li>
<li>Declare these names as <code>extern</code> in the lib header.</li>
<li>Define these <code>extern</code> symbols in a file named <code>lib-Hardware.h</code>, e.g., lib <code>Ft1248</code> has a file named <code>Ft1248-Hardware.h</code></li>
<li>there are at least two versions of this hardware file
<ul>
<li>both have the same name, but they are in different folders</li>
<li>one is in the sub-folder for the PCB:
<ul>
<li>e.g., PCB <code>simBrd</code> has a subfolder named <code>simBrd</code>:</li>
<li><code>LIS-770i/lib/src/simBrd/Ft1248-Hardware.h</code></li>
</ul></li>
<li>the other is in the <code>test</code> folder as a <code>fake</code>:
<ul>
<li><code>LIS-770i/lib/test/fake/Ft1248-Hardware.h</code></li>
</ul></li>
</ul></li>
</ul>
<h2 id="faking-io-registers">Faking io registers</h2>
<p>=====[ <code>LIS-770i/lib/src/Ft1248.h</code> ]=====</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">extern</span> <span class="dt">uint8_t</span> <span class="dt">volatile</span> * <span class="dt">const</span> Ft1248_port;</a></code></pre></div>
<p><code>Ft1248_port</code> is the name the <code>Ft1248</code> lib uses for some memory-mapped IO. What is the actual address? <code>Ft1248</code> lib does not care. It up to the client of <code>Ft1248</code> lib to set the address.</p>
<h3 id="test-code-as-a-client">test code as a client</h3>
<p>The test code that tests the <code>Ft1248</code> lib is a client of <code>Ft1248</code> lib. Here is some test code to test one of the low-level functions in <code>Ft1248</code> lib.</p>
<p>=====[ <code>LIS-770i/lib/test/test_Ft1248.c</code> ]=====</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="dt">void</span> FtOutputByte_outputs_a_byte_on_port_MIOSIO(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb11-2" title="2">{</a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="co">//TEST_FAIL_MESSAGE(&quot;Implement test.&quot;);</span></a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="co">//=====[ Setup ]=====</span></a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="dt">uint8_t</span> byte_to_write = <span class="bn">0xAB</span>;</a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="dt">uint8_t</span> expected_miosio = byte_to_write;</a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="co">//=====[ Operate ]=====</span></a>
<a class="sourceLine" id="cb11-8" title="8">    FtOutputByte(byte_to_write);</a>
<a class="sourceLine" id="cb11-9" title="9">    <span class="co">//=====[ Test ]=====</span></a>
<a class="sourceLine" id="cb11-10" title="10">    <span class="dt">uint8_t</span> actual_miosio = *FtMiosio_port; <span class="co">// value in miosio port</span></a>
<a class="sourceLine" id="cb11-11" title="11">    TEST_ASSERT_EQUAL_HEX8( expected_miosio, actual_miosio );</a>
<a class="sourceLine" id="cb11-12" title="12">}</a></code></pre></div>
<p>This test code calls <code>FtOutputByte()</code> and <code>FtOutputByte()</code> writes to the address of the <code>FtMiosio_port</code>.</p>
<p>The test code runs on my computer. My computer does not have the same addresses used by the MCU. Those addresses point somewhere in kernel space on my computer. If I try to access an address in kernel space, the test executable has a segmentation fault.</p>
<p>Instead, the test code uses an arbitrary address chosen by the compiler. The client sets up that address by including this fake version of the <code>Ft1248-Hardware.h</code> header file:</p>
<p>=====[ <code>LIS-770i/lib/test/fake/Ft1248-Hardware.h</code> ]=====</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="dt">static</span> <span class="dt">uint8_t</span> <span class="dt">volatile</span> value_in_fake_Ft1248_port;</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="dt">uint8_t</span> <span class="dt">volatile</span> * <span class="dt">const</span> Ft1248_port    =   &amp;value_in_fake_Ft1248_port;</a></code></pre></div>
<p>The header creates a dummy value of the right number of bytes. Since this is faking an 8-bit microcontroller, it’s just one byte. The symbol with the <code>extern</code> declaration in the lib header file, <code>Ft1248_port</code>, is defined here to point to the address of this dummy value.</p>
<h3 id="embedded-system-as-a-client">embedded system as a client</h3>
<p>The embedded system is another client of the <code>Ft1248</code> lib. This is the production code. It needs to use the actual address of the <code>Ft1248_port</code> specific to the microcontroller target and specific to the PCB the microcontroller is soldered to.</p>
<p>The embedded system on the <code>simBrd</code> PCB includes this version of the <code>Ft1248-Hardware.h</code> header:</p>
<p>=====[ LIS-770i/lib/src/simBrd/Ft1248-Hardware.h ]=====</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="pp">#include </span><span class="im">&lt;avr/io.h&gt;</span><span class="pp">  </span><span class="co">// defines IO addresses and pin names</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="dt">uint8_t</span> <span class="dt">volatile</span> * <span class="dt">const</span> Ft1248_port    =   &amp;PORTC; <span class="co">// output (Port out)</span></a></code></pre></div>
<p>The <code>simBrd</code> uses an <code>Atmega328P</code> microcontroller. When I designed the <code>simBrd</code> PCB, I decided <code>PORTC</code> would handle the <code>Ft1248</code> control signals.</p>
<p>The <code>avr/io.h</code> file defines the numeric address of <code>PORTC</code> for the <code>ATmega328P</code> microcontroller. <code>PORTC</code> is the pnemonic the vendor provides. The pnemonic is handy for referencing this register in the <code>ATmega328P</code> datasheet. And many AVR microcontrollers have a <code>PORTC</code> with similar functionality, even if the specific address is different on each part.</p>
<h2 id="thought-process-on-faking-io-this-way">Thought process on faking io this way</h2>
<h3 id="run-time-injection-is-stupid-complicated">run time injection is stupid complicated</h3>
<p>My first solution to testing code with IO dependencies was to use <em>run-time injection</em>. See repo <code>mock-object</code> for an example. This means that register IO addresses and pin numbers are loaded into memory at run-time instead of compile-time.</p>
<p>My libraries have functions that operate on memory-mapped IO, but the library object files do not specify the addresses and pin numbers, only the datatype (byte size) of each address. It was up to the client of the library to call an <code>init()</code> function to load the specific values. Those values came from a hardware header that specified those details. Depending on which hardware header was included in the client code, the same library functions operated on different pin numbers for different PCBs, or even different addresses depending on if the client runs on the embedded target or as a test on a computer.</p>
<p>The only benefit of run-time injection is to allow a single run-time to instantiate a lib multiple times. But my libs do not define objects. I do not need that level of complexity. All of my libs only have a single instance. The instance is created by the compiler and placed in static memory, and it stays in memory for as long the microcontroller is powered. There is no reason to make this memory management manual. Since my libs do not describe objects, there is no benefit to using run-time injection.</p>
<p>Loading the addresses in at runtime has three drawbacks.</p>
<ul>
<li>The main drawback is that test fixturing is complicated. Setup and Teardown need to load and unload these addresses.</li>
<li>Similarly, the lib <code>init()</code> function is noisy: a huge argument list loads all the memory-mapped io data, and the actual initialization functionality is buried at the end.</li>
<li>The last drawback is that I/O data takes up static memory.</li>
</ul>
<h3 id="optimizing-for-sanity-and-simplicity">optimizing for sanity and simplicity</h3>
<p>Simple is always good. That was the problem with run-time injection. So I went back to the <code>just use vendor macros</code> idea and made the smallest adjustments I could to address my problems.</p>
<p>The method I used before I embraced TDD is to simply define all I/O dependencies at compile-time by using the vendor’s macro names. This is straight-forward, but then the code cannot be tested because it only runs on the target microcontroller. The code is also just less readable.</p>
<p>A small improvement on this is to define project-specific macros to alias the vendor macro names. I used to do this, purely to make the code easier to read, but I never tried running tests that used this method. I guess the project code is tested under this method by including a header that defines the macros using dummy values instead of the vendor values. This approach still does not solve the testing problem when it comes to lib code. Library code cannot be developed separately: the lib code gets compiled with either the vendor macros or the dummy macros. Depending on the executable target, the libs have to be recompiled.</p>
<p>A final small improvement on this is to use <code>const</code> variables instead of macros. Library code declares memory-mapped I/O as <code>extern</code> in its header file. The same library object file works with both the test-development target and the embedded targets because the <code>extern</code> definitions are resolved when the final executable is linked. Each project creates <code>*lib*-Hardware.h</code> file that provides the definition promised by the <code>extern</code> declaration in the <code>*lib*.h</code> file. These hardware definition files use the vendor-specific macros. Test clients provide their own fake hardware files that let the compiler choose the address instead of using the vendor-specific macro.</p>
<h3 id="my-old-notes-on-this-from-mock-object">my old notes on this from mock-object</h3>
<p><em>The rest of this section was copied from repo <code>mock-object</code> with slight edits to match the info above.</em></p>
<p>Embedded design has <em>hardware dependencies</em>. The hardware dependency is a memory-mapped I/O register. The dependency is <em>faked</em> by creating a variable that occupies the same number of bytes as the memory-mapped I/O register. The variable is created in static memory. For me, that means getting an address starting with <code>0x1004</code> such as <code>0x100403120</code>. The <em>ATmega328P</em> is an 8-bit MCU, so the fake registers are 8-bit unsigned integers: <code>uint8_t</code>.</p>
<p>The <code>avr</code> headers and libraries set up the memory-mapped I/O registers as if their name is a dereferenced pointer. For example, <code>DDRC = 0xFF</code> sets the value in register <code>DDRC</code> to <code>0xFF</code>. This is equivalent to creating a pointer to a fake register and dereferencing it to write to the fake register:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="dt">uint8_t</span> <span class="dt">volatile</span> * <span class="dt">const</span> fake_LedRegister;</a>
<a class="sourceLine" id="cb14-2" title="2">*fake_LedRegister = <span class="bn">0xFF</span>;</a></code></pre></div>
<ul>
<li>The fake register is <em>volatile</em> because the compiler should never assume it knows the value. The value might be altered by an interrupt.</li>
<li>The pointer to the fake register is <em>const</em> because <code>fake_LedRegister</code> will never point to anything else in this executable, just as <code>DDRC</code> is the permanent alias to a specific address on this microcontroller.</li>
</ul>
<p><em>Faking enables testing on a development system.</em> It is much faster to compile and test on the development system than on the target embedded system.</p>
<p>Faking forces writing the project code base in a way that is independent of the hardware. The hardware details are stored in static memory and injected at link time when the <code>extern</code> declarations in the hardware library’s header file are resolved by linking against a client that includes a specific <code>lib-Hardware.h</code> header.</p>
<p>Now the question is whether the compiler is smart enough to see that the register addresses are <code>const</code> and hardcode them directly as if they were macros. I should investigate this.</p>
<h1 id="tdd">TDD</h1>
<p>The primary benefit of TDD is <em>workflow</em>. TDD is a sane way to split an intimidating task into smaller tasks. Each task has a clear goal. Focus on the small goal while ignoring the intimidating task. An initial straw man task list gets the first few tasks queued up. As the tasks are developed into tests, the details become clearer and the task list is revised. By expressing each small task as code it is very clear:</p>
<ul>
<li>how to proceed on the task</li>
<li>when the task is finished</li>
</ul>
<p>At some point, you step back and look at the list of completed tasks, i.e., the list of passing tests, and you realize the initial intimidating task is done.</p>
<p>My old workflow was pretty simple. The drawback is that I end up with code that I am afraid to make changes to, which means at some point I am no longer able to add functionality without doing a complete rewrite.</p>
<ul>
<li>start writing the application and check the control flow as I go by turning the debug LED red</li>
<li>bootstrap the application: as it grows, I am able to check more stuff, e.g., once there is USB communication, I have more ways to check that the code is actually doing what I think its doing</li>
<li>keep doing this until I’ve written the whole application</li>
</ul>
<p>My TDD workflow goes like this. I do not actively use this like a check list, this is just the flow I naturally follow after practicing TDD for the past 6 months. The embedded part are very recent habits I’ve noticed forming in the past week now that I’ve started working with the actual embedded targets: <code>simBrd</code> and <code>mBrd</code>.</p>
<ul>
<li>write an embedded test application
<ul>
<li>this is a very small piece of embedded code that tries to do something, e.g., write one byte or turn the debug LED red when a condition happens</li>
<li>the only goal of this code is that it worksk</li>
<li>do not worry about anything else</li>
<li>proceed each line with a one-liner comment explaining what the code does, e.g., <code>Load the data and start the transmission.</code>
<ul>
<li>the need for these is obvious because the code it explains is cryptic register names and bit names that require referencing the datasheet to interpret</li>
</ul></li>
<li>if there is a large block of code that works together, write a multi-line comment explaining how that block of code behaves under different conditions</li>
</ul></li>
<li>get the embedded test to do what it claims</li>
<li>place the test code in a function that describes the test</li>
<li>add a multi-line comment to this function explaining all the conditions necessary to run this test</li>
<li>comment the test as passing with the date tested</li>
<li>commit the passing embedded test</li>
<li>now turn the embedded code into unit-tested lib code
<ul>
<li>the one-liner comments become the function names in the lib</li>
<li>the multiline block comments become the test cases</li>
</ul></li>
<li>write an initial list of tests</li>
<li>pick a test to work on first</li>
<li>write a function with the test as the name and a body that asserts failure</li>
<li>get the test runner to compile and report the failure</li>
<li>create the <code>Operate</code> section: usually this is just calling the function</li>
<li>if the function does not exist yet, get the test runner to compile</li>
<li>once it compiles, I am back to a failing test</li>
<li>create the <code>Test</code> section: write the real test and erase the asserted failure</li>
<li>once I start expressing the test in code, it is clear what I need in terms of test setup and teardown</li>
<li>create the <code>Setup</code> and <code>Teardown</code> sections</li>
<li>check that this test fails</li>
<li>start editing the production code function body to make this test pass</li>
<li>git commit the passing test</li>
<li>think about a refactor:
<ul>
<li>if I am unhappy with the production code or the test code</li>
<li>and if I have an idea on how to make it better now</li>
<li>then refactor and commit the passing refactored code.</li>
<li>otherwise stick a <code>TODO</code> that says why I am unhappy</li>
<li>it will become clear how to refactor after there are more tests in place</li>
</ul></li>
<li>think about how this test affects the test list:
<ul>
<li>often a test like <code>foo returns true when bar</code> begs a twin test like <code>foo returns false when not bar</code></li>
<li>getting the test to pass shows what functions are needed</li>
</ul></li>
<li>continue this until all of the functionality of the passing embedded code is captured</li>
<li>the unit-tested lib code is the refactored version of the original embedded code</li>
<li>in small pieces, replace the embedded code with the lib code and check that the embedded test still passes</li>
<li>refactor the embedded code as much as possible: it should now be dead simple to understand when you come back to it in the future</li>
<li>this will often result in great example code:
<ul>
<li>neat little functions that seem to application-specific to make them part of the lib, but will probably come in handy later when all of the libs are done and you are working on the final application</li>
</ul></li>
<li>commit the final, refactored, passing, embedded test</li>
<li>if it is clear how to continue extending the lib code, go back to developing the lib, otherwise write some more embedded code</li>
</ul>
<h1 id="mockist-tdd">Mockist TDD</h1>
<h2 id="mocks-are-not-fakes">Mocks are not fakes</h2>
<h3 id="update-only-mock-when-the-test-requires-it">2017-07-19 Update: only mock when the test requires it</h3>
<ul>
<li>if possible, test behavior without comparing call lists</li>
<li>comparing call lists couples tests to implementation details</li>
<li>even tests that stub functions to mock-up a scenario by controlling return values may not need to compare call lists</li>
<li>tests require comparing call lists when:
<ul>
<li>there is no other way to check the behavior</li>
<li>the purpose of the test is to describe one path, e.g.: sad path or happy path</li>
</ul></li>
</ul>
<h3 id="this-section-was-copied-from-repo-mock-object">This section was copied from repo <code>mock-object</code></h3>
<ul>
<li>take any <em>mock-heavy</em> attitudes with a grain of salt <code>&gt;*.*&lt;</code></li>
</ul>
<pre><code>286:    a9 9b           sbis    0x15, 1 ; 21
288:    fe cf           rjmp    .-4         ; 0x286 &lt;DemoMacroFastestRstResponseToClk&gt;
28a:    5e 9a           sbi 0x0b, 6 ; 11
28c:    a9 9a           sbi 0x15, 1 ; 21
28e:    aa 9b           sbis    0x15, 2 ; 21
290:    fe cf           rjmp    .-4         ; 0x28e &lt;DemoMacroFastestRstResponseToClk+0x8&gt;
292:    5e 98           cbi 0x0b, 6 ; 11
294:    aa 9a           sbi 0x15, 2 ; 21
296:    f7 cf           rjmp    .-18        ; 0x286 &lt;DemoMacroFastestRstResponseToClk&gt;</code></pre>
<ul>
<li><code>sbi 0x0b, 6 ; 11</code>
<ul>
<li><code>sbi</code> [S]et [B]it in [I]/O register</li>
<li>takes 2 clock cycles</li>
<li>register address <code>0x0b (0x2b)</code> is register name <code>PORTD</code></li>
<li>bit <code>6</code> is bit name <code>PD6</code>
<ul>
<li>I set <code>const uint8_t Lis_Rst</code> equal to macro <code>PD6</code> in <code>Lis-Hardware.h</code></li>
<li>note there is no overhead penalty for this abstraction</li>
<li>the compiler takes the substitution to the end, using the bit number defined by the macro</li>
</ul></li>
</ul></li>
<li><code>sbi 0x15, 1 ; 21</code>
<ul>
<li>clear the OCF0A flag by setting the bit</li>
<li>takes 2 clock cycles</li>
</ul></li>
<li><code>sbis 0x15, 1 ; 21</code>
<ul>
<li><code>sbis</code> [S]kip if [B]it in [I]/O register is [S]et</li>
<li>register address <code>0x15 (0x35)</code> is register name <code>TIFR0</code></li>
<li>bit <code>1</code> is bit name <code>OCF0A</code></li>
<li>takes 1/2/3 clock cycles</li>
</ul></li>
<li><code>rjmp .-4 ; 0x286</code>
<ul>
<li><code>rjmp</code> is [R]elative [J]u[MP]</li>
<li>takes 2 clock cycles</li>
<li>in hand-written code this would jump to a label</li>
<li>here I guess the notation <code>.-4</code> means <em>relative to the location of the program counter after this line executes</em> go <em>back 4 bytes</em> in program memory</li>
</ul></li>
<li>after translating this segment of assembly, I think it is the fastest way to express the Rst pin following the Clk pin in software ## AVR asm macros These are macros defined in <code>avr-libc</code>.</li>
</ul>
<h3 id="example">Example</h3>
<ul>
<li>For example:
<ul>
<li><code>Atmel/Studio/7.0/toolchain/avr8/avr8-gnu-toolchain/avr/include/avr/interrupt.h</code></li>
</ul></li>
<li>defines these macros:
<ul>
<li><code>sei()</code> - do the SEI instruction: <em>Global Interrupt Enable</em></li>
<li><code>cli()</code> - do the CLI instruction: <em>Global Interrupt Disable</em></li>
</ul></li>
</ul>
<h3 id="i-wrap-these-inside-functions">I wrap these inside functions</h3>
<p>I wrap these macros inside functions because:</p>
<ul>
<li>my function names are more readable:
<ul>
<li>for example, <code>sei()</code> is wrapped in <code>GlobalInterruptEnable</code></li>
</ul></li>
<li>this allows me to put them in my lib code</li>
</ul>
<p>Like any other lib code, I put these macros in my lib code to hide the details from the application code.</p>
<ul>
<li>For example, when enabling a specific interrupt:
<ul>
<li>globally disable interrupts</li>
<li>clear the pending interrupt, if any, for the specific interrupt being enabled</li>
<li><em>enable the specific interrupt</em> – <strong>this is the goal</strong></li>
<li>then globally re-enable interrupts</li>
</ul></li>
<li>the surrounding <code>cli()</code> and <code>sei()</code> are a precaution that no interrupts occur while I enable this interrupt</li>
<li>clearing any pending interrupt is a precaution against enabling this interrupt and having it execute as soon as I return from this function</li>
</ul>
<h3 id="compiling-lib-code-with-avr-asm-macros">Compiling lib code with AVR asm macros</h3>
<p>Putting the macro in my lib code has a similar problem to putting a register or pin name in my lib code. My test environment compilers, gcc and clang, do not know what these macros are.</p>
<p>I cannot just include the <code>avr-libc</code> header that defines the macros. The macro is inline assembly. The assembly recognized by avr-gcc is not the same assembly recognized by gcc or clang. The inline assembly will compile fine for the avr target, but the unit tests will not compile for the development environment.</p>
<p>My solution is similar to how I fake register and pin names.</p>
<h4 id="recall-strategy-for-faking-register-and-pin-names">Recall strategy for faking register and pin names</h4>
<ul>
<li>register and pin names are just macros for numbers
<ul>
<li>e.g.:</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="pp">#define SPCR _SFR_IO8(0x2C)</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="pp">#define SPR0 0</span></a></code></pre></div></li>
<li>I make a <code>hardware</code> header file specific to the embedded system target</li>
<li>the <code>hardware</code> header file defines variables and assigns them to the register and pin names, just as a variable would be assigned to any literal value</li>
<li>e.g.:</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1"><span class="co">// mBrd/src/Spi-Hardware.h</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="dt">uint8_t</span> <span class="dt">volatile</span> * <span class="dt">const</span> Spi_spcr   = &amp;SPCR;  <span class="co">// SPI control register</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="dt">uint8_t</span> <span class="dt">const</span> Spi_ClockRateBit0     = SPR0;</a></code></pre></div>
<p>This creates a seam for the <em>stub</em> or <em>fake</em>. It substitutes the macro with a variable. I need a variable rather than a macro so that I can assign the value appropriate to the translation unit it is in: the test runner’s translation unit stubs the value, and the application’s translation unit assigns the hardware-specific value. For example, use <code>uint8_t const</code> to substitute for a macro defining an 8-bit register or a bit number. <code>const</code> gives me help from the compiler if I accidentally try to write the variable after initialization. This replaces <code>#define</code> which uses the pre-processor to achieve the same end goal.</p>
<p>While creating this seam I also abstract the name. I suffix the variables with names reflecting which of my libs they belong to.</p>
<ul>
<li>this is just the old <em>no magic numbers</em> mantra</li>
<li>I shift the name from the language domain or hardware domain into the solution domain</li>
</ul>
<p>For example, while developing code, I care about what the pin is used for, e.g., the <code>Spi</code> lib, so I suffix it:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="co">// mBrd/src/Spi-Hardware.h</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="dt">uint8_t</span> <span class="dt">const</span> Spi_Ss    =   PB2;    <span class="co">// slave select driven by the master</span></a></code></pre></div>
<p>I do not care that a pin is on <code>PORTB</code> – that detail was important during PCB layout and planning for the functionality of the embedded system, but I want to forget that detail while developing code. My lib header only has the solution-domain name:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="co">// lib/src/Spi.h</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="kw">extern</span> <span class="dt">uint8_t</span> <span class="dt">const</span> Spi_Ss;</a></code></pre></div>
<p>The same hardware pin can even be used by more than one lib! The lib code is truly abstracted from the hardware.</p>
<p>To make this scheme work:</p>
<ul>
<li>The lib header file:
<ul>
<li>declares those variables as <code>extern</code></li>
<li>only has to match the datatype in the <code>hardware</code> header file</li>
</ul></li>
<li>My test code is otherwise ignorant of the <code>hardware</code> header file and defines those variables in a <code>fake</code> header folder to mirror how it is done in the application code:</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="co">// lib/test/test_Spi.c</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="pp">#include </span><span class="im">&quot;Spi.h&quot;</span><span class="pp">                </span><span class="co">// lib under test</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="pp">#include </span><span class="im">&quot;fake/Spi-Hardware.h&quot;</span><span class="pp">  </span><span class="co">// fake hardware dependencies in Spi.h</span></a></code></pre></div>
<ul>
<li>the <code>extern</code> is resolved here:</li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="co">// lib/test/fake/Spi-Hardware.h</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="dt">uint8_t</span> <span class="dt">const</span> Spi_Ss    =   <span class="dv">2</span>;    <span class="co">// slave select driven by the master</span></a></code></pre></div>
<ul>
<li>My application code defines the hardware values in a separate <code>hardware</code> file to keep the code clean:</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="co">// mBrd/src/Spi-Hardware.h</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="dt">uint8_t</span> <span class="dt">const</span> Spi_Ss    =   PB2;    <span class="co">// slave select driven by the master</span></a></code></pre></div>
<ul>
<li>And the application code includes the lib header to access the lib and the hardware header to define the <code>extern</code> hardware abstractions in the lib:</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="pp">#include </span><span class="im">&lt;Spi.h&gt;</span><span class="pp">                </span><span class="co">// Chromation spectrometer is a SPI slave</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="pp">#include </span><span class="im">&quot;Spi-Hardware.h&quot;</span><span class="pp">       </span><span class="co">// map SPI I/O to actual hardware</span></a></code></pre></div>
<h4 id="solution-for-faking-avr-asm-macros">Solution for faking AVR asm macros</h4>
<p>The solution is a little different because the asm macros are not just numbers, they are inline assembly code. I cannot create the <em>faking seam</em> with a simple <code>const</code> variable.</p>
<p>I create the <em>faking seam</em> by wrapping the macro in a function. Similar to setting up a function for stubbing, I keep the macro wrapper as a private implementation and expose the function pointer for the API.</p>
<p>Here is the implementation in the <code>.c</code> file for the avr targets:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="co">/* =====[ mBrd/AvrAsmMacros.c ]===== */</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="co">/* =====[ simBrd/AvrAsmMacros.c ]===== */</span></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="pp">#include </span><span class="im">&quot;AvrAsmMacros.h&quot;</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="pp">#include </span><span class="im">&lt;avr/interrupt.h&gt;</span><span class="pp">      </span><span class="co">// defines macros `sei()` and `cli()`</span></a>
<a class="sourceLine" id="cb24-5" title="5"></a>
<a class="sourceLine" id="cb24-6" title="6"><span class="co">// sei()</span></a>
<a class="sourceLine" id="cb24-7" title="7"><span class="dt">static</span> <span class="dt">void</span> GlobalInterruptEnable_Implementation(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb24-8" title="8">{ sei(); }</a>
<a class="sourceLine" id="cb24-9" title="9"><span class="dt">void</span> (*GlobalInterruptEnable)(<span class="dt">void</span>) = GlobalInterruptEnable_Implementation;</a></code></pre></div>
<p>Here is the fake implementation in the <code>.c</code> file for the unit test code:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1"><span class="co">/* =====[ lib/test/fake/AvrAsmMacros.c ]===== */</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="pp">#include </span><span class="im">&quot;AvrAsmMacros.h&quot;</span></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="co">/* =====[ Fake the AVR asm macros with empty definitions ]===== */</span></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="co">// sei()</span></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="dt">static</span> <span class="dt">void</span> GlobalInterruptEnable_Implementation(<span class="dt">void</span>) {}</a>
<a class="sourceLine" id="cb25-6" title="6"><span class="dt">void</span> (*GlobalInterruptEnable)(<span class="dt">void</span>) = GlobalInterruptEnable_Implementation;</a></code></pre></div>
<p>And here is the one lib header used by all clients:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1"><span class="co">/* =====[ lib/src/AvrAsmMacros.h ]===== */</span></a>
<a class="sourceLine" id="cb26-2" title="2"><span class="kw">extern</span> <span class="dt">void</span> (*GlobalInterruptEnable)(<span class="dt">void</span>);</a></code></pre></div>
<ul>
<li>The avr target uses the inline assembly implementation.</li>
<li>The unit tests use empty implementations.</li>
</ul>
<p>I cannot unit test these functions because they do nothing. But I can compile them without harm and I can fake their effects within the stack frame of a test case.</p>
<h2 id="interrupts">Interrupts</h2>
<p>Interrupts are yet another macro to deal with.</p>
<ul>
<li>the macro looks like a function that is missing a return type</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1">ISR(SPI_STC_vect)</a>
<a class="sourceLine" id="cb27-2" title="2">{</a>
<a class="sourceLine" id="cb27-3" title="3">    Turn_led1_red_and_the_rest_green();</a>
<a class="sourceLine" id="cb27-4" title="4">}</a></code></pre></div>
<ul>
<li><code>avr-gcc</code> does some useful hidden setup/teardown on entering and exiting the interrupt
<ul>
<li>suspend interrupts while this interrupt executes</li>
<li>call <code>reti()</code> at the end</li>
</ul></li>
</ul>
<p>But I do not like the disconnect between <em>interrupt enablers</em> in one part of the application code and <em>what the interrupt does</em> being described in the body of the interrupt service routine. This really sucks during embedded system tests. I want the test to control the behavior of the ISR. Different tests need different bodies for the ISR. And I want to do this without resorting to conditionals.</p>
<p>I use the <em>command</em> design pattern:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="co">/* =====[ Move control over the SPI ISR into the test code ]===== */</span></a>
<a class="sourceLine" id="cb28-2" title="2"><span class="kw">typedef</span> <span class="dt">void</span> (SPI_ISR_task)(<span class="dt">void</span>); SPI_ISR_task *DoTaskForThisTest;</a>
<a class="sourceLine" id="cb28-3" title="3"><span class="co">//</span></a>
<a class="sourceLine" id="cb28-4" title="4">ISR(SPI_STC_vect)</a>
<a class="sourceLine" id="cb28-5" title="5">{</a>
<a class="sourceLine" id="cb28-6" title="6">    DoTaskForThisTest(); <span class="co">// fptr assigned in test code</span></a>
<a class="sourceLine" id="cb28-7" title="7">}</a></code></pre></div>
<p>The <em>ISR</em> just knows it is doing a task. A task is any function that has no input arguments and returns nothing. The task is selected in the testcase. For example, here is a test case to check that the ISR is being called. If it is called, then <code>debug_led1</code> turns red:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="dt">void</span> SPI_interrupt_routine_turns_debug_led1_red(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb29-2" title="2">{</a>
<a class="sourceLine" id="cb29-3" title="3">    <span class="co">/* =====[ Setup ]===== */</span></a>
<a class="sourceLine" id="cb29-4" title="4">    SpiSlaveInit();</a>
<a class="sourceLine" id="cb29-5" title="5">    DoTaskForThisTest = Turn_led1_red_and_the_rest_green;</a>
<a class="sourceLine" id="cb29-6" title="6">    <span class="co">/* =====[ Operate ]===== */</span></a>
<a class="sourceLine" id="cb29-7" title="7">    SpiEnableInterrupt();</a>
<a class="sourceLine" id="cb29-8" title="8">    <span class="co">/* while(0); // exit loop immediately */</span></a>
<a class="sourceLine" id="cb29-9" title="9">    <span class="cf">while</span>(<span class="dv">1</span>); <span class="co">// loop forever</span></a>
<a class="sourceLine" id="cb29-10" title="10">    DebugLedsTurnAllRed();  <span class="co">// This should *never* be called.</span></a>
<a class="sourceLine" id="cb29-11" title="11">    <span class="co">/* =====[ Test ]===== */</span></a>
<a class="sourceLine" id="cb29-12" title="12">    <span class="co">// Program the SPI Master to send any byte on reset.</span></a>
<a class="sourceLine" id="cb29-13" title="13">    <span class="co">// Visually confirm the debug LEDs are all green.</span></a>
<a class="sourceLine" id="cb29-14" title="14">    <span class="co">// Flip `SW2` to `SPI`. Press the reset button.</span></a>
<a class="sourceLine" id="cb29-15" title="15">    <span class="co">// Visually confirm debug LED 1 turns red.</span></a>
<a class="sourceLine" id="cb29-16" title="16">}</a></code></pre></div>
<p>The ISR behavior is defined by the test case! I can read what this test does without ever looking at the ISR macro.</p>
<h2 id="read-a-register-and-throw-away-the-value">Read a register and throw away the value</h2>
<p>Sometimes it is necessary to read a register to clear a bit flag. The value in the register is garbage, but reading it is the only way to clear the bit in some status register. But now there is a <em>throw-away</em> value that needs to be dealt with.</p>
<p>Here is an example:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="co">// Clear the SPI Interrupt Flag bit in the SPI Status Register.</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="co">// Implementation:</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="co">// Read registers SPSR and SPDR, in that order.</span></a></code></pre></div>
<p>First attempt at an implementation:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb31-1" title="1"><span class="dt">static</span> <span class="dt">void</span> ClearPendingSpiInterrupt(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb31-2" title="2">{</a>
<a class="sourceLine" id="cb31-3" title="3">    <span class="dt">uint8_t</span> <span class="dt">volatile</span> throw_away;</a>
<a class="sourceLine" id="cb31-4" title="4">    throw_away = *Spi_spsr; throw_away = *Spi_spdr;</a>
<a class="sourceLine" id="cb31-5" title="5">}</a></code></pre></div>
<p>Compiling this code with <code>gcc</code> generates a warning that the value is not used:</p>
<pre class="make"><code>|| src/Spi.c: In function ‘ClearPendingSpiInterrupt’:
src/Spi.c|92 col 22| warning: variable ‘throw_away’ set but not used [-Wunused-but-set-variable]
||      uint8_t volatile throw_away;
||                       ^~~~~~~~~~</code></pre>
<p>It is tempting to write this as inline assembly, but the assembly recognized by avr-gcc is not the same assembly recognized by gcc or clang. The inline assembly will compile fine for the avr target, but the unit tests will not compile for the development environment.</p>
<p>One workaround is to write a wrapper for inline assembly. The wrapper has an empty implementation used by test code, and an inline assembly implementation used by the avr-target code. I use this approach to place the <code>AVR asm</code> macros in my lib code.</p>
<p>But there is a simple solution. It turns out the <em>assignment is not necessary</em>. It is sufficient to do this:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="dt">static</span> <span class="dt">void</span> ClearPendingSpiInterrupt(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb33-2" title="2">{</a>
<a class="sourceLine" id="cb33-3" title="3">    *Spi_spsr; *Spi_spdr;</a>
<a class="sourceLine" id="cb33-4" title="4">}</a></code></pre></div>
<p>Unfortunately the [success of this simple approach is compiler-dependent] (https://embeddedgurus.com/stack-overflow/2010/03/reading-a-register-for-its-side-effects-in-c-and-c/ on the compiler).</p>
<ul>
<li>[ ] TODO: check the disassembly from <code>avr-gcc</code> to confirm the register access happens.</li>
</ul>
<p>If I am disappointed in the results of the <code>avr-gcc</code> output, I can use the <code>AvrAsmMacros</code> trick.</p>
<h2 id="clobbering-large-arrays-when-making-structs">clobbering large arrays when making structs?</h2>
<ul>
<li>the frame data is a big array:
<ul>
<li>approximately <code>770 pixels * 2 bytes per pixel = 1540</code></li>
</ul></li>
<li>and transmitting large arrays over USB works fine</li>
<li>but printing test results messes this up for reasons I do not understand ### observations</li>
<li>if I precede a large array print with a test result print, the array is consistently clobbered starting at byte 1042</li>
<li>if I follow a large array print with a test result print, the array is consistently clobbered starting at byte 1385</li>
<li>if I print an array of 1540 bytes without printing any test results, the array prints correctly ### conclusions</li>
<li>do not print test results</li>
<li>in general, behavior is very unpredictable with this large array dancing around</li>
<li>I think this is because the array is too large a percentage of the SRAM</li>
<li>unfortunately I cannot switch it to PROGMEM because I need to write to it!</li>
<li>I tried for 6 hours to understand the problem, time to move on
<ul>
<li>in that time I heavily characterized what would and wouldn’t cause problems</li>
<li>in each case it was not predictable until I actually did the test</li>
<li>the main takeaway is that I need to be careful about even doing simple function calls</li>
<li>it would be better to offload the data as it comes in</li>
<li>I tried just printing out direct every byte, but that doesn’t work, I don’t know why. The SPI communication fails.</li>
</ul></li>
<li>I can print test results, I just cannot pass the <code>TestResult</code> struct around
<ul>
<li>fault if I use its members as string variables in <code>snprintf</code></li>
</ul></li>
<li>I also must declare the <em>total</em> amount of memory snprintf will write to before calling snprintf</li>
<li>Here is the final working example:</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb34-1" title="1">    <span class="dt">char</span> test[<span class="dv">94</span>];  <span class="co">// assume 93 char is the biggest `TestResult` message</span></a>
<a class="sourceLine" id="cb34-2" title="2">    <span class="dt">char</span> pcb_name[] = <span class="st">&quot;simBrd&quot;</span>;</a>
<a class="sourceLine" id="cb34-3" title="3">    <span class="dt">char</span> pass_fail[] = <span class="st">&quot;PASS&quot;</span>;</a>
<a class="sourceLine" id="cb34-4" title="4">    snprintf(test, <span class="dv">94</span>,</a>
<a class="sourceLine" id="cb34-5" title="5">            <span class="co">/* &quot;\n%ssimBrd %stest &quot; */</span></a>
<a class="sourceLine" id="cb34-6" title="6">            <span class="st">&quot;</span><span class="sc">\n</span><span class="st">%s%s %stest &quot;</span></a>
<a class="sourceLine" id="cb34-7" title="7">            <span class="st">&quot;Get_a_frame_from_slave_and_write_frame_to_USB_host&quot;</span></a>
<a class="sourceLine" id="cb34-8" title="8">            <span class="co">/* &quot;:%sPASS%s\n&quot;, */</span></a>
<a class="sourceLine" id="cb34-9" title="9">            <span class="st">&quot;:%s%s%s</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb34-10" title="10">        text_color_white, pcb_name,</a>
<a class="sourceLine" id="cb34-11" title="11">        text_color_grey,  <span class="co">// test_name</span></a>
<a class="sourceLine" id="cb34-12" title="12">        text_color_white, pass_fail,</a>
<a class="sourceLine" id="cb34-13" title="13">        text_color_reset</a>
<a class="sourceLine" id="cb34-14" title="14">        );</a>
<a class="sourceLine" id="cb34-15" title="15">    <span class="dt">uint16_t</span> nb = strlen(test);</a>
<a class="sourceLine" id="cb34-16" title="16">    UsbWrite((<span class="dt">uint8_t</span> *)test, nb);</a></code></pre></div>
<ul>
<li>It really sucks that any of the steps to turn this into a function cause a fault</li>
<li>I don’t know why I can pass <code>pcb_name</code> and <code>pass_fail</code> as string variables, but I cannot do that for the <code>test_name</code> or the debug LED does not even turn on</li>
<li>so I am stuck just copy-and-pasting this code wherever I need it</li>
<li>even attempting to automate the color of pass/fail causes a little array clobbering, even if I am not passing the whole TestResult struct!</li>
</ul>
<h3 id="wait-but-why">wait but why</h3>
<ul>
<li>why is printing coupled to the memory for the array?
<ul>
<li>this is probably an <code>snprintf</code> issue</li>
<li>I am calculating the message length at runtime</li>
<li>that is OK, but not for determining the maximum amount of memory</li>
<li>but I need to give the compiler a safe maximum to reserve, and then the program decides how much to actually use</li>
</ul></li>
<li>solving those problems was not enough
<ul>
<li>sending two frames is no problem</li>
<li>and reading from the slave is no problem</li>
<li>the problem is 100% due to attempting to print a test result either before or after printing the array</li>
<li>so what is special about my test-result printing call?</li>
<li>it uses <code>snprintf</code> – possibly that is accessing memory it should not be</li>
<li>yep, <code>snprintf</code> causes the problem, but so does a straight call to <code>UsbWrite</code> with mixed up signedness of the pointers, as well as use of the <code>TestResult</code> struct in building a string to write with <code>snprintf</code></li>
</ul></li>
<li>the issue is the SRAM is only 2K
<ul>
<li>I am consuming 1.54K just to hold an array</li>
<li>it does not take much to overrun into this array by accident</li>
<li>I’m losing SRAM to stack frames from all the function calls</li>
<li>I’m losing SRAM to data like the <code>TestResults</code> struct which holds a long string</li>
<li>so it does not take much to step onto the array</li>
</ul></li>
<li>the solution is to <em>not store the array</em>
<ul>
<li>the tradeoff here is speed</li>
<li>sending each byte as I get it is definitely slower</li>
</ul></li>
<li>I can probably speed up if I send the data out in half-frames</li>
<li>alternatively, I can do an 8-bit version for now</li>
<li>but yes, success, now I can go back to my printing routines with no problem #### for future refactoring</li>
<li>use <code>vsnprintf</code> instead?</li>
<li>it’s a good solution once I have my array-clobbering problem sorted, but this will not help with that</li>
<li>plus I have to learn to write variadic functions… &gt; https://embeddedgurus.com/stack-overflow/2009/02/effective-c-tips-1-using-vsprintf/ &gt; https://www.avrfreaks.net/forum/passing-valist-snprintf</li>
<li>it is in <code>stdio.h</code> along with <code>snprintf</code>: &gt; <code>https://www.nongnu.org/avr-libc/user-manual/group__avr__stdio.html</code> &gt; <code>https://www.nongnu.org/avr-libc/user-manual/group__avr__stdio.html#gac92e8c42a044c8f50aad5c2c69e638e0</code></li>
</ul>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb35-1" title="1"><span class="dt">int</span> vsnprintf(</a>
<a class="sourceLine" id="cb35-2" title="2">        <span class="dt">char</span> * __s,</a>
<a class="sourceLine" id="cb35-3" title="3">        <span class="dt">size_t</span> __n,</a>
<a class="sourceLine" id="cb35-4" title="4">        <span class="dt">const</span> <span class="dt">char</span> *__fmt,</a>
<a class="sourceLine" id="cb35-5" title="5">        <span class="dt">va_list</span> ap</a>
<a class="sourceLine" id="cb35-6" title="6">        )</a></code></pre></div>
<blockquote>
<p>Like vsprintf(), but instead of assuming s to be of infinite size, no more than n characters (including the trailing NUL character) will be converted to s.</p>
<p>Returns the number of characters that would have been written to s if there were enough space.</p>
</blockquote>
<ul>
<li>The example from Nigel Jones:</li>
</ul>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1"><span class="co">// char array creation happens here</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="dt">void</span> display_Write(</a>
<a class="sourceLine" id="cb36-3" title="3">    <span class="dt">uint8_t</span> row,</a>
<a class="sourceLine" id="cb36-4" title="4">    <span class="dt">uint8_t</span> column,</a>
<a class="sourceLine" id="cb36-5" title="5">    <span class="dt">char</span> <span class="dt">const</span> * format,</a>
<a class="sourceLine" id="cb36-6" title="6">    ...</a>
<a class="sourceLine" id="cb36-7" title="7">    )</a>
<a class="sourceLine" id="cb36-8" title="8">{</a>
<a class="sourceLine" id="cb36-9" title="9">    <span class="dt">va_list</span> args;</a>
<a class="sourceLine" id="cb36-10" title="10">    <span class="dt">char</span> buf[MAX_STR_LEN];</a>
<a class="sourceLine" id="cb36-11" title="11"></a>
<a class="sourceLine" id="cb36-12" title="12">    va_start(args, format);</a>
<a class="sourceLine" id="cb36-13" title="13">    vsprintf(buf, format, args); <span class="co">/* buf contains the formatted string */</span></a>
<a class="sourceLine" id="cb36-14" title="14">    </a>
<a class="sourceLine" id="cb36-15" title="15">    <span class="co">/* Send formatted string to display - hardware dependent */</span></a>
<a class="sourceLine" id="cb36-16" title="16">    </a>
<a class="sourceLine" id="cb36-17" title="17">    va_end(args);                <span class="co">/* Clean up. Do NOT omit */</span></a>
<a class="sourceLine" id="cb36-18" title="18">}</a>
<a class="sourceLine" id="cb36-19" title="19"><span class="co">// example client code</span></a>
<a class="sourceLine" id="cb36-20" title="20"><span class="dt">void</span> display_Time(<span class="dt">int</span> hours, <span class="dt">int</span> minutes, <span class="dt">int</span> seconds)</a>
<a class="sourceLine" id="cb36-21" title="21">{</a>
<a class="sourceLine" id="cb36-22" title="22">    display_Write(<span class="dv">3</span>, <span class="dv">9</span>, <span class="st">&quot;%02d:%02d:%02d&quot;</span>, hours, minutes, seconds);</a>
<a class="sourceLine" id="cb36-23" title="23">}</a></code></pre></div>
<h2 id="pointer-signedness">pointer signedness</h2>
<pre class="make"><code>warning: pointer targets in initialization differ in signedness [-Wpointer-sign]</code></pre>
<ul>
<li>this happens because <code>UsbWrite</code> deals in raw bytes, so it takes pointers to unsigned bytes:</li>
</ul>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb38-1" title="1">UsbWrite((<span class="dt">uint8_t</span> *)test, nb);</a></code></pre></div>
<ul>
<li>but in the example above, <code>test</code> is a string, which is a pointer to a char</li>
<li>even though <code>char</code> and <code>uint8_t</code> are identical, <code>avr-gcc</code> complains this is a sign change from <code>unsigned</code> to not <code>unsigned</code></li>
<li>the attempted <code>cast</code> in the above snipped does not eliminate the warning because I have CFLAGS <code>-Wall</code> and <code>-Wextra -pedantic</code></li>
<li>solution: add CFLAG <code>-Wno-pointer-sign</code> to eliminate the warning</li>
</ul>
<pre class="make"><code>#=====[ Compiler and Linker flags ]=====
CFLAGS = -I../lib/src -Isrc \
    -g -Wall -Wextra -pedantic -Wno-pointer-sign\
    -O1 -ffunction-sections -fdata-sections -fshort-enums \
        -mmcu=atmega328p -B ${atmega328_lib}</code></pre>
<h1 id="ft1248-1">FT1248</h1>
<h2 id="how-ft1248-relates-to-usb">How FT1248 relates to USB</h2>
<p>There is one FT1248 master, usually a microcontroller (MCU), communicating with one or more FT1248 slaves. Each slave is a USB-bridge IC made by FTDI. Multiple slaves means the FT1248 master can communicate with multiple USB hosts. In my setup, there is only one USB host. The USB host is a Windows PC.</p>
<p>Even though the MCU is the FT1248 master, from the perspective of USB communication, the MCU is a <em>USB device</em>, while the USB host is, well, the USB host. A USB host initiates communication with its device. But at the lower level of USB implementation, the FT1248 master initiates communication with the USB-bridge! How does this play out? Who is actually initiating communication?</p>
<p>The USB host initiates the top-level conversation with the USB device. Always. The USB device is a combination of USB-bridge IC and MCU. And viewing the USB device as the combined effect of those two chips is the key to explaining the seeming contradiction:</p>
<h3 id="usb-1">USB</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">USB Host (the one that initiates)</th>
<th style="text-align: center;">USB Device (the one that responds)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Windows PC</td>
<td style="text-align: center;">USB-bridge + MCU</td>
</tr>
</tbody>
</table>
<h3 id="ft1248-2">FT1248</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">FT1248 Master (the one that initiates)</th>
<th style="text-align: center;">FT1248 Slave (the one that responds)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">MCU</td>
<td style="text-align: center;">USB-bridge</td>
</tr>
</tbody>
</table>
<h3 id="the-usb-bridge-abstracts-the-usb-hardware-interface">The USB-bridge abstracts the USB hardware interface</h3>
<p>Taking a page from the last <em>SOLID</em> principle, <em>Dependency Injection</em>, the USB-bridge is an interface that abstracts the details of USB communication. The interface lets the USB-host and the MCU both think they are the one to initiate communication, and even lets them use different communication protocols!</p>
<p>The MCU does not know it is talking to a USB host, i.e., I <em>do not know how USB works</em>, and yet I wrote a library called <code>UsbDriver</code>! The USB host <em>does know</em> it is talking to an FTDI device, because it uses the <code>d2xx.dll</code> library and its associated FTDI API. But <em>I can forget the details of FT1248 communication</em> when I write the USB Host application.</p>
<h3 id="usb-host-and-ft1248-master-both-initiate-communication-with-the-usb-bridge">USB host and FT1248 master both initiate communication with the USB-bridge</h3>
<p>The USB host writes to the USB device. The USB host trusts that the USB device will respond, but like with any device, it <em>has to wait</em> for that response. It cannot clock or drive the USB device. The USB-bridge IC tells the USB host when a response arrives.</p>
<p>After the host writes to the USB device, the data sent is sitting in the USB-bridge receive buffer. The USB-bridge signals to the MCU that there is data in the receive buffer. Because the MCU is the FT1248 master, <em>it is responsible for polling this receive buffer signal</em>. When it sees there is data in the receive buffer, it initiates communication with the USB-bridge to read that data.</p>
<p>If the USB host sent a command requesting data from the USB device, that means the USB host is now waiting on a response. Because my USB device (the USB-Bridge plus MCU) responds <em>quickly</em>, I write the USB host application to simply block until it receives the transmission. The USB Host application continues to <em>register</em> user events like a button press and provide some feedback to the user that the button was pressed. But the application does not act on those commands until it receives all of the expected data from the USB device.</p>
<h3 id="contract-between-the-usb-host-application-and-the-ft1248-master-firmware">Contract between the USB host application and the FT1248 master firmware</h3>
<p>As the FT1248 master, the MCU is in charge of delivering the data to the USB-bridge. The USB host expects this data to be delivered promptly and correctly. This is a <em>contract</em> between the USB host and the USB device. When the USB host requests data, the MCU must respond promptly and with the requested amount of data. This is the contract. The application on the USB host only runs smoothly if the MCU firmware upholds its side of the contract.</p>
<p>The USB host initiates all USB communication, but it has no way to enforce the contract. What if the USB device <em>does not</em> respond <strong>promptly</strong> and <strong>correctly</strong>?</p>
<p>If the USB device does not respond <strong>promptly</strong>, the host can set a timeout. I do this when I talk to the FTDI chip in our monochromator. The response time can vary quite a bit, so I need to allow for this while guarding against communication completely hanging.</p>
<p>There are several ways to ensure the USB device responds <strong>correctly</strong>:</p>
<ul>
<li>the USB host application requests a specific amount of data</li>
<li>the USB host application reads until there is no more data in the USB buffer</li>
<li>the data from the USB device always ends with a byte sequence that indicates the end of a transmission</li>
<li>the data from the USB device has a header that identifies it as the response to a specific request from the host</li>
</ul>
<p>These are not mutually exclusive. A good strategy would use some combination. I think up until now, I’ve mostly relied on the <em>expect a certain number of bytes</em> method, and that has actually never failed! I’ll continue doing that. I set up the communication to include a header, but I never actually implemented unique header IDs, I just ignore the initial sequence of bytes. I might have also added a sanity check that the USB host checks to see the the receive buffer is empty. The point is it should not be difficult to make a robust communication protocol given all of these options. It may even be possible to make a composable protocol. Decide on the allowed options beforehand. State at the beginning of each data frame which options are used. Program the USB host to compose a <code>DetectEndOfFrame</code> function on-the-fly based on the data at the start of the frame.</p>
<h2 id="ft1248-overview">FT1248 overview</h2>
<p>The FT1248 interface consists of:</p>
<ul>
<li><strong>clock</strong> and <strong>slave select</strong> signals driven by the FT1248 master</li>
<li>a <strong>data line</strong> driven by the FT1248 slave</li>
<li>1, 2, 4, or 8 <strong>bi-directional data lines</strong> driven by the master or the slave, depending on the command issued by the master at the start of communication
<ul>
<li>The <em>Earhart</em> used <strong>one</strong> <em>bi-directional data line</em>.</li>
<li>The <em>LIS USB interface board</em> uses <strong>eight</strong> <em>bi-directional data lines</em>.</li>
</ul></li>
</ul>
<p>The FT1248 interface has <em>two states</em>: <strong>inactive</strong> and <strong>active</strong>.</p>
<p>In the <strong>inactive state</strong>, there is <em>no clock</em>. All communication is via the signal on <em>two data lines driven by the slave</em>. One is the dedicated slave data line, <code>MISO</code> <em>master-in-slave-out</em>. The other is the <em>LSB</em> of the <em>bi-directional data port</em>, <code>MIOSIO[0]</code> <em>master-io-slave-io-bit-0</em>.</p>
<p><code>MISO</code> indicates <em>if there is data in the receive buffer</em>. The master polls <code>MISO</code>. If there is data in the receive buffer, the <em>master initiates a read</em>.</p>
<p><code>MIOSIO[0]</code> indicates <em>if there is room in the transmit buffer</em>. If the <em>master wishes to initiate a write</em>, it polls <code>MIOSIO[0]</code>. Once the transmit buffer has room, the master initiates a write.</p>
<p>The <strong>transmit</strong> and <strong>receive buffers</strong> are each <strong>1kByte</strong>. If there is <em>at least one byte of data</em> in the receive buffer, the slave <em>indicates there is data to read</em>. If there is <em>at least one empty byte</em> in the transmit buffer, the slave <em>indicates there is room to write</em>.</p>
<p>In the <strong>active state</strong> the master is clocking the slave to transfer data between master and slave. On a read, the slave writes data to the bus. On a write, the master writes data to the bus.</p>
<p>Aside: the FT1248 master has nothing to do with the data once it is written to the slave’s transmit buffer. At that point it is between the USB Host and the USB-bridge to negotiate reading the data out to the USB Host application.</p>
<hr />
<p>The <strong>active state</strong> is further divided into a <strong>command phase</strong> and a <strong>data phase</strong>.</p>
<p>In the <strong>command phase</strong>, the master sends a byte that tells the slave whether it is <em>reading</em> (from the receive buffer) or <em>writing</em> (to the transmit buffer), and how many pins (1, 2, 4, or 8) to use for the data transfer.</p>
<p>Following the <em>command phase</em> there are one or more <strong>data phases</strong> during which the actual data is transferred. Once data transfer starts, the interface remains in the <em>active</em> state, transferring data according to the command, until the master returns the interface to the <em>inactive</em> state.</p>
<h3 id="bus-turnaround">Bus-turnaround</h3>
<p>After the <em>command phase</em> and before the first <em>data phase</em>, there is a <strong>bus-turnaround</strong>. During bus-turnaround, if the command was a <em>write</em>, the slave uses <code>MISO</code> to <em>indicate whether the transmit buffer is full</em>. If the command was a <em>read</em>, the slave uses <code>MISO</code> to <em>indicate whether the receive buffer is empty</em>.</p>
<p>There is a subtle difference in how the <em>transmit buffer is full</em> signal is communicated during the <em>active</em> and <em>inactive</em> states. During the inactive state, the slave uses <code>MIOSIO[0]</code> to indicate when the <em>transmit buffer is full</em>, and <code>MISO</code> to indicate when there is <em>data in the receive buffer</em>. During the active state, the slave uses <code>MISO</code> for both <em>transmit buffer full</em> and <em>receive buffer empty</em>. This happens during the <em>bus-turnaround</em>. Which signal is communicated on <code>MISO</code> depends on whether the command was a <em>write</em> (goes with <em>transmit buffer full</em>) or a <em>read</em> (goes with <em>receive buffer empty</em>). And during the actual <em>data phase</em>, the slave is essentially doing the same thing on <code>MISO</code>, but the signals are called <code>ACK</code> and <code>NAK</code>. Again, the thing being <em>acknowledge</em> or <em>not acknowledge</em> depends on whether the command was a <em>read</em> or a <em>write</em>.</p>
<h3 id="ack-and-nak">ACK and NAK</h3>
<p>During the <em>data phase</em>, the slave uses <code>MISO</code> to indicate either an <strong><code>ACK</code></strong> or a <strong><code>NAK</code></strong>.</p>
<p>If the command is a <em>write</em>, the <code>ACK</code> means the transmit buffer has at least one more byte of space. On the rising clock edge, the master pushes its data, and the slave pushes its <code>ACK</code> or <code>NAK</code>. On the falling clock edge, the slave pulls in the data, and the master reads the <code>ACK</code> or <code>NAK</code> to determine whether that byte was successfully written.</p>
<p>If the command is a <em>read</em>, the <code>ACK</code> means the receive buffer has at least one more byte of data to read. On the rising clock edge, the slave pushes the byte of data along with the <code>ACK</code> signal indicating that this is valid data. If the slave sends the <code>NAK</code> signal, it means this byte is whatever garbage you get from reading an empty buffer.</p>
<p>Anytime the FT1248 master receives a <code>NAK</code> it returns the interface to the inactive state.</p>
<h2 id="ft1248-protocol-and-ft1248-c-library">FT1248 protocol and Ft1248 C library</h2>
<ul>
<li><code>FT1248</code> is the FTDI protocol.</li>
<li><code>Ft1248</code> is my C library that implements the <code>FT1248</code> protocol.</li>
<li>I implemented <code>FT1248</code> entirely in software:
<ul>
<li>the Earhart implementation used the SPI hardware module on the ATtiny84 because it is 1-bit wide</li>
<li>the LIS-770i interface implementation is done in software because it is 8-bitwide</li>
</ul></li>
</ul>
<p>The following summarizes 8-bit wide <code>FT1248</code> using the lib <code>Ft1248</code> function names.</p>
<h3 id="polling-in-the-inactive-state">Polling in the inactive state</h3>
<p>In the inactive state, the master is always checking <code>MISO</code> to see if there is data to read:</p>
<pre><code>FtHasDataToRead</code></pre>
<p>These are the other names I considered: <code>!FtIsRxBufferEmpty</code>, <code>!FtIsRxEmpty</code>, <code>FtIsDataAvailable</code>, <code>FtIsReadyToRead</code>.</p>
<p>After reading data from the USB host, the master is back in the inactive state. If the data from the USB host was a request for the master to transmit data, the master first checks <code>MIOSIO[0]</code> to see if the transmit buffer has room for new data:</p>
<pre><code>FtHasRoomToWrite</code></pre>
<p>These are the other names I considered: <code>!FtIsTxBufferFull</code>, <code>FtTxBufferHasRoom</code>, <code>!FtIsTxFull</code>, <code>FtIsReadyToSend</code></p>
<h3 id="activate-the-interface">Activate the interface</h3>
<p>Whether the master wishes to do a write or a read, the master first activates the interface by pulling <code>!SS!</code> low:</p>
<pre><code>FtActivateInterface</code></pre>
<p>The master clocks the interface to push data onto the bus by pulling <code>SCK</code> high:</p>
<pre><code>FtPushData</code></pre>
<p>The master has to wait to output on the <code>MIOSIO</code> port until after pulling <code>SCK</code> high. The slave releases <code>MIOSIO[0]</code> on the rising edge of <code>SCK</code>. The master can take as long as it needs to push the data and then pull <code>SCK</code> low. The slave will not read the data until the falling edge of <code>SCK</code>.</p>
<hr />
<h3 id="read-command">Read Command</h3>
<p>After activating the interface and raising <code>SCK</code> to signal pushing data, the master outputs the <em>read</em> command on the <code>MIOSIO</code> port:</p>
<pre><code>FtLetMasterDriveBus
FtReadCommand</code></pre>
<p>The master clocks the slave with a falling edge, telling it to pull the command from the <code>MIOSIO</code> port:</p>
<pre><code>FtPullData</code></pre>
<h3 id="bus-turnaround-after-the-read-command">Bus-turnaround after the read command</h3>
<p>The master releases the <code>MIOSIO</code> port:</p>
<pre><code>FtLetSlaveDriveBus</code></pre>
<p>The master clocks the slave with a rising edge, telling it to drive <code>MISO</code> with the <code>RxBufferEmpty</code> signal:</p>
<pre><code>FtPushData</code></pre>
<p>The master clocks the slave with a falling edge, indicating that it is going to pull data from <code>MISO</code>:</p>
<pre><code>FtPullData</code></pre>
<p>The master checks <code>MISO</code> to see if it is OK to continue with the data transfer:</p>
<pre><code>FtIsBusOk</code></pre>
<p>Note this is actually the same as <code>FtHasDataToRead</code>, but I am using a new name because the master is going to call this same function whether the command is a <em>read</em> or a <em>write</em>. During the <code>bus-turnaround</code>, the slave uses <code>MISO</code> for both <em>receive buffer empty</em> and <em>transmit buffer full</em>.</p>
<ul>
<li><p>If it is <em>not</em> OK to continue with the data transfer, <code>FtIsBusOk</code> returns <em>false</em>. The low-level command immediately before this was <code>FtPullData</code> which pulls <code>SCK</code> low. This is good. <code>SCK</code> should be low before deactivating the interface. The master terminates the Ft1248 sesssion by deactivating the interface: <code>FtDeactivateInterface</code> pulls <code>!SS!</code> high again to return to the <em>inactive state</em>.</p></li>
<li><p>If it <em>is</em> OK to continue with the data transfer, the master clocks out the data from the slave.</p></li>
</ul>
<p>First a rising clock edge to tell the slave to push data onto the bus and to drive <code>MISO</code> with an <code>ACK</code> or <code>NAK</code>:</p>
<pre><code>FtPushData</code></pre>
<p>Then a falling clock edge to tell the slave that it is pulling the slave’s data from the bus:</p>
<pre><code>FtPullData</code></pre>
<p>The master checks <code>MISO</code> for an <code>ACK</code> to see if this is a valid byte of data:</p>
<pre><code>FtIsBusOk</code></pre>
<p>Then reads the data from the MIOSIO port:</p>
<pre><code>FtReadData</code></pre>
<p>The master continues the <strong>push-pull-isOk-readData</strong> loop as long as it wishes or until it receives a <code>NAK</code>.</p>
<p>When the master is done, it does a final pull:</p>
<pre><code>FtPullData
FtIsBusOk
FtReadData</code></pre>
<p>And it leaves <code>SCK</code> low.</p>
<p>Lastly, the master pulls <code>!SS!</code> high again to return to the <em>inactive state</em>:</p>
<pre><code>FtDeactivateInterface</code></pre>
<h3 id="write-command">Write Command</h3>
<p>After activating the interface and raising <code>SCK</code> to signal pushing data, the master outputs the <em>write</em> command on the <code>MIOSIO</code> port:</p>
<pre><code>FtLetMasterDriveBus
FtWriteCommand</code></pre>
<p>The master clocks the slave with a falling edge, telling it to pull the command from the <code>MIOSIO</code> port:</p>
<pre><code>FtPullData</code></pre>
<h3 id="bus-turnaround-after-the-write-command">Bus-turnaround after the write command</h3>
<p>The master releases the <code>MIOSIO</code> port:</p>
<pre><code>FtLetSlaveDriveBus</code></pre>
<p>The master clocks the slave with a rising edge, telling it to drive <code>MISO</code> with the <code>TxBufferFull</code> signal:</p>
<pre><code>FtPushData</code></pre>
<p>The master clocks the slave with a falling edge, indicating that it is going to pull data from <code>MISO</code>:</p>
<pre><code>FtPullData</code></pre>
<p>The master checks <code>MISO</code> to see if it is OK to continue with the data transfer:</p>
<pre><code>FtIsBusOk</code></pre>
<p>Note this is <em>not</em> the same as <code>FtHasRoomToWrite</code>. That function checks <code>MIOSIO[0]</code>, this one checks <code>MISO</code>. During the <code>bus-turnaround</code>, the slave uses <code>MISO</code> for both <em>receive buffer empty</em> and <em>transmit buffer full</em>.</p>
<p>The master clocks the data into the slave’s transmit buffer. First a rising clock edge to tell the slave to drive <code>MISO</code> with an <code>ACK</code> or <code>NAK</code>:</p>
<pre><code>FtPushData</code></pre>
<p>The master pushes its data onto <code>MIOSIO</code>:</p>
<pre><code>FtWriteData</code></pre>
<p>Then a falling clock edge to tell the slave to pull the data from the bus:</p>
<pre><code>FtPullData</code></pre>
<p>The master checks <code>MISO</code> for an <code>ACK</code> to see if the data successfully entered the transmit buffer:</p>
<pre><code>FtIsBusOk</code></pre>
<p>The master continues the <strong>push-pull-isOk-readData</strong> loop as long as it wishes or until it receives a <code>NAK</code>.</p>
<p>When the master is done, it does a final pull to tell the slave to read the last byte into the transmit buffer:</p>
<pre><code>FtPullData</code></pre>
<p>It checks that the buffer had room to write that last byte:</p>
<pre><code>FtIsBusOk</code></pre>
<p>And it leaves <code>SCK</code> low.</p>
<p>The master then releases the <code>MIOSIO</code> port:</p>
<pre><code>FtLetSlaveDriveBus</code></pre>
<p>Lastly, the master pulls <code>!SS!</code> high again to return to the <em>inactive state</em>:</p>
<pre><code>FtDeactivateInterface</code></pre>
<h2 id="ft1248-setup">FT1248 setup</h2>
<ul>
<li><code>SCK</code> : clock signal driven by the master</li>
<li><code>!SS!</code> : slave select signal driven by the master</li>
<li><code>MISO</code> : master-in-slave-out, <em>always</em> driven by the slave</li>
<li><code>MIOSIO</code> : eight bi-directional lines</li>
</ul>
<p>The eight bi-directional lines are driven by the master during a write, and driven by the slave during a read.</p>
<p>The first bi-directional line, <code>MIOSIO[0]</code>, has an additional function. The slave only drives this line during the inactive state. If LOW, the transmit buffer is full. During the active state, the slave indicates a full transmit buffer using <code>MISO</code>.</p>
<p>=====[ Summary of MCU pin configuration to be an FT1248 master ]=====</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb70-1" title="1"><span class="co">// MISO   is an       input pin</span></a>
<a class="sourceLine" id="cb70-2" title="2"><span class="co">// MIOSIO is an 8-bit input port</span></a>
<a class="sourceLine" id="cb70-3" title="3"><span class="co">// SCK  is an output signal that idles LOW.</span></a>
<a class="sourceLine" id="cb70-4" title="4"><span class="co">// !SS! is an output signal that idles HIGH.</span></a>
<a class="sourceLine" id="cb70-5" title="5"></a>
<a class="sourceLine" id="cb70-6" title="6"><span class="co">// MISO is always an input.</span></a>
<a class="sourceLine" id="cb70-7" title="7">clr_bit(FT1248_DDR,FT1248_MISO);    <span class="co">// cfg miso as an input pin</span></a>
<a class="sourceLine" id="cb70-8" title="8">set_bit(FT1248_PORT,FT1248_MISO);   <span class="co">// enable pull-up on miso</span></a>
<a class="sourceLine" id="cb70-9" title="9"></a>
<a class="sourceLine" id="cb70-10" title="10"><span class="co">// MIOSIO is always an input port while in the inactive state.</span></a>
<a class="sourceLine" id="cb70-11" title="11"><span class="co">// MIOSIO is an input in the active state, except during the command phase</span></a>
<a class="sourceLine" id="cb70-12" title="12"><span class="co">// and during the data phase for a write.</span></a>
<a class="sourceLine" id="cb70-13" title="13">MIOSIO_DDR = <span class="bn">0x00</span>;                  <span class="co">// cfg miosio0:7 as an input port</span></a>
<a class="sourceLine" id="cb70-14" title="14">MIOSIO_PORT = <span class="bn">0XFF</span>;                 <span class="co">// enable pull-ups on miosio</span></a>
<a class="sourceLine" id="cb70-15" title="15"></a>
<a class="sourceLine" id="cb70-16" title="16"><span class="co">// SCK remains low while in the inactive state.</span></a>
<a class="sourceLine" id="cb70-17" title="17"><span class="co">// The first clock edge in the active state is a rising edge.</span></a>
<a class="sourceLine" id="cb70-18" title="18">clr_bit(FT1248_PORT,FT1248_SCK);    <span class="co">// Drive SCK low.</span></a>
<a class="sourceLine" id="cb70-19" title="19">set_bit(FT1248_DDR,FT1248_SCK);     <span class="co">// Make SCK an output.</span></a>
<a class="sourceLine" id="cb70-20" title="20"></a>
<a class="sourceLine" id="cb70-21" title="21"><span class="co">// !SS! controls whether the interface is in the active or inactive stage.</span></a>
<a class="sourceLine" id="cb70-22" title="22"><span class="co">// !SS! remains high while in the inactive state.</span></a>
<a class="sourceLine" id="cb70-23" title="23"><span class="co">// !SS! goes low to initiate the active state.</span></a>
<a class="sourceLine" id="cb70-24" title="24">set_bit(FT1248_PORT,FT1248_SS);     <span class="co">// Drive !SS! high.</span></a>
<a class="sourceLine" id="cb70-25" title="25">set_bit(FT1248_DDR,FT1248_SS);      <span class="co">// Make !SS! an output.</span></a></code></pre></div>
<h2 id="ft1248-starts-communication-with-a-combined-command-and-bus-width-byte">FT1248 starts communication with a combined command and bus-width byte</h2>
<p>FT1248 communication is initiated by the FT1248 master (the MCU). The FT1248 slave (the FTDI chip) signals when there is data in the receive buffer from the USB host, but it is up to the master to decide when to read the data.</p>
<p>The master initiates communication by sending a single byte that is a complicated combination of two nibbles:</p>
<ul>
<li>one nibble represents a command: 0 for write, 1 for read</li>
<li>the other nibble represents the bus-width.</li>
</ul>
<p>This is described on <em>p.6 of FTDI application note #167</em>.</p>
<p>See [FT1248 format of combined command and bus-width byte][ft1248-cmd-bw-byte]. [ft1248-cmd-bw-byte]: #markdown-header-ft1248-format-of-combined-command-and-bus-width-byte</p>
<h2 id="how-the-mcu-manages-usb-communication-using-ft1248">How the MCU manages USB communication using FT1248</h2>
<h3 id="check-if-there-is-any-unread-data-from-the-usb-host">Check if there is any unread data from the USB host</h3>
<div class="sourceCode" id="cb71"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb71-1" title="1">!chk_bit(FT1248_PIN,FT1248_MISO);   <span class="co">// true:    there is unread data from the</span></a>
<a class="sourceLine" id="cb71-2" title="2">                                    <span class="co">//          USB host in the receive buffer</span></a></code></pre></div>
<h3 id="read-the-data-from-the-usb-host">Read the data from the USB host</h3>
<p>Activate the interface by pulling <code>!SS!</code> low:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb72-1" title="1">clr_bit(FT1248_PORT,FT1248_SS);     <span class="co">// Pull !SS! low to signal the FT1248 slave</span></a>
<a class="sourceLine" id="cb72-2" title="2">                                    <span class="co">// (the FTDI chip) to release MIOSIO[0].</span></a></code></pre></div>
<p>Ft1248 function:</p>
<pre><code>FtActivateInterface_SsLow</code></pre>
<p>Clock the interface to push data onto the bus by pulling <code>SCK</code> high:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb74-1" title="1">set_bit(FT1248_PORT,FT1248_SCK);    <span class="co">// Pull SCK high to signal the FT1248</span></a>
<a class="sourceLine" id="cb74-2" title="2">                                    <span class="co">// master (the MCU) and slave (the FTDI</span></a>
<a class="sourceLine" id="cb74-3" title="3">                                    <span class="co">// chip) to shift their data onto the bus.</span></a></code></pre></div>
<p>Ft1248 function:</p>
<pre><code>FtPushData_SckHigh</code></pre>
<p>Output the command to read by outputting byte <code>0xC6</code> on the <code>MIOSIO</code> port:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb76-1" title="1">MIOSIO_DDR = <span class="bn">0xFF</span>;                  <span class="co">// First the master drives the data lines.</span></a>
<a class="sourceLine" id="cb76-2" title="2">MIOSIO_PORT = FT1248_CMD_READ8;     <span class="co">// The master outputs the read command</span></a>
<a class="sourceLine" id="cb76-3" title="3">                                    <span class="co">// and specifies an 8-bit-wide bus.</span></a></code></pre></div>
<p>Ft1248 function:</p>
<pre><code>FtOutputTheReadCommand</code></pre>
<hr />
<h2 id="ft1248-reference">FT1248 reference</h2>
<h3 id="hardware-specific-ft1248-settings-in-ftprog">Hardware Specific Ft1248 Settings in ftprog</h3>
<ul>
<li>Run <code>FT_Prog</code></li>
<li>Scan for devices</li>
<li>locate the <code>UMFT221XA</code></li>
<li>Name it <code>Chromation Mod UsbSpi Bridge</code></li>
<li>Select <code>Hardware Specific -&gt; Ft1248 Settings</code></li>
<li><em>8-bit wide config used on the LIS-770i interface:</em>
<ul>
<li>Clock Polarity High: unchecked</li>
<li>Bit Order LSB: <em>checked</em></li>
<li>Flow Ctrl not selected: <em>checked</em></li>
</ul></li>
<li>Note this is different from the previous Chromation embedded system using FTDI USB bridge ICs:
<ul>
<li>Earhart 1-bit wide config:
<ul>
<li>Clock Polarity High: <em>checked</em></li>
<li>Bit Order LSB: unchecked</li>
<li>Flow Ctrl not selected: <em>checked</em></li>
</ul></li>
</ul></li>
</ul>
<h4 id="flow-ctrl">Flow Ctrl</h4>
<ul>
<li>if <code>Flow Ctrl not selected</code> is unchecked, then the Ft1248 slave does not use MISO and MIOSIO[0] to send Rx and Tx buffer status signals</li>
<li>read this as <code>Use flow control when the slave is inactive</code></li>
</ul>
<h4 id="bit-order">Bit Order</h4>
<ul>
<li>I discovered this by trial and error</li>
<li>the bit order is LSB</li>
<li>send the byte <code>0x01</code>
<ul>
<li>if <code>Bit Order LSB</code> is checked</li>
<li>then the USB host reads this as <code>0x01</code></li>
<li>if <code>Bit Order LSB</code> is unchecked</li>
<li>then the USB host read this as <code>0x80</code></li>
<li>this is exactly what you expect when flipping the bit order</li>
</ul></li>
</ul>
<h4 id="clock-polarity">Clock Polarity</h4>
<ul>
<li>when unchecked, clock polarity works as described all throughout the FTDI application note and all throughout this README</li>
<li>unchecked means the CPOL is 0 which means SCK idles low</li>
<li><p>since the clock phase CPHA is always 1, this means SCK goes high to signal pushing data onto the bus and SCK goes low to signal pulling data from the bus</p></li>
<li>I was pretty sure Clock Polarity High should be unchecked
<ul>
<li>I confirmed this by trying it both ways</li>
<li>behavior is very strange when clock polarity is checked</li>
</ul></li>
<li><p>See FTDI Application Note <code>AN_167</code> &gt; When <code>CPOL</code> is 1, the idle state of the clock is high. &gt; When <code>CPOL</code> is 0, the idle state of the clock is low. &gt; There are 4 possible modes which are determined by Clock Polarity (<code>CPOL</code>) and &gt; Clock Phase (<code>CPHA</code>) signals. For the FT1248 slave, only 2 of these 4 modes are &gt; supported. <code>CPHA</code> will always be set to 1 in the FT1248 slave because data is &gt; available or driven on to MIOSIO wires on the first clock edge after <code>SS_n</code> is &gt; active and is therefore sampled on the trailing edge of the first clock pulse.</p></li>
</ul>
<h3 id="ft1248-format-of-combined-command-and-bus-width-byte">FT1248 format of combined command and bus-width byte</h3>
<p>The <em>bus-width</em> (<em>BW</em>) and command are sent in a byte on a subset of the <code>MIOSIO[7:0]</code> pins over one or more clock cycles.</p>
<p>For example, if <em>BW</em> is 1-bit:</p>
<ul>
<li>bit[7..0] is clocked out on MIOSIO[0]</li>
<li>takes eight clock cycles</li>
</ul>
<p>And the opposite example, if <em>BW</em> is 8-bit:</p>
<ul>
<li><code>bit[7..0]</code> is clocked out on <code>MIOSIO[7:0]</code></li>
<li>takes one clock cycle</li>
</ul>
<p>On the <strong>first falling edge</strong> of <code>SCK</code>, the FTDI chip gets the <strong>bus-width ID</strong> and therefore knows whether it’s clocking out more bits, or reading the entire <code>CMD[3..0]</code> on the <code>MIOSIO</code> pins.</p>
<p>Note that in the Earhart design, <code>CPOL = 1</code> (<code>SCK</code> idles <code>HIGH</code>), so it would be the first rising edge of <code>SCK</code> when the FTDI chip reads the bus-width.</p>
<p>In the design for the LIS-770i interface, <code>CPOL = 0</code> (<code>SCK</code> idles <code>LOW</code>).</p>
<ul>
<li>command/bus-width byte format:
<ul>
<li>bit[7] = X</li>
<li>bit[6] = CMD[0]</li>
<li>bit[5] = CMD[1]</li>
<li>bit[4] = 0 if BW=8, X otherwise</li>
<li>bit[3] = CMD[2]</li>
<li>bit[2] = 0 if BW=4, X otherwise</li>
<li>bit[1] = 0 if BW=2, X otherwise</li>
<li>bit[0] = CMD[3]</li>
<li>if bits[4,2,1] are all X, the BW=1</li>
</ul></li>
<li>if BW=8, all eight pins are used:
<ul>
<li>MIOSIO[7] = X</li>
<li>MIOSIO[6] = CMD[0]</li>
<li>MIOSIO[5] = CMD[1]</li>
<li>MIOSIO[4] = 0 (BW=8)</li>
<li>MIOSIO[3] = CMD[2]</li>
<li>MIOSIO[2] = X</li>
<li>MIOSIO[1] = X</li>
<li>MIOSIO[0] = CMD[3]</li>
</ul></li>
<li>if BW=4, only MIOSIO[3:0] are used:
<ul>
<li>MIOSIO[7] = X</li>
<li>MIOSIO[6] = X</li>
<li>MIOSIO[5] = X</li>
<li>MIOSIO[4] = X</li>
<li>on 1st clock:
<ul>
<li>MIOSIO[3] = CMD[2]</li>
<li>MIOSIO[2] = 0 if BW=4</li>
<li>MIOSIO[1] = X</li>
<li>MIOSIO[0] = CMD[3]</li>
</ul></li>
<li>on 2nd clock:
<ul>
<li>MIOSIO[3] = X</li>
<li>MIOSIO[2] = CMD[0]</li>
<li>MIOSIO[1] = CMD[1]</li>
<li>MIOSIO[0] = X</li>
</ul></li>
</ul></li>
</ul>
<p>list of commands:</p>
<pre><code>write                 0x0
read                  0x1
write buffer flush    0x4</code></pre>
<h3 id="ft1248-combined-command-and-bus-width-byte-for-an-8-bit-bus">FT1248 combined command and bus-width byte for an 8-bit bus</h3>
<p>Here are the bytes to output on the MIOSIO port to specify 8-bit-wide read and write:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb79-1" title="1">                                    <span class="co">// BW:8 (0)────────┐</span></a>
<a class="sourceLine" id="cb79-2" title="2">                                    <span class="co">//                 │</span></a>
<a class="sourceLine" id="cb79-3" title="3">                                    <span class="co">// CMD-nibble:  -01▾ 2--3</span></a>
<a class="sourceLine" id="cb79-4" title="4"><span class="pp">#define FT1248_CMD_WRITE8   0x86    </span><span class="co">//              1000 0110</span></a>
<a class="sourceLine" id="cb79-5" title="5"><span class="pp">#define FT1248_CMD_READ8    0xC6    </span><span class="co">//              1100 0110</span></a>
<a class="sourceLine" id="cb79-6" title="6">                                    <span class="co">// Bit numbers: 7654 3210</span></a></code></pre></div>
<p>There are four bits for the <em>command</em> nibble and four for the <em>bus-width</em> nibble. A <strong>low</strong> on a particular bus-width bit indicates the bus width. The other bits in the bus-width nibble should not matter, but to play it safe, the other bits in the bus-width nibble are pulled high.</p>
<h1 id="spi">SPI</h1>
<h2 id="spi-dev-tasklist">SPI dev tasklist</h2>
<h3 id="this-is-the-dev-cycle">This is the dev cycle</h3>
<h4 id="start-with-embedded-tests-to-discover-working-code">start with embedded tests to discover working code</h4>
<ul>
<li>Example: this is how I started working on the SPI libraries
<ul>
<li>[x] configure user-defined pins in software</li>
<li>[x] setup SPI registers to use SPI pins for SPI on Master and Slave</li>
<li>[x] set SPI Master to run the SPI clock at <code>fosc/8 = 1.25MHz</code></li>
<li>[x] setup slave to change debug LED when it receives a byte over SPI</li>
<li>[x] setup master to send a byte over SPI when it starts up #### switch to unit tests to refactor working code</li>
</ul></li>
<li>look at the functions in the embedded tests:
<ul>
<li>one-liner comments describing what the next line does become the function names</li>
<li>each claim in the function documentation becomes a unit test ### Track progress in the current dev cycle #### ! embedded tests to discover new code</li>
</ul></li>
<li>[x] SpiMaster</li>
<li>[x] SpiSlave
<ul>
<li>[x] killed a few bugs:
<ul>
<li>[x] I was reading <code>PORT</code> instead of <code>PIN</code></li>
<li>[x] I was reading a function name instead of the function value
<ul>
<li>i.e., I forgot the trailing <code>()</code></li>
</ul></li>
<li>[x] I was trying to use <code>MISO</code> as general purpose I/O while the <code>SPI</code> hardware module was overriding the <code>PORT</code> value</li>
</ul></li>
<li>[x] this test: sending bytes</li>
<li>next test: write Application versions of <code>Slave_receives_request</code></li>
<li>make a version without interrupts and a version with interrupts #### unit-tested working code into lib code and refactored</li>
</ul></li>
<li>[x] SpiMaster</li>
<li>[x] SpiSlave #### refactor embedded tests using new lib code</li>
<li>[x] SpiMaster</li>
<li>[x] SpiSlave #### embedded tests of refactored lib code</li>
<li>[x] embedded test of SpiMaster</li>
<li>[x] embedded test of SpiSlave</li>
</ul>
<h2 id="spi-dev-overview">SPI dev overview</h2>
<h3 id="spi-and-spi">SPI and Spi</h3>
<ul>
<li><em>SPI</em> is <em>Serial Peripheral Interface</em></li>
<li>I use <em>Spi</em> when referring to my lib</li>
<li>the libs are <code>SpiMaster</code> and <code>SpiSlave</code></li>
<li>there is another <em>SPI</em> lib: <code>UartSpi</code> for communication with the <em>ADC</em> on the <code>mBrd</code>, see section <a href="#markdown-header-uart-spi">UART SPI</a></li>
</ul>
<h3 id="master-and-slave">Master and Slave</h3>
<ul>
<li><em>SPI master</em>: the MCU on the <code>simBrd</code>, a.k.a the <em>Ft1248 Master</em> MCU</li>
<li><em>SPI slave</em>: the MCU on the <code>mBrd</code></li>
</ul>
<h3 id="spi-overview">SPI overview</h3>
<ul>
<li>see datasheet</li>
</ul>
<div class="sourceCode" id="cb80"><pre class="sourceCode powershell"><code class="sourceCode powershell"><a class="sourceLine" id="cb80-1" title="1"><span class="fu">PS</span>&gt; &amp;<span class="va">$atmega328p_datasheet</span></a></code></pre></div>
<ul>
<li><em>SPI</em> is well-described in the <em>ATmega328P</em> datasheet, chapter 18 <code>SPI - Serial Peripheral Interface</code></li>
<li>see <strong>Figure 18-2.</strong> <em>SPI Master-slave Interconnection</em></li>
<li>this figure summarizes how <em>SPI</em> works:
<ul>
<li>the master has an <strong>8-bit data</strong> register</li>
<li>the slave has an <strong>8-bit data</strong> register</li>
<li>by connecting <code>MOSI</code> to <code>MOSI</code> and <code>MISO</code> to <code>MISO</code>, these two 8-bit registers form a <strong>16-bit circular buffer</strong></li>
<li>it is a <em>circular buffer</em> because each time the bits are shifted left, the old <code>MSB</code> is shifted back in as the new <code>LSB</code></li>
<li>on each clock pulse:
<ul>
<li>the <strong>master <code>MSB</code></strong> is shifted into the <strong>slave <code>LSB</code></strong></li>
<li>the <strong>slave <code>MSB</code></strong> is shifted into the <strong>master <code>LSB</code></strong></li>
</ul></li>
<li>the circular buffer is clocked 8 times to shift all 8 bits</li>
<li>the transmission is finished</li>
<li>whatever was in the <em>master</em> is now in the <em>slave</em>, and vice versa</li>
</ul></li>
<li><strong>takeaway</strong>: both the master and slave send and receive on every transmission, regardless of which one is sending the <em>actual</em> data</li>
</ul>
<h3 id="spi-communication-for-requesting-a-frame">SPI communication for requesting a frame</h3>
<h4 id="spi-master-requests-a-frame">SPI master requests a frame</h4>
<ul>
<li>SPI master transmits <code>request_frame</code>:
<ul>
<li><code>Spi_Ss</code> goes high to low
<ul>
<li>this places the <code>mBrd</code> MCU in <em>slave</em> mode</li>
</ul></li>
<li>SPI master loads SPI data register with byte to <code>request_frame</code>
<ul>
<li>this initiates the transmission</li>
</ul></li>
<li>the byte in the SPI data register is shifted out</li>
<li><code>Spi_Ss</code> goes low to high
<ul>
<li>this releases the <code>mBrd</code> MCU from <em>slave</em> mode</li>
</ul></li>
</ul></li>
<li>SPI slave parses the byte and recognizes it as <code>request_frame</code></li>
<li>SPI slave coordinates with the ADC and LIS to get a frame of data</li>
</ul>
<h4 id="spi-slave-responds-with-the-frame">SPI slave responds with the frame</h4>
<ul>
<li>SPI slave collects the entire frame of data</li>
<li>SPI slave loads the first byte of data into the SPI data register</li>
<li>SPI slave pulls <code>Spi_Miso</code> low to signal that a frame is ready</li>
<li>SPI master reads out the frame:
<ul>
<li><code>Spi_Ss</code> goes high to low
<ul>
<li>this places the <code>mBrd</code> MCU in <em>slave</em> mode</li>
</ul></li>
<li>SPI master does the read out:
<ul>
<li>SPI master initiates the transmission of each byte by writing to the SPI data register</li>
<li>it does not matter what the master writes to the SPI data register:
<ul>
<li>I can use this byte like an ACK/NAK:
<ul>
<li>e.g., master sends a byte meaning <em>stop sending</em></li>
</ul></li>
<li>but <code>Spi_Ss</code> already handles synchronization, so to stop a transmission all I have to do is pull <code>Spi_Ss</code> high</li>
<li>I cannot think of anything useful for the master to send</li>
</ul></li>
</ul></li>
<li><code>Spi_Ss</code> goes low to high
<ul>
<li>this releases the <code>mBrd</code> MCU from <em>slave</em> mode</li>
<li>SPI slave considers the frame finished</li>
</ul></li>
</ul></li>
<li>I am having timing problems.</li>
<li>I can try an extra handshake:
<ul>
<li>slaves wait to be released</li>
<li>master releases slave</li>
<li>this is slaves queue to signal when data is ready</li>
<li>master waits for this signal</li>
<li>master reopens communication with slave ## Setup the SPI hardware ### Setup the SPI pins</li>
</ul></li>
<li>see <code>hardware-connection-and-schematics.pdf</code></li>
</ul>
<div class="sourceCode" id="cb81"><pre class="sourceCode powershell"><code class="sourceCode powershell"><a class="sourceLine" id="cb81-1" title="1"><span class="fu">PS</span>&gt; &amp;<span class="va">$lis_hardware</span></a></code></pre></div>
<ul>
<li>[x] create <code>SpiMaster-Hardware.h</code></li>
<li>[x] create <code>SpiSlave-Hardware.h</code>
<ul>
<li>pinout is identical to <code>SpiMaster-Hardware.h</code></li>
</ul></li>
</ul>
<h3 id="setup-the-spi-registers">Setup the SPI registers</h3>
<ul>
<li>see datasheet</li>
</ul>
<div class="sourceCode" id="cb82"><pre class="sourceCode powershell"><code class="sourceCode powershell"><a class="sourceLine" id="cb82-1" title="1"><span class="fu">PS</span>&gt; &amp;<span class="va">$atmega328p_datasheet</span></a></code></pre></div>
<h4 id="spi-master-pin-overrides">SPI master pin overrides</h4>
<table>
<thead>
<tr class="header">
<th>pin</th>
<th>direction</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Spi_Ss</code></td>
<td>user defined</td>
</tr>
<tr class="even">
<td><code>Spi_Miso</code></td>
<td>input</td>
</tr>
<tr class="odd">
<td><code>Spi_Mosi</code></td>
<td>user defined</td>
</tr>
<tr class="even">
<td><code>Spi_Sck</code></td>
<td>user defined</td>
</tr>
</tbody>
</table>
<h4 id="spi-slave-pin-overrides">SPI slave pin overrides</h4>
<table>
<thead>
<tr class="header">
<th>pin</th>
<th>direction</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Spi_Ss</code></td>
<td>input</td>
</tr>
<tr class="even">
<td><code>Spi_Miso</code></td>
<td>user defined</td>
</tr>
<tr class="odd">
<td><code>Spi_Mosi</code></td>
<td>input</td>
</tr>
<tr class="even">
<td><code>Spi_Sck</code></td>
<td>input</td>
</tr>
</tbody>
</table>
<h3 id="spi-errata">SPI Errata</h3>
<p>I discovered a weird-but-obvious-in-hindsight behavior that is not documented anywhere. Below I ramble on about this for a while, but there is a more significant takeaway in: - writing the logic for the SPI master to detect when the SPI slave sends the <em>data is ready</em> signal - characterizing the setup and hold times for when the SPI slave sends the <em>data is ready</em> signal and providing this information in the datasheet</p>
<h4 id="loss-of-miso-as-general-purpose-io-when-spi-is-enabled">Loss of MISO as general purpose IO when SPI is enabled</h4>
<h5 id="context-1">Context</h5>
<p>The Chromation spectrometer is a SPI slave. Customer hardware is the SPI master. When a master requests data, it takes time for the sensor to collect the data. Since <code>MISO</code> is always an input on the SPI master, I decided to use <code>MISO</code> as the signal to the master that the data is ready. The master requests data, the slave gets the data, then pulls <code>MISO</code> low to signal it is ready for the master to read the data.</p>
<h5 id="problem">Problem</h5>
<p>After the SPI slave enables the SPI hardware module:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb83-1" title="1">SetBit(Spi_spcr, Spi_Enable);</a></code></pre></div>
<p><code>MISO</code> no longer behaves as general purpose I/O. <code>MISO</code> idles high (I think it is pulled-up, not a hard high, but I have not tested this). This has no affect:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb84-1" title="1">ClearBit(Spi_port, Spi_Miso);</a></code></pre></div>
<p>The pin continues to idle high and the SPI master thinks the slave is still collecting data.</p>
<p>Of course, the pin must be configured as an output pin for the SPI hardware module to use it as a slave output line. But what is not clearly stated anywhere is the loss of control via the <code>PORT</code> register.</p>
<p><em>As long as SPI is enabled, only the SPI hardware module has control over MISO</em>.</p>
<p>I cannot use <code>MISO</code> to signal to the master that data is ready.</p>
<h5 id="solution">Solution</h5>
<p>Just kidding. It’s an easy fix.</p>
<p>Follow the <code>MISO</code>-go-low instruction with a quick <code>SpiDisable()</code> to regain control of the pin and <code>SpiEnable()</code> to give control back to the SPI hardware module:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb85-1" title="1">ClearBit(Spi_port, Spi_Miso);    <span class="co">// signal the slave is ready</span></a>
<a class="sourceLine" id="cb85-2" title="2">ClearBit(Spi_spcr, Spi_Enable);  <span class="co">// disable SPI -- now MISO goes low</span></a>
<a class="sourceLine" id="cb85-3" title="3">SetBit  (Spi_spcr, Spi_Enable);  <span class="co">// enable SPI -- MISO is pulled back up</span></a></code></pre></div>
<h5 id="well-not-really-timing">Well not really – timing</h5>
<p>The fix only works with the sluggish function call overhead. With that removed, this doesn’t work at all. To make matters worse, I cannot measure the MISO signal on an oscilloscope. The pin is not pulled up, so there is nothing to see. Attempting to measure on an oscilloscope interferes with communication.</p>
<h5 id="it-makes-sense-in-hindsight">It makes sense in hindsight</h5>
<p>It kind of makes sense that the SPI module works this way, but I’m still annoyed this isn’t spelled out in the datasheet.</p>
<p>I mean it is spelled out in <code>Figure 13-5. Alternate Port Functions</code>. But that takes a real careful, thoughtful read of the datasheet. The <code>SPI</code> section doesn’t mention this, and that’s what I’m ticked about.</p>
<p>Of course, the chip has to work this way. As <code>Figure 13-5</code> shows, a <em>MUX</em> is needed to select whether control goes to general purpose or the alternate function. And what signal controls the <em>MUX</em>? The act of <em>enabling/disabling</em> the alternate function. A nice and simple system. I just wish the implication was stated explicitly.</p>
<p>From a system-design point-of-view, this is definitely a feature, not a bug. Disabling PORT control is a safeguard. In a multi-slave system, if SPI is always enabled, the pin can only drive the MISO line when the slave is select. This protects against the slave driving MISO while another slave is driving MISO. The SPI protocol handles selecting one slave at a time, and the SPI hardware module tri-states the MISO for inactive slaves.</p>
<h3 id="detection-logic-for-spi-data-ready-signal-includes-tri-state">Detection logic for SPI data-ready signal includes tri-state</h3>
<ul>
<li>the SPI slave uses MISO to signal when data is ready</li>
<li>this happens in software</li>
<li>this happens <em>outside</em> the SPI transfer</li>
<li>therefore the SPI module is disabled to let the slave do this</li>
<li>but disabling the SPI module is not the main problem</li>
<li>the main problem is that the slave <em>does not</em> disable the SPI module until it wants to signal that it is ready</li>
<li>[ ] TODO: so why didn’t I just change that do teh SpiDisable() when the SPI slave recieves the <code>request_frame</code> command?</li>
<li>if the transfer ends with a low, <code>MISO</code> is <em>slowly</em> pulled high, it is not driven high as it is during the transfer</li>
<li>if the SPI master starts right away checking for a low on <code>MISO</code>, it will think this slowly rising <code>MISO</code> voltage <em>is</em> a low driven by the slave</li>
<li>luckily, the pull-up at least ensures a monotonic rise</li>
<li>the SPI master must first look for a high on <code>MISO</code></li>
<li>a high and a low are separated by some voltage, so by the time <code>MISO</code> is high enough to look high, it is <em>definitely</em> not going to look low from noise
<ul>
<li>there is no need for any debouncing</li>
<li>this is kind of like a Schmitt trigger providing hysteresis:
<ul>
<li>look for a high</li>
<li>after high, look for a low</li>
<li>by the time the signal is high, it well above the threshold for low</li>
</ul></li>
</ul></li>
<li>the SPI master starts looking for <code>MISO</code> low after it sees <code>MISO</code> high</li>
<li>to make sure the SPI slave is ready, the SPI master again waits for <code>MISO</code> to go high before continuing</li>
<li>after the SPI slave pulls <code>MISO</code> high, it re-enables the SPI hardware module</li>
</ul>
<h4 id="what-i-implemented-in-the-firmware-sent-to-osram-2018-08-28">what I implemented in the firmware sent to Osram 2018-08-28</h4>
<div class="sourceCode" id="cb86"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb86-1" title="1"><span class="pp">#define MacroSpiResponseIsReady() MacroBitIsClear(Spi_pin, Spi_Miso)</span></a>
<a class="sourceLine" id="cb86-2" title="2"><span class="pp">#define MacroSpiMasterWaitForResponse() do { \</span></a>
<a class="sourceLine" id="cb86-3" title="3"><span class="pp">    while(  MacroSpiResponseIsReady() ); \</span></a>
<a class="sourceLine" id="cb86-4" title="4"><span class="pp">    while( !MacroSpiResponseIsReady() ); \</span></a>
<a class="sourceLine" id="cb86-5" title="5"><span class="pp">    while(  MacroSpiResponseIsReady() ); \</span></a>
<a class="sourceLine" id="cb86-6" title="6"><span class="pp">} while (0)</span></a></code></pre></div>
<ul>
<li>the first <code>while</code> loop:
<ul>
<li>loop and do nothing while <code>MISO</code> is low</li>
<li>exit the loop when <code>MISO</code> is high</li>
<li>this guarantees <code>MISO</code> is high before the SPI master looks for <code>MISO</code> low</li>
</ul></li>
<li>the second <code>while</code> loop:
<ul>
<li>loop and do nothing while <code>MISO</code> is high</li>
<li>exit the loop when <code>MISO</code> is low</li>
<li>this is the SPI slave signaling <em>data is ready</em></li>
</ul></li>
<li>the third <code>while</code> loop:
<ul>
<li>loop and do nothing while <code>MISO</code> is low</li>
<li>exit the loop when <code>MISO</code> is high</li>
<li>this is the SPI master catching when the SPI slave is done sending the <em>data is ready</em> signal and is now going to re-enable the SPI slave hardware module</li>
</ul></li>
<li>but the SPI slave does not actively drive <code>MISO</code> high again:</li>
</ul>
<div class="sourceCode" id="cb87"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb87-1" title="1"><span class="pp">#define MacroSpiSlaveSignalDataIsReady() do { \</span></a>
<a class="sourceLine" id="cb87-2" title="2"><span class="pp">    MacroClearBit(Spi_port, Spi_Miso); \</span></a>
<a class="sourceLine" id="cb87-3" title="3"><span class="pp">    MacroDisableSpi(); \</span></a>
<a class="sourceLine" id="cb87-4" title="4"><span class="pp">    Delay3CpuCyclesPerTick(10); \</span></a>
<a class="sourceLine" id="cb87-5" title="5"><span class="pp">    MacroEnableSpi(); \</span></a>
<a class="sourceLine" id="cb87-6" title="6"><span class="pp">} while (0)</span></a></code></pre></div>
<ul>
<li>and <code>MacroEnableSpi()</code> does not drive <code>MISO</code> high:</li>
</ul>
<div class="sourceCode" id="cb88"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb88-1" title="1"><span class="pp">#define MacroEnableSpi() MacroSetBit(Spi_spcr, Spi_Enable)</span></a></code></pre></div>
<ul>
<li>the SPI slave does <em>not</em> pull <code>MISO</code> high first!</li>
<li>it just re-enables SPI and lets <code>MISO</code> slowly rise up again
<ul>
<li>this guarantees the SPI slave has time to get ready</li>
<li>but I’d rather:
<ul>
<li>the slave ends <em>data is ready</em> by driving <code>MISO</code> high</li>
<li>then release <code>MISO</code> by re-enabling the SPI slave hardware module</li>
</ul></li>
<li>in this scenario, the SPI master uses a fixed delay before starting communication</li>
<li>this will cut-down on unnecssary wait time</li>
<li>and it will make the overall system more deterministic by making it less dependent on the pull-up resistor value and the parasitic capacitance on the <code>MISO</code> pin</li>
</ul></li>
</ul>
<h4 id="philosophizing">philosophizing</h4>
<ul>
<li>this is a case where logic is not binary</li>
<li><em>not low</em> does not imply <em>high</em></li>
<li>the tri-state makes <em>not low</em> ambiguous
<ul>
<li>it could mean <em>high</em></li>
<li>or it could mean <em>tri-state</em></li>
<li>the abstraction of <em>negation</em> is not sufficient in this context</li>
</ul></li>
<li>since it is a SPI pin, <em>not low</em> means <em>tri-state</em>
<ul>
<li>the pin has a pull-up resistor</li>
<li>this gives predictable behavior:
<ul>
<li>if the transfer ends with <code>MISO</code> high
<ul>
<li>then <em>not ready</em> is <code>MISO</code> high</li>
</ul></li>
<li>if the transfer ends with <code>MISO</code> low
<ul>
<li>then <em>not ready</em> is an exponential decay from 0V to 3.0V</li>
</ul></li>
<li>in both cases, the SPI master first looks for <code>MISO</code> high</li>
<li>this ensures the <code>MISO</code> pin is in a high state</li>
<li>the SPI slave must then also set a minimum high time on <code>MISO</code> for setup, not just a minimum low time</li>
<li>and to make sure the SPI master does not start the transfer before the SPI slave re-enables communication, the SPI slave must also set a maximum time from <code>MISO</code> high to when it has renabled its SPI hardware module
<ul>
<li>this does not have to be a minimum because after <code>MISO</code> goes high, the SPI slave does nothing until the SPI master starts communication, so the SPI master has all the time it needs to check <code>MISO</code></li>
<li>it is a maximum because the SPI master has no other way to know the SPI slave is ready ### TODO: implement bullet-proof logic to detect <em>data is ready</em> signal</li>
</ul></li>
</ul></li>
</ul></li>
<li>I did not fully implement the bullet-proof logic outlined above</li>
<li>I look for <code>MISO</code> high</li>
<li>then I look for <code>MISO</code> low</li>
<li>then I delay to give the SPI slave time to re-enable the SPI hardware module</li>
<li>so I have no protection against two scenarios:
<ol type="1">
<li>the SPI slave pulls <code>MISO</code> low before it ever has a chance to rise high
<ul>
<li>then the SPI master sits in an infinite loop waiting for <code>MISO</code> to go high</li>
<li>this never happens, but there is no guarantee I will not extend functionality and continue to avoid this</li>
<li>fix: the SPI slave first holds <code>MISO</code> high for a guaranteed minimum before pulling <code>MISO</code> low to signal data is ready</li>
</ul></li>
<li>the SPI master starts the transfer before the SPI slave re-enables the <code>SPI</code> hardware module
<ul>
<li>again, this never happens, but there is no guarantee it will never happen in the future as functionality grows</li>
<li>fix: the SPI slave has a maximum guaranteed time from <code>MISO</code> high until the SPI hardware module is enabled</li>
<li>if the SPI master waits for this amount of time after detecting <code>MISO</code> high, it is guaranteed the SPI slave is ready</li>
</ul></li>
</ol></li>
<li>another protocol rule to implement is that the Chromation Digital Interface maintains control over <code>MISO</code> once the SPI master requests data
<ul>
<li>no other SPI slave may drive <code>MISO</code> until the SPI master reads the requested data</li>
<li>this is to avoid contention where another device is trying to signal the SPI master</li>
<li>this contention is easily avoided by the SPI master</li>
<li>the SPI master must not attempt to communicate with other SPI devices once it has requested data from the Chromation Digital Interface</li>
<li>this guarantees it is OK for the Chromation Digital Interface to use <code>MISO</code> to signal when data is ready</li>
<li>but the <em>data is ready</em> signal is highly deterministic, so if the SPI master <em>does</em> attempt to pipeline communication with other SPI slaves, e.g., requesting a frame of data with a long integration time, it is up to the SPI master to time everything so that the Chromation Digital Interface is <em>the only</em> SPI slave that drives <code>MISO</code> when the Chromation Digital Interface sends the <em>data is ready</em> signal</li>
</ul></li>
<li>[ ] add a 10k resistor on the next design of the Chromation Digital Interface
<ul>
<li>purpose: want the SPI MISO pull-up to be independent of the value of the internal pull-up resistor in the SPI slave hardware module</li>
</ul></li>
</ul>
<h3 id="todo-code-for-bad-actor-spi-scenarios">TODO: code for bad actor SPI scenarios</h3>
<ul>
<li>I have done nothing to handle the cases where the SPI master is a bad actor:
<ul>
<li>the SPI master sends a second data request before receiving the data from the previous data request</li>
<li>the SPI master sends commands to change exposure time or to change the LIS programming settings while the SPI slave is still acquiring data to fulfill a previous data request</li>
</ul></li>
<li>the SPI slave implementation sent to Osram on 2018-08-28 might already handle these cases:
<ul>
<li>see <code>Commands affect the state of the spectrometer chip digital interface</code></li>
<li>TLDR:
<ul>
<li>the <code>SPI slave</code> ignores communications sent while it still has unread frame data</li>
<li>the <code>SPI slave</code> interprets data sent after commands as the values for those commands</li>
</ul></li>
<li>[ ] but I still need to write tests to see what happens in these cases
<ul>
<li>show the effect is:
<ul>
<li>the slave simply ignores the bad communications</li>
<li>the master gets meaningless garbage back</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="spi-simbrd-and-mbrd-hardware">SPI simBrd and mBrd hardware</h2>
<ul>
<li>the <code>SPI</code> pin connections on the <code>mBrd</code> are exactly the same as on the <code>simBrd</code></li>
</ul>
<div class="sourceCode" id="cb89"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb89-1" title="1"><span class="co">//  =====[ I/O Register Address ]=====          =====[ Register&#39;s Purpose ]=====</span></a>
<a class="sourceLine" id="cb89-2" title="2"><span class="dt">uint8_t</span> <span class="dt">volatile</span> * <span class="dt">const</span> Spi_ddr     =   &amp;DDRB;  <span class="co">// data direction in/out</span></a>
<a class="sourceLine" id="cb89-3" title="3"><span class="dt">uint8_t</span> <span class="dt">volatile</span> * <span class="dt">const</span> Spi_port    =   &amp;PORTB; <span class="co">// output (Port out)</span></a>
<a class="sourceLine" id="cb89-4" title="4"><span class="dt">uint8_t</span> <span class="dt">volatile</span> * <span class="dt">const</span> Spi_pin     =   &amp;PINB;  <span class="co">// input  (Port in)</span></a>
<a class="sourceLine" id="cb89-5" title="5"><span class="co">// =====[ Spi Pin Connection On simBrd and mBrd ]=====</span></a>
<a class="sourceLine" id="cb89-6" title="6"><span class="dt">uint8_t</span> <span class="dt">const</span> Spi_Ss     =   PB2;    <span class="co">// Slave select</span></a>
<a class="sourceLine" id="cb89-7" title="7"><span class="dt">uint8_t</span> <span class="dt">const</span> Spi_Mosi   =   PB3;    <span class="co">// master data line: master-out, slave-in</span></a>
<a class="sourceLine" id="cb89-8" title="8"><span class="dt">uint8_t</span> <span class="dt">const</span> Spi_Miso   =   PB4;    <span class="co">// slave data line: master-in, slave-out</span></a>
<a class="sourceLine" id="cb89-9" title="9"><span class="dt">uint8_t</span> <span class="dt">const</span> Spi_Sck    =   PB5;    <span class="co">// SPI clock</span></a></code></pre></div>
<ul>
<li><code>simBrd</code> and <code>mBrd</code> are both ATmega328P on 10MHz oscillators</li>
<li><code>mBrd</code> is the SPI slave
<ul>
<li><code>mBrd</code> uses SPI hardware peripheral</li>
<li><code>mBrd</code> configures an interrupt for byte received over SPI</li>
</ul></li>
<li><code>simBrd</code> is the SPI master
<ul>
<li><code>simBrd</code> uses USART hardware peripheral</li>
</ul></li>
<li>SPI master SCK shall not exceed 2MHz.</li>
<li>SPI master is an ATmega328P with a 10MHz oscillator.</li>
<li>SPI master shall use SCK = fosc/8 = 1.25MHz.</li>
<li><code>simBrd</code> MCU <code>SCK</code> clocks <code>mBrd</code> MCU <code>SCK</code> at <code>fosc/8 = 1.25MHz</code></li>
<li><code>mBrd</code> is SPI master to ADC
<ul>
<li>its <code>USART</code> clocks ADC SCK at <code>fosc/2 = 5MHz</code></li>
</ul></li>
</ul>
<h2 id="old-but-useful-spi-master-writes-to-spi-slave">Old but useful: SPI master writes to SPI slave</h2>
<ul>
<li>[x] continue copying in from &gt; <code>/cygdrive/c/chromation-dropbox/Dropbox/design files and protocols/circuits/pcb design/eagle/projects/Chromation/20150807_SPI_Wand/doc/design on paper/Communication With FLIR Ex-Series Camera.txt</code></li>
<li><code>simBrd</code> transmits to <code>mBrd</code>:
<ul>
<li><code>simBrd</code> pull <code>mBrd</code> <code>!SS</code> low</li>
<li><code>simBrd</code> sends byte</li>
<li><code>mBrd</code> receives byte in SPI hardware buffer</li>
<li>when one byte is received, hardware triggers interrupt and <code>mBrd</code> reads byte from SPI buffer</li>
<li><code>simBrd</code> pulls <code>mBrd</code> <code>!SS</code> high (allowing slave to use its MISO pin as a GPIO)</li>
</ul></li>
<li><code>mBrd</code> transmits to <code>simBrd</code>:
<ul>
<li>example: <code>simBrd</code> is waiting to receive a frame of data</li>
<li><code>simBrd</code> is polling MISO
<ul>
<li>MISO goes low when the frame is ready</li>
<li>(check that control of MISO is automatically given to the SPI hardware module when the <code>mBrd</code> is put into slave mode)</li>
</ul></li>
<li><code>simBrd</code> pulls <code>!SS</code> low
<ul>
<li><code>mBrd</code> is automatically placed into SPI slave mode</li>
<li>MISO output is controlled by SPI hardware</li>
</ul></li>
<li><code>simBrd</code> loads a byte of garbage into its transmit buffer
<ul>
<li>this starts a transmission</li>
<li>eight bits of garbage are sent to the slave</li>
<li>the slave transmits eight bits of frame data at the same time</li>
<li>the slave needs to prepare the next byte as soon as it knows the previous one has been sent</li>
</ul></li>
<li><code>simBrd</code> keeps <code>!SS</code> low</li>
<li><code>simBrd</code> reads the byte received from the slave</li>
<li><code>simBrd</code> loads another byte of garbage into its transmit buffer
<ul>
<li>this start another transmission</li>
</ul></li>
<li><code>simBrd</code> continues this until it has read a full frame (784 pixels * 2 bytes per pixel = 1568 bytes)</li>
<li><code>simBrd</code> checks the frame to make sure it was received correctly
<ul>
<li>not sure how to do this – want to do a checksum?</li>
</ul></li>
<li><code>simBrd</code> requests a new frame from the <code>mBrd</code></li>
</ul></li>
</ul>
<h2 id="old-notes-that-are-probably-not-useful-anymore">Old notes that are probably not useful anymore</h2>
<h3 id="old-reference-docs">Old Reference docs</h3>
<blockquote>
<p><code>C:\chromation-dropbox\Dropbox\design files and protocols\circuits\pcb design\eagle\projects\Chromation\20150807_SPI_Wand\doc\design on paper\Communication With FLIR Ex-Series Camera.txt</code> <code>/cygdrive/c/chromation-dropbox/Dropbox/design files and protocols/circuits/pcb design/eagle/projects/Chromation/20150807_SPI_Wand/doc/design on paper/Communication With FLIR Ex-Series Camera.txt</code> <code>C:\chromation-dropbox\Dropbox\design files and protocols\circuits\mcu\Atmel Studio\LIS-770i_Interface\20151020_LIS-770i_mBrd\src\main.c</code> <code>/cygdrive/c/chromation-dropbox/Dropbox/design files and protocols/circuits/mcu/Atmel Studio/LIS-770i_Interface/20151020_LIS-770i_mBrd/src/main.c</code></p>
</blockquote>
<h3 id="standard-spi">Standard SPI</h3>
<ul>
<li>SPI master <em>always</em> initiates communication</li>
<li>Every SPI communication is both a <strong>read</strong> and a <strong>write</strong>
<ul>
<li>master and slave form an 8-bit circular buffer</li>
<li>the 8-bits in the slave’s transmit buffer get shifted into the master’s receive buffer</li>
<li>the 8-bits in the master’s transmit buffer get shifted into the slave’s receive buffer ### SPI sensors</li>
</ul></li>
<li>many SPI sensors are slaves that only transmit (no receive buffer)</li>
<li>transmit only scheme:
<ul>
<li>host transmit buffer is garbage</li>
<li>clock slave some number of times</li>
<li>clock drives the sensor’s ADC</li>
<li>meaningful data received on last N clocks after the first M clocks.</li>
</ul></li>
<li>the <code>mBrd</code> is configurable so it must receive too ### Basic SPI</li>
<li>SPI master loads a byte into its SPI data register</li>
<li>SPI master tells its hardware peripheral to send the byte</li>
<li>SPI slave hardware peripheral receives the byte
<ul>
<li>this is independent of the main program execution</li>
</ul></li>
<li>SPI slave has an interrupt that triggers when a byte is received
<ul>
<li>this interrupt notifies the CPU that a byte was received</li>
<li>this is the first time the SPI slave need even be aware that the SPI master has been communicating with it.</li>
</ul></li>
</ul>
<h3 id="spi-with-slavechip-select">SPI with Slave/Chip Select</h3>
<ul>
<li>There is a fourth SPI signal called Slave Select or Chip Select.
<ul>
<li>SPI master MCU <code>Spi_Ss</code> pin can by any general purpose I/O on the <code>ATmega328</code></li>
<li>SPI slave MCU <code>Spi_Ss</code> is a specific pin that ties into the SPI hardware peripheral</li>
</ul></li>
<li>When the <code>simBrd</code> MCU wants to talk to the <code>mBrd</code>, it pulls <code>Spi_Ss</code> low to put the <code>mBrd</code> MCU’s SPI hardware peripheral into a state where it is ready to receive communication.
<ul>
<li>If the <code>simBrd</code> MCU transimts data without pulling <code>Spi_Ss</code> low, the <code>mBrd</code> MCU’s SPI hardware peripheral ignores the communication.</li>
<li>This allows the <code>simBrd</code> MCU to have multiple SPI slaves on the same SPI bus (every slave’s SCK connected to the master’s SCK, etc.), but only communicate with one slave at a time. The SPI master has a separate <code>Spi_Ss</code> pin for each slave.</li>
</ul></li>
</ul>
<h1 id="uart-spi">UART SPI</h1>
<ul>
<li>lib <code>UartSpi</code></li>
<li>the <code>mBrd</code> MCU is the SPI master</li>
<li>the <code>mBrd</code> ADC is the SPI slave</li>
</ul>
<h2 id="spi-communication-with-ltc1864ladc">SPI communication with LTC1864LADC</h2>
<p>Tx a byte: - Wait until bit UDREn in reg UCSRnA is high. - Write two bytes to UDRn for a 16-bit transfer. - Wait for an interrupt that is triggered when the UART transmission completes. Or, wait until bit RXCn in reg UCSRnA is high.</p>
<h1 id="lis">LIS</h1>
<ul>
<li>lib <code>Lis</code></li>
</ul>
<h2 id="one-frame-of-data">one frame of data</h2>
<ul>
<li>the ADC converts every pixel to a 16-bit value</li>
<li>there are 784 pixels
<ul>
<li>the first 13 are optically dark</li>
<li>the 14th is a dummy</li>
<li>15-784 are optically active</li>
</ul></li>
<li>784 * 2 bytes = 1568 bytes</li>
<li>hopefully the ATmega 2K SRAM can handle this</li>
<li>if not, we can ignore the first 14 pixels
<ul>
<li>that makes it 1540 bytes</li>
</ul></li>
<li>there are probably more pixels we can ignore too
<ul>
<li>revisit the optical design to see which pixels are actually used</li>
</ul></li>
</ul>
<h2 id="power-down">power down</h2>
<ul>
<li>see <code>Power Standby Mode</code></li>
<li><code>Lis_Rst</code> is high</li>
<li><code>Lis_Clk</code> stops and idles low</li>
<li>remains in power down mode until <code>Lis_Rst</code> is pulled low and <code>Lis_Clk</code> is restarted</li>
</ul>
<h2 id="power-up">power up</h2>
<ul>
<li>see <code>Power Up sequence</code></li>
<li><code>Lis_Rst</code> is pulled low</li>
<li><code>Lis_Clk</code> starts</li>
<li>this power up sequence resets the imager</li>
<li>default programming is enabled:
<ul>
<li>select entire active pixel array</li>
<li>set output amplifier gain to 2.5x</li>
<li>turn off the summing mode</li>
</ul></li>
</ul>
<h2 id="programmable-setup">programmable setup</h2>
<ul>
<li>see <code>Programmable Setup Register</code></li>
<li>power up</li>
<li>pull <code>Lis_PixSelect</code> high
<ul>
<li>[x] <code>LisInit()</code> idles <code>Lis_PixSelect</code> low</li>
</ul></li>
<li>first rising clock edge reads <code>Lis_Rst</code>
<ul>
<li>this sets the value of the <em>summing mode bit</em></li>
<li><em>Summing Mode = 0</em> - normal operation
<ul>
<li>pixels are 7.8um wide</li>
</ul></li>
<li><em>Summing Mode = 1</em> - every other pixel is added together during integration
<ul>
<li>the size of the pixel array is halved to 392 pixels</li>
<li>pixel width becomes 15.6um</li>
<li>only 392 clocks are needed to output the data</li>
</ul></li>
</ul></li>
<li>2nd and 3rd rising clock edges read <code>Lis_Rst</code>
<ul>
<li>sets the value of gain bits <code>G2</code> and <code>G1</code></li>
<li>hold <code>Lis_Rst</code> high for 25 clock cycles after the gain bits are set</li>
<li>this completely contradicts what the datasheet says next</li>
</ul></li>
<li>4th through 28th rising clock edges read <code>Lis_Rst</code>
<ul>
<li>sets the active pixel sub-arrays in the order P25 to P1</li>
<li>see <em>Table 5b: Selectable Pixel Array</em> to see which pixel is in which of the 25 pixel sub-arrays
<ul>
<li>a pixel has five segments in the <em>pixel height</em> direction</li>
<li>each segment is 62.5um tall</li>
<li>each sub-array is one segment tall</li>
<li>each sub-array spans 154 pixels</li>
</ul></li>
<li>just keep reset high, this selects every segment of every pixel</li>
</ul></li>
</ul>
<h2 id="frame-readout">frame readout</h2>
<ul>
<li><code>Lis_Clk</code> is running
<ul>
<li>[x] <code>LisInit()</code> pulls <code>Lis_Rst</code> low</li>
<li>[x] <code>LisInit()</code> starts the <code>Lis_Clk</code>
<ul>
<li>in the future, <code>LisInit()</code> will not start the clock</li>
<li>this will be a separate command to leave power-down mode</li>
<li>but for now intialize in power up mode</li>
</ul></li>
</ul></li>
<li>[ ] TODO: implement a power-down mode
<ul>
<li>[ ] provide a SPI command to enter/exit power-down mode</li>
</ul></li>
<li>Do I need to use the <em>ISR</em> to do things on clock rising/falling edges?</li>
<li>No, this can be done without interrupts by polling flags and manually clearing flags. In fact it is slightly faster without interrupts because it cuts out the function call/return overhead of the ISR.
<ul>
<li>The output compare unit sets the output compare flag <code>OCF0A</code> or <code>OCF0B</code> when <code>TCNT0</code> equals <code>OCR0A</code> or <code>OCR0B</code>.</li>
<li>Clear the flag in software by writing a logical one to its I/O bit location.</li>
<li>I tested with and without interrupts and the fastest performance is to do this without interrupts. That is worth the extra step of manually clearing the flag. The result code is easier to read too.</li>
<li>Unfortunately, I also discovered the high-level code makes the response time to clock edges unacceptably slow. It is so slow that attempting to follow the clock edges on Rst makes Rst output a square wave that jitters between sometimes being half the frequency, sometimes the same frequency, because it only rarely catches adjacent clock edges.</li>
</ul></li>
<li><code>Lis_Rst</code> is low
<ul>
<li><code>LisInit()</code> has <code>Lis_Rst</code> idle high for power-saving</li>
<li>but once the device is in power up mode, <code>Lis_Rst</code> is low</li>
</ul></li>
<li><code>Lis_Rst</code> controls the integration period
<ul>
<li>in the following, <code>Lis_Rst</code> is pulled high and low</li>
<li>the new value is clocked in on the very next rising edge of <code>Lis_Clk</code> after <code>Lis_Rst</code> has changed</li>
<li>[x] change the value of <code>Lis_Rst</code> just after a <code>Lis_Clk</code> falling edge
<ul>
<li>this avoids confusion over when the LIS shifts in the new value of <code>Lis_Rst</code></li>
<li>at 50kHz, it is 10us from the clock falling edge to the clock rising edge</li>
<li>there is a 0.6us to 0.8us delay between the actual clock falling edge and the time it takes software to catch the fall and pull <code>Lis_Rst</code> high or low</li>
<li>so in effect, I am guaranteed to have <code>Lis_Rst</code> always transition about 9us just before the next <code>Lis_Clk</code> rising edge, and to never transition during a clock edge</li>
</ul></li>
</ul></li>
<li><code>ExposureStart()</code> - pull <code>Lis_Rst</code> high
<ul>
<li>resets all pixels</li>
<li>integration begins</li>
</ul></li>
<li><code>Lis_Rst</code> goes low
<ul>
<li>integration ends</li>
<li>integration time is the number of clock cycles that <code>Lis_Rst</code> was high</li>
<li>[x] decide how to track the integration period:
<ul>
<li>check for N clock cycles in the PWM interrupt?
<ul>
<li>requires the ISR know about the state of the system</li>
<li>system can take new requests while the camera integrates</li>
<li>no – ISR adds call/return overhead, slowing response time</li>
</ul></li>
<li>or sit and poll the interrupt flag, incrementing a counter
<ul>
<li>localizes where the state needs to be known to precisely that place where it is used</li>
<li>entire system blocks until integration period ends</li>
<li>yes – there is nothing else the system has to do</li>
</ul></li>
</ul></li>
</ul></li>
<li>Exposure time
<ul>
<li>LisRst is high for 20us * nticks + 2us</li>
<li>But the LIS is counting clock pulses, so exposure time is exactly 20us * nticks.</li>
</ul></li>
<li><code>Lis_Sync</code> input is pulsed high &gt; Once RST is brought low a synchronization signal (SYNC) pulse is fired &gt; starting on the next falling clock edge. Pixel readout then begins on the next &gt; rising CLK edge after the SYNC signal goes low and continues for 784 clock &gt; cyles. The SYNC signal is one clock period wide. SYNC is again fired during &gt; the last pixel readout on the falling edge of CLK.
<ul>
<li><code>ExposureStop()</code> - pull <code>Lis_Rst</code> low
<ul>
<li>call this just after a <code>Lis_Clk</code> falling edge</li>
<li>exposure officially stops on the next <code>Lis_Clk</code> rising edge</li>
</ul></li>
<li><code>WaitForSync()</code> - watch for <code>Lis_Sync</code> to go high, then low
<ul>
<li>call this just after calling <code>ExposureStop()</code></li>
<li><code>Lis_Sync</code> goes high on the next falling clock edge</li>
<li><code>Lis_Sync</code> then goes low on the next falling clock edge</li>
<li>pixel readout starts on the very next clock rising edge</li>
</ul></li>
<li><code>PixelReadout()</code> - sample analog <code>VOUT</code> while the clock is high
<ul>
<li>video output may have disturbance during the falling clock edge</li>
<li>pixels 1 to 13 are dark</li>
<li>pixels 15 to 784 are optical</li>
</ul></li>
</ul></li>
</ul>
<h1 id="program-flash">Program Flash</h1>
<h2 id="quick-summary">Quick Summary</h2>
<ul>
<li>check hardware connection: <code>;mkp</code>
<ul>
<li>Expect device signature is <code>0x1E950F</code></li>
<li>Expect fuse settings are <code>EXTENDED 0xFF, HIGH 0xD9, LOW 0xF7</code></li>
<li>[ ] to do: program fuses from Vim
<ul>
<li>off the shelf, LOW is 0x62</li>
<li>for now just go into AtmelStudio to set the LOW to 0xF7</li>
</ul></li>
</ul></li>
<li>check build recipe: <code>;mna</code>
<ul>
<li>Expect build output is <code>simBrd.elf</code> if programming the <code>simBrd</code> MCU</li>
</ul></li>
<li>build and check size: <code>;mka</code>
<ul>
<li>builds the <code>Makefile</code> in the active folder</li>
<li><code>;nr</code> refresh the build folder</li>
<li>open <code>avr-size_simBrd.log</code></li>
<li><code>make</code> reports <code>Nothing to be done for avr-target</code> if the <code>.elf</code> has not changed</li>
<li>clean the build to force a rebuild</li>
</ul></li>
<li>clean the build <code>;mc</code></li>
<li>download flash: <code>;fa</code></li>
<li>build and download flash: <code>;mfa</code>
<ul>
<li>downloads flash whether or not the build needed to be rebuilt</li>
</ul></li>
</ul>
<h2 id="compiler-options">Compiler options</h2>
<blockquote>
<p><code>https://www.microchip.com/webdoc/AVRLibcReferenceManual/using_tools_1using_sel_gcc_opts.html</code></p>
</blockquote>
<h2 id="memory-on-the-atmega328">Memory on the ATmega328</h2>
<p>The ATmega328 uses a <em>Harvard architecture</em> meaning separate memory and buses for program and data:</p>
<ul>
<li><strong>2KBytes</strong> of <em>SRAM</em> hold data memory</li>
<li><p><strong>32KBytes</strong> of <em>Flash</em> hold program memory</p></li>
<li><em>SRAM</em> <strong>is not</strong> <em>Flash</em></li>
<li><em>Flash</em> holds the program memory</li>
<li><p><em>SRAM</em> holds the data memory</p></li>
</ul>
<p>Both the <em>SRAM</em> and <em>Flash</em> use indirect addressing because it is a large amount of memory to navigate and the buses are only 8-bit. The <strong>32</strong> 8-bit <em>General Purpose Registers</em> use direct addressing.</p>
<p>Static memory, stack memory, and the heap all use the <em>SRAM</em>. Static memory is never a problem. The trouble is with <em>stack-heap collisions</em>.</p>
<h3 id="ram-layout-and-stack-heap-collisions">RAM layout and stack-heap collisions</h3>
<blockquote>
<p>https://www.nongnu.org/avr-libc/user-manual/malloc.html</p>
</blockquote>
<ul>
<li><em>.data</em> are initialized variables</li>
<li><em>.bss</em> are uninitialized variables</li>
<li>both are stored in <em>SRAM</em></li>
</ul>
<p>These are <em>static-mem</em> variables. The standard RAM layout is to place <em>.data</em> then <em>.bss</em> at the beginning. Then the <em>heap</em> starts.</p>
<p>The <em>stack-mem</em> starts at the end of RAM and grows towards the beginning.</p>
<p>The trouble is the <em>heap</em> and <em>stack</em> can both require arbitrarily large amounts of memory.</p>
<p>Besides allocating memory dynamically, the <em>heap</em> causes trouble if there is a memory that is allocted but never freed, or if the memory is freed but RAM because fragmented such that the freed memory is never reallocated. The <em>stack</em> grows as stack frames stack up from nested function calls. The size of each stack frame depends on how much data is local to that function.</p>
<p>It is hard to predict when the <em>heap</em> and the <em>stack</em> might collide.</p>
<h3 id="size-of-the-final-.elf-files">Size of the final <code>.elf</code> files</h3>
<ul>
<li>the avr-target executable is an <code>elf32-avr</code> with a <code>.elf</code> extension</li>
<li><code>avr-size</code> is a utility to report the size of a <code>.elf</code> by section:</li>
</ul>
<pre class="make"><code>build/%.elf: ${obj_dev-libs} src/%.c ${avr-asm-macros}
    avr-gcc $^ -o $@ $(CFLAGS)  \
        -Wl,-Map=&quot;build/$*.map&quot; -Wl,--gc-sections
    avr-size $@ &gt; build/avr-size_simBrd.log</code></pre>
<ul>
<li>example output of <code>avr-size</code>:</li>
</ul>
<pre><code>   text    data     bss     dec     hex filename
    730      34       7     771     303 build/simBrd.elf</code></pre>
<ul>
<li>about these values:
<ul>
<li>units are bytes</li>
<li>numbers are represented in base 10 except for the final <code>hex</code> column</li>
<li>the <code>dec</code> and <code>hex</code> columns are the total <em>Flash</em> memory used</li>
</ul></li>
<li>memory sections are described here: &gt; <code>https://www.microchip.com/webdoc/AVRLibcReferenceManual/mem_sections_1sec_dot_text.html</code></li>
<li>I think the following is a decent summary #### <code>.text</code> memory section</li>
<li>the <code>.text</code> contains the machine instructions</li>
<li>the total amount of <em>Flash</em> memory consumed is the <code>.text</code> plus the <code>.data</code>
<ul>
<li>the <code>.data</code> is added because the <em>Flash</em> gets: &gt; a copy of the <code>.data</code> initializers</li>
</ul></li>
<li>the <code>ATmega328P</code> has <code>32KBytes</code> of <em>Flash</em></li>
<li>example: How much of the <em>Flash</em> did I use?
<ul>
<li><code>.data</code>: 34</li>
<li><code>.text</code>: 730</li>
<li>total: <strong>764</strong></li>
</ul></li>
<li>so this small example application uses less than <code>1KByte</code></li>
<li>that is about 2.4% of the <em>Flash</em> memory.</li>
</ul>
<h4 id="data-memory-section"><code>.data</code> memory section</h4>
<ul>
<li>static data:
<ul>
<li>constants</li>
<li>initialized globals</li>
<li>initialized static variables</li>
</ul></li>
<li><code>.data</code> and <code>.bss</code> are both data, so they both go in <code>SRAM</code></li>
<li>the total amount of <em>SRAM</em> consumed is the <code>.data</code> plus <code>.bss</code></li>
<li>the <code>ATmega328P</code> has <code>2KBytes</code> of <em>SRAM</em></li>
<li>example: How much of the <em>SRAM</em> did I use?
<ul>
<li><code>.data</code>: 34</li>
<li><code>.bss</code>: 7</li>
<li>total: <strong>41</strong></li>
</ul></li>
<li>that is about 2.1% of the <em>SRAM</em></li>
</ul>
<h4 id="bss-memory-section"><code>.bss</code> memory section</h4>
<ul>
<li>uninitialized globals</li>
<li>uninitialized static variables</li>
</ul>
<h4 id="dec-memory-section"><code>.dec</code> memory section</h4>
<ul>
<li>this is just the sum of the other three sections
<ul>
<li><code>.data</code>: 34</li>
<li><code>.text</code>: 730</li>
<li><code>.bss</code> : 7</li>
<li>total: <strong>771</strong></li>
</ul></li>
<li><code>dec</code> stands for decimal</li>
<li><code>hex</code> is the same total represented in base 16</li>
</ul>
<h2 id="cable-connections-and-switch-settings">Cable connections and switch settings</h2>
<ul>
<li>Power <code>simBrd</code> from hostPC with mini-B USB cable.</li>
<li>Power ATMEL-ICE from hostPC with micro-B USB cable.</li>
<li>Connect ATMEL-ICE to <code>simBrd</code> by connecting the 10-pin ribbon cable to the AVR port on the Atmel-ICE, and the 6-pin keyed female socket end of the 10-pin ribbon cable to the male shrouded header on the PCB.</li>
<li>Set simBrd <code>SW2</code> to <code>ISP</code>
<ul>
<li>program the <code>simBrd</code>: <code>SW1</code> to <code>M.ISP</code>
<ul>
<li><strong>pneumonic</strong>: <em>M for SPI Master</em></li>
</ul></li>
<li>program the <code>mBrd</code>: <code>SW1</code> to <code>S.ISP</code>
<ul>
<li><strong>pneumonic</strong>: <em>S for SPI Slave</em></li>
</ul></li>
</ul></li>
<li>Before invoking <code>;mfa</code> or <code>;fa</code> <em>make sure the <code>pwd</code> is correct</em>:</li>
</ul>
<pre class="vim"><code>:pwd</code></pre>
<ul>
<li>Switch to the <code>simBrd</code> directory before programming the <code>simBrd</code>:</li>
</ul>
<pre class="vim"><code>:cd ../simBrd</code></pre>
<ul>
<li>Switch to the <code>mBrd</code> directory before programming the <code>mBrd</code>:</li>
</ul>
<pre class="vim"><code>:cd ../mBrd</code></pre>
<h2 id="verify-programming-communication-link">Verify programming communication link</h2>
<h3 id="correct-output">Correct output</h3>
<ul>
<li>Expect device signature: <code>0x1E950F</code></li>
<li>Expect fuse settings: <code>EXTENDED 0xFF, HIGH 0xD9, LOW 0xF7</code></li>
</ul>
<h3 id="do-not-invoke-from-command-line">Do not invoke from command line</h3>
<ul>
<li>you can invoke from PowerShell like this:</li>
</ul>
<pre><code>PS&gt; atprogram -t atmelice -i isp -d atmega328p info</code></pre>
<ul>
<li>invoke from Vim instead with the <code>;mkp</code> shortcut</li>
</ul>
<h3 id="invoke-from-vim">Invoke from Vim</h3>
<ul>
<li><code>cd</code> to directory that has the <code>Makefile</code> with the <code>avr</code> targets</li>
</ul>
<pre class="vim"><code>;mkp</code></pre>
<h2 id="do-not-manually-program-flash-from-the-command-line">Do not manually program flash from the command line</h2>
<ul>
<li>don’t bother, use <code>make</code> instead ### Verify a file is loaded from the command line</li>
<li>TODO: make a Vim shortcut for this</li>
<li>From PowerShell:
<ul>
<li>Copy the full path to the source.elf to the clipboard.</li>
<li>Create a variable:</li>
</ul>
<pre><code>PS&gt; $source = {paste-path-to-source.elf}
PS&gt; atprogram -t atmelice -i isp -d atmega328p verify -fl -f $source</code></pre></li>
</ul>
<h2 id="programming-flash-with-make">Programming flash with <code>make</code></h2>
<ul>
<li>each sub-folder in <code>LIS-770i</code> has a <code>Makefile</code>
<ul>
<li><code>lib</code></li>
<li><code>mBrd</code></li>
<li><code>simBrd</code></li>
</ul></li>
<li><code>cd</code> to the directory with the right <code>Makefile</code>
<ul>
<li>the <code>Makefile</code> in <code>simBrd</code> and <code>mBrd</code> has <em>avr targets</em></li>
<li>these are invoked by the following shortcuts
<ul>
<li><code>;mkp</code> - query device</li>
<li><code>;mkv</code> - measure voltage</li>
<li><code>;mna</code> - show build recipe</li>
<li><code>;mka</code> - build</li>
<li><code>;fa</code> - download flash</li>
<li><code>;mfa</code> - build and download flash</li>
<li><code>;f-Space</code> - close log windows</li>
</ul></li>
<li>most are safe, but downloading flash with <code>;fa</code> will program the wrong .elf file if the <em>pwd</em> is the wrong sub-folder</li>
<li>the <code>Makefile</code> in <code>lib</code> does not have <em>avr targets</em>
<ul>
<li>it is safe to accidentally be in this folder</li>
<li>this results in messages like this:</li>
</ul>
<pre class="make"><code>(1 of 1): make: *** No rule to make target &#39;test_programmer_is_connected&#39;.  Stop.</code></pre>
<h3 id="diagnostics">Diagnostics</h3>
<h4 id="mkp-returns-mcu-device-signature-and-fuse-settings">;mkp returns MCU device signature and fuse settings</h4></li>
</ul></li>
<li>Expect device signature: <code>0x1E950F</code></li>
<li>Expect fuse settings: <code>EXTENDED 0xFF, HIGH 0xD9, LOW 0xF7</code></li>
</ul>
<pre class="vim"><code>nnoremap &lt;leader&gt;mkp :make test_programmer_is_connected&lt;CR&gt;</code></pre>
<ul>
<li><code>test_programmer_is_connected</code> is a target defined in the <code>Makefile</code>:</li>
<li>=====[ <code>LIS-770i/simBrd/Makefile</code> ]=====</li>
</ul>
<pre class="make"><code>.PHONY: test_programmer_is_connected
test_programmer_is_connected:
    atprogram.exe --tool atmelice --interface isp --device atmega328p info</code></pre>
<h4 id="mkv-returns-the-target-voltage">;mkv returns the target voltage</h4>
<ul>
<li>Expect <code>2.94V</code></li>
</ul>
<pre class="vim"><code>nnoremap &lt;leader&gt;mkv :make display_target_voltage&lt;CR&gt;</code></pre>
<ul>
<li><code>display_target_voltage</code> is a target defined in the <code>Makefile</code>:</li>
<li>=====[ <code>LIS-770i/simBrd/Makefile</code> ]=====</li>
</ul>
<pre class="make"><code>.PHONY: display_target_voltage
display_target_voltage:
    atprogram.exe --tool atmelice --interface isp --device atmega328p parameters --voltage</code></pre>
<h3 id="build-and-download">Build and Download</h3>
<h4 id="mna-returns-the-.elf-build-recipe-with-variables-substituted">;mna returns the .elf build recipe with variables substituted</h4>
<pre class="vim"><code>nnoremap &lt;leader&gt;mna :make avr-target compiler=avr-gcc -n&lt;CR&gt;</code></pre>
<h4 id="mka-builds-the-.elf">;mka builds the .elf</h4>
<pre class="vim"><code>nnoremap &lt;leader&gt;mka :call CloseTestResults()&lt;CR&gt;
            \:make avr-target compiler=avr-gcc&lt;CR&gt;&lt;CR&gt;&lt;CR&gt;
            \:call MakeQuickfix()&lt;CR&gt;</code></pre>
<h4 id="fa-programs-the-flash">;fa programs the flash</h4>
<ul>
<li><code>;fa</code> to download flash</li>
</ul>
<pre class="vim"><code>nnoremap &lt;leader&gt;fa :call DownloadFlash()&lt;CR&gt;
function! DownloadFlash()
    execute &quot;make download_flash&quot;
endfunction</code></pre>
<h4 id="mfa-builds-and-programs-the-flash">;mfa builds and programs the flash</h4>
<ul>
<li><code>;mfa</code> to build for the MCU and download flash</li>
<li>there is something wrong with this Vim script
<ul>
<li>the first time I ran it I just saw a bunch of errors</li>
<li>the second time I ran it it erased my entire README.md file!</li>
<li>the trouble must have been here:</li>
</ul>
<pre class="vim"><code>call MakeQuickfixAndDownloadFlash</code></pre></li>
<li>but the important stuff works</li>
</ul>
<pre class="vim"><code>nnoremap &lt;leader&gt;mfa :call CloseLogfileWindows()&lt;CR&gt;
            \:make avr-target compiler=avr-gcc&lt;CR&gt;&lt;CR&gt;&lt;CR&gt;
            \:call MakeQuickfixAndDownloadFlash()&lt;CR&gt;&lt;CR&gt;</code></pre>
<h4 id="f-space-closes-any-open-atprogram-log-windows-and-quickfix-window">;f-Space closes any open atprogram log windows and quickfix window</h4>
<ul>
<li>I rewrote this Vim script while fixing <code>;mfa</code></li>
<li>it is completely safe</li>
<li>invoke it from any window</li>
<li>as long as the <em>pwd</em> is correct, it does its job</li>
<li>otherwise, it does nothing</li>
</ul>
<h2 id="look-at-the-disassembly-instructions">Look at the disassembly instructions</h2>
<h3 id="read-the-.lst-file">read the .lst file</h3>
<ul>
<li>the disassembly file has extension <code>.lst</code></li>
<li><p>[x] learn to read the .lst file</p></li>
<li>all of the instructions are listed in the datasheet</li>
<li><p>I pulled out a handful below that are used in the <code>.lst</code> snippets I attempt to translate</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th>instr</th>
<th>Operand</th>
<th>Operation</th>
<th>Flags</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ADD</td>
<td>Rd, Rr</td>
<td>Rd←Rd+Rr</td>
<td>Z,C,N,V,H</td>
<td>Add two Registers</td>
</tr>
<tr class="even">
<td>BRPL</td>
<td>k</td>
<td>if(N=0), PC←PC+k+1</td>
<td>None</td>
<td>Branch if Plus</td>
</tr>
<tr class="odd">
<td>CALL</td>
<td>k</td>
<td>PC←k</td>
<td>None</td>
<td>Direct Subroutine Call</td>
</tr>
<tr class="even">
<td>DEC</td>
<td>Rd</td>
<td>Rd←Rd-1</td>
<td>Z,N,V</td>
<td>Decrement</td>
</tr>
<tr class="odd">
<td>ICALL</td>
<td></td>
<td></td>
<td>None</td>
<td>Indirect Call to (Z)</td>
</tr>
<tr class="even">
<td>LD</td>
<td>Rd, Z</td>
<td>Rd←(Z)</td>
<td>None</td>
<td>Load Indirect</td>
</tr>
<tr class="odd">
<td>LDI</td>
<td>Rd, K</td>
<td>Rd←K</td>
<td>None</td>
<td>Load Immediate</td>
</tr>
<tr class="even">
<td>LDS</td>
<td>Rd, k</td>
<td>Rd←(k)</td>
<td>None</td>
<td>Load Direct from SRAM</td>
</tr>
<tr class="odd">
<td>MOVW</td>
<td>Rd, Rr</td>
<td>Rd+1:Rd←Rr+1:Rr</td>
<td>None</td>
<td>Copy Register Word</td>
</tr>
<tr class="even">
<td>PUSH</td>
<td>Rr</td>
<td>STACK←Rr</td>
<td>None</td>
<td>Push Register on Stack</td>
</tr>
<tr class="odd">
<td>RET</td>
<td></td>
<td>PC←STACK</td>
<td>None</td>
<td>Subroutine Return</td>
</tr>
<tr class="even">
<td>RJMP</td>
<td>k</td>
<td>PC←PC+k+1</td>
<td>None</td>
<td>Relative Jump</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb108"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb108-1" title="1">000000f0 &lt;DebugLedTurnOn_Implementation&gt;:</a>
<a class="sourceLine" id="cb108-2" title="2">    DebugLedTurnGreen();</a>
<a class="sourceLine" id="cb108-3" title="3">}</a>
<a class="sourceLine" id="cb108-4" title="4"></a>
<a class="sourceLine" id="cb108-5" title="5"><span class="dt">static</span> <span class="dt">void</span> DebugLedTurnOn_Implementation(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb108-6" title="6">{</a>
<a class="sourceLine" id="cb108-7" title="7">    SetBit(ddr_register_, debug_led_);</a>
<a class="sourceLine" id="cb108-8" title="8">  f0:   <span class="dv">60</span> <span class="dv">91</span> <span class="dv">32</span> <span class="dv">01</span>     lds r22, <span class="bn">0x0132</span> ; <span class="bn">0x800132</span> &lt;__data_end&gt;</a>
<a class="sourceLine" id="cb108-9" title="9">  f4:   <span class="dv">80</span> <span class="dv">91</span> <span class="dv">37</span> <span class="dv">01</span>     lds r24, <span class="bn">0x0137</span> ; <span class="bn">0x800137</span> &lt;ddr_register_&gt;</a>
<a class="sourceLine" id="cb108-10" title="10">  f8:   <span class="dv">90</span> <span class="dv">91</span> <span class="dv">38</span> <span class="dv">01</span>     lds r25, <span class="bn">0x0138</span> ; <span class="bn">0x800138</span> &lt;ddr_register_+<span class="bn">0x1</span>&gt;</a>
<a class="sourceLine" id="cb108-11" title="11">  fc:   0e <span class="dv">94</span> <span class="dv">53</span> <span class="dv">00</span>     call    <span class="bn">0xa6</span>    ; <span class="bn">0xa6</span> &lt;SetBit&gt;</a>
<a class="sourceLine" id="cb108-12" title="12"> <span class="dv">100</span>:   <span class="dv">08</span> <span class="dv">95</span>           ret</a></code></pre></div>
<ul>
<li><code>0xf0</code> is the address of this function</li>
<li>this function just sets up a function call</li>
<li>the input arguments are stored in <code>SRAM</code></li>
<li>it loads these arguments from <code>SRAM</code> into some registers:
<ul>
<li>copy value from <code>SRAM</code> at address <code>0x0132</code> to <code>r22</code></li>
<li>copy value from <code>SRAM</code> at address <code>0x0137</code> to <code>r24</code></li>
<li>copy value from <code>SRAM</code> at address <code>0x0138</code> to <code>r25</code></li>
</ul></li>
<li>then it calls <code>SetBit</code>:
<ul>
<li><code>SetBit</code> is the subroutine at <code>PC</code> address <code>0xa6</code></li>
<li>load the <code>PC</code> with <code>0xa6</code></li>
<li>when the program counter returns here (address <code>0xfc</code>) the final step is to return from this function by popping the return address from the stack and loading the <code>PC</code> with that return address</li>
</ul></li>
<li>I don’t know where the assembly for <code>SetBit</code> is</li>
<li>this is all I could find:</li>
</ul>
<div class="sourceCode" id="cb109"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb109-1" title="1">000000a6 &lt;SetBit&gt;:</a>
<a class="sourceLine" id="cb109-2" title="2">    *port ^= (<span class="dv">1</span>&lt;&lt;bit);</a>
<a class="sourceLine" id="cb109-3" title="3">}</a></code></pre></div>
<div class="sourceCode" id="cb110"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb110-1" title="1"><span class="dt">bool</span> BitIsSet(<span class="dt">uint8_t</span> <span class="dt">volatile</span> * <span class="dt">const</span> port, <span class="dt">uint8_t</span> <span class="dt">const</span> bit) {</a>
<a class="sourceLine" id="cb110-2" title="2">    <span class="cf">return</span> *port &amp; (<span class="dv">1</span>&lt;&lt;bit);</a>
<a class="sourceLine" id="cb110-3" title="3">}</a>
<a class="sourceLine" id="cb110-4" title="4">  a6:   fc <span class="dv">01</span>           movw    r30, r24</a>
<a class="sourceLine" id="cb110-5" title="5">  a8:   <span class="dv">40</span> <span class="dv">81</span>           ld  r20, Z</a>
<a class="sourceLine" id="cb110-6" title="6">  aa:   <span class="dv">21</span> e0           ldi r18, <span class="bn">0x01</span>   ; <span class="dv">1</span></a>
<a class="sourceLine" id="cb110-7" title="7">  ac:   <span class="dv">30</span> e0           ldi r19, <span class="bn">0x00</span>   ; <span class="dv">0</span></a>
<a class="sourceLine" id="cb110-8" title="8">  ae:   <span class="dv">02</span> c0           rjmp    .+<span class="dv">4</span>         ; <span class="bn">0xb4</span> &lt;SetBit+<span class="bn">0xe</span>&gt;</a>
<a class="sourceLine" id="cb110-9" title="9">  b0:   <span class="dv">22</span> 0f           add r18, r18</a>
<a class="sourceLine" id="cb110-10" title="10">  b2:   <span class="dv">33</span> 1f           adc r19, r19</a>
<a class="sourceLine" id="cb110-11" title="11">  b4:   6a <span class="dv">95</span>           dec r22</a>
<a class="sourceLine" id="cb110-12" title="12">  b6:   e2 f7           brpl    .-<span class="dv">8</span>         ; <span class="bn">0xb0</span> &lt;SetBit+<span class="bn">0xa</span>&gt;</a>
<a class="sourceLine" id="cb110-13" title="13">  b8:   <span class="dv">24</span> 2b           or  r18, r20</a>
<a class="sourceLine" id="cb110-14" title="14">  ba:   <span class="dv">20</span> <span class="dv">83</span>           st  Z, r18</a>
<a class="sourceLine" id="cb110-15" title="15">  bc:   <span class="dv">08</span> <span class="dv">95</span>           ret</a></code></pre></div>
<ul>
<li>Here is the function in question, <code>UsbWrite</code>:</li>
</ul>
<div class="sourceCode" id="cb111"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb111-1" title="1">0000032a &lt;UsbWrite&gt;:</a>
<a class="sourceLine" id="cb111-2" title="2"><span class="dt">uint16_t</span> UsbWrite(<span class="dt">uint8_t</span> *write_buffer, <span class="dt">uint16_t</span> nbytes)</a>
<a class="sourceLine" id="cb111-3" title="3">{</a></code></pre></div>
<ul>
<li>this first part just makes space to work:
<ul>
<li>save the values in the registers by pushing them onto the stack:</li>
</ul>
<div class="sourceCode" id="cb112"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb112-1" title="1"> 32a:   ef <span class="dv">92</span>           push    r14</a>
<a class="sourceLine" id="cb112-2" title="2"> 32c:   ff <span class="dv">92</span>           push    r15</a>
<a class="sourceLine" id="cb112-3" title="3"> 32e:   0f <span class="dv">93</span>           push    r16</a>
<a class="sourceLine" id="cb112-4" title="4"> <span class="dv">330</span>:   1f <span class="dv">93</span>           push    r17</a>
<a class="sourceLine" id="cb112-5" title="5"> <span class="dv">332</span>:   cf <span class="dv">93</span>           push    r28</a>
<a class="sourceLine" id="cb112-6" title="6"> <span class="dv">334</span>:   df <span class="dv">93</span>           push    r29</a></code></pre></div></li>
<li>now copy the input arguments into the registers just freed up:</li>
</ul>
<div class="sourceCode" id="cb113"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb113-1" title="1"> <span class="dv">336</span>:   8c <span class="dv">01</span>           movw    r16, r24</a>
<a class="sourceLine" id="cb113-2" title="2"> <span class="dv">338</span>:   7b <span class="dv">01</span>           movw    r14, r22</a></code></pre></div>
<ul>
<li><code>FtSendCommand</code> is a function pointer:</li>
</ul>
<div class="sourceCode" id="cb114"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb114-1" title="1"><span class="dt">void</span> (*FtSendCommand)(<span class="dt">uint8_t</span>) = FtSendCommand_Implementation;</a></code></pre></div>
<ul>
<li>function pointers are treated differently from regular functions</li>
<li>compare <code>FtSendCommand</code> and <code>SetBit</code></li>
<li>it is not called like <code>SetBit</code></li>
<li><code>SetBit</code> is a <code>PC</code> address</li>
<li><code>SetBit</code> was called by loading the <code>PC</code> with that address</li>
<li>the address of <code>FtSendCommand</code> is stored in <code>SRAM</code></li>
<li><code>FtSendCommand</code> is called by loading a 16-bit address from <code>SRAM</code> into registers <code>r30</code> and <code>r31</code></li>
<li>these comprise the 16-bit <code>Z</code> register</li>
</ul>
<div class="sourceCode" id="cb115"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb115-1" title="1">    <span class="dt">uint16_t</span> num_bytes_sent = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb115-2" title="2">    FtSendCommand(FtCmd_Write);</a>
<a class="sourceLine" id="cb115-3" title="3"> 33a:   e0 <span class="dv">91</span> 1c <span class="dv">01</span>     lds r30, <span class="bn">0x011C</span> ; <span class="bn">0x80011c</span> &lt;FtSendCommand&gt;</a>
<a class="sourceLine" id="cb115-4" title="4"> 33e:   f0 <span class="dv">91</span> 1d <span class="dv">01</span>     lds r31, <span class="bn">0x011D</span> ; <span class="bn">0x80011d</span> &lt;FtSendCommand+<span class="bn">0x1</span>&gt;</a>
<a class="sourceLine" id="cb115-5" title="5"> <span class="dv">342</span>:   <span class="dv">80</span> <span class="dv">91</span> <span class="dv">24</span> <span class="dv">01</span>     lds r24, <span class="bn">0x0124</span> ; <span class="bn">0x800124</span> &lt;FtCmd_Write&gt;</a>
<a class="sourceLine" id="cb115-6" title="6"> <span class="dv">346</span>:   <span class="dv">09</span> <span class="dv">95</span>           icall</a>
<a class="sourceLine" id="cb115-7" title="7">    <span class="cf">if</span> (!FtBusTurnaround())</a>
<a class="sourceLine" id="cb115-8" title="8"> <span class="dv">348</span>:   e0 <span class="dv">91</span> 1a <span class="dv">01</span>     lds r30, <span class="bn">0x011A</span> ; <span class="bn">0x80011a</span> &lt;FtBusTurnaround&gt;</a>
<a class="sourceLine" id="cb115-9" title="9"> 34c:   f0 <span class="dv">91</span> 1b <span class="dv">01</span>     lds r31, <span class="bn">0x011B</span> ; <span class="bn">0x80011b</span> &lt;FtBusTurnaround+<span class="bn">0x1</span>&gt;</a>
<a class="sourceLine" id="cb115-10" title="10"> <span class="dv">350</span>:   <span class="dv">09</span> <span class="dv">95</span>           icall</a>
<a class="sourceLine" id="cb115-11" title="11"> <span class="dv">352</span>:   <span class="dv">81</span> <span class="dv">11</span>           cpse    r24, r1</a>
<a class="sourceLine" id="cb115-12" title="12"> <span class="dv">354</span>:   0d c0           rjmp    .+<span class="dv">26</span>        ; <span class="bn">0x370</span> &lt;UsbWrite+<span class="bn">0x46</span>&gt;</a>
<a class="sourceLine" id="cb115-13" title="13">    {</a>
<a class="sourceLine" id="cb115-14" title="14">        DebugLedTurnRedToShowError();</a>
<a class="sourceLine" id="cb115-15" title="15"> <span class="dv">356</span>:   e0 <span class="dv">91</span> <span class="dv">00</span> <span class="dv">01</span>     lds r30, <span class="bn">0x0100</span> ; <span class="bn">0x800100</span> &lt;DebugLedTurnRedToShowError&gt;</a>
<a class="sourceLine" id="cb115-16" title="16"> 35a:   f0 <span class="dv">91</span> <span class="dv">01</span> <span class="dv">01</span>     lds r31, <span class="bn">0x0101</span> ; <span class="bn">0x800101</span> &lt;DebugLedTurnRedToShowError+<span class="bn">0x1</span>&gt;</a>
<a class="sourceLine" id="cb115-17" title="17"> 35e:   <span class="dv">09</span> <span class="dv">95</span>           icall</a>
<a class="sourceLine" id="cb115-18" title="18">        FtDeactivateInterface();</a>
<a class="sourceLine" id="cb115-19" title="19"> <span class="dv">360</span>:   e0 <span class="dv">91</span> <span class="dv">14</span> <span class="dv">01</span>     lds r30, <span class="bn">0x0114</span> ; <span class="bn">0x800114</span> &lt;FtDeactivateInterface&gt;</a>
<a class="sourceLine" id="cb115-20" title="20"> <span class="dv">364</span>:   f0 <span class="dv">91</span> <span class="dv">15</span> <span class="dv">01</span>     lds r31, <span class="bn">0x0115</span> ; <span class="bn">0x800115</span> &lt;FtDeactivateInterface+<span class="bn">0x1</span>&gt;</a>
<a class="sourceLine" id="cb115-21" title="21"> <span class="dv">368</span>:   <span class="dv">09</span> <span class="dv">95</span>           icall</a>
<a class="sourceLine" id="cb115-22" title="22">        <span class="cf">return</span> num_bytes_sent;</a>
<a class="sourceLine" id="cb115-23" title="23"> 36a:   c0 e0           ldi r28, <span class="bn">0x00</span>   ; <span class="dv">0</span></a>
<a class="sourceLine" id="cb115-24" title="24"> 36c:   d0 e0           ldi r29, <span class="bn">0x00</span>   ; <span class="dv">0</span></a>
<a class="sourceLine" id="cb115-25" title="25"> 36e:   <span class="dv">15</span> c0           rjmp    .+<span class="dv">42</span>        ; <span class="bn">0x39a</span> &lt;UsbWrite+<span class="bn">0x70</span>&gt;</a>
<a class="sourceLine" id="cb115-26" title="26"> <span class="dv">370</span>:   c0 e0           ldi r28, <span class="bn">0x00</span>   ; <span class="dv">0</span></a>
<a class="sourceLine" id="cb115-27" title="27"> <span class="dv">372</span>:   d0 e0           ldi r29, <span class="bn">0x00</span>   ; <span class="dv">0</span></a>
<a class="sourceLine" id="cb115-28" title="28">    }</a>
<a class="sourceLine" id="cb115-29" title="29">    <span class="co">// </span><span class="al">TODO</span><span class="co">: rename `byte_sent` as `byte_sent_OK` or `byte_was_sent`</span></a>
<a class="sourceLine" id="cb115-30" title="30">    <span class="dt">bool</span> byte_sent = true; <span class="dt">bool</span> finished = false;</a></code></pre></div>
<ul>
<li>This is where the value is copied.</li>
<li><code>r16</code> is the input argument: the address of <code>write_buffer</code></li>
<li>so look at <code>FtWrite</code>, not <code>UsbWrite</code></li>
</ul>
<div class="sourceCode" id="cb116"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb116-1" title="1">    <span class="cf">while</span> (byte_sent &amp;&amp; !finished)</a>
<a class="sourceLine" id="cb116-2" title="2">    {</a>
<a class="sourceLine" id="cb116-3" title="3">        byte_sent = FtWrite(write_buffer++);</a>
<a class="sourceLine" id="cb116-4" title="4"> <span class="dv">374</span>:   e0 <span class="dv">91</span> <span class="dv">18</span> <span class="dv">01</span>     lds r30, <span class="bn">0x0118</span> ; <span class="bn">0x800118</span> &lt;FtWrite&gt;</a>
<a class="sourceLine" id="cb116-5" title="5"> <span class="dv">378</span>:   f0 <span class="dv">91</span> <span class="dv">19</span> <span class="dv">01</span>     lds r31, <span class="bn">0x0119</span> ; <span class="bn">0x800119</span> &lt;FtWrite+<span class="bn">0x1</span>&gt;</a>
<a class="sourceLine" id="cb116-6" title="6"> 37c:   c8 <span class="dv">01</span>           movw    r24, r16</a>
<a class="sourceLine" id="cb116-7" title="7"> 37e:   8c 0f           add r24, r28</a>
<a class="sourceLine" id="cb116-8" title="8"> <span class="dv">380</span>:   9d 1f           adc r25, r29</a>
<a class="sourceLine" id="cb116-9" title="9"> <span class="dv">382</span>:   <span class="dv">09</span> <span class="dv">95</span>           icall</a>
<a class="sourceLine" id="cb116-10" title="10">        <span class="cf">if</span> (byte_sent) num_bytes_sent++;</a>
<a class="sourceLine" id="cb116-11" title="11"> <span class="dv">384</span>:   <span class="dv">88</span> <span class="dv">23</span>           and r24, r24</a>
<a class="sourceLine" id="cb116-12" title="12"> <span class="dv">386</span>:   <span class="dv">21</span> f0           breq    .+<span class="dv">8</span>         ; <span class="bn">0x390</span> &lt;UsbWrite+<span class="bn">0x66</span>&gt;</a>
<a class="sourceLine" id="cb116-13" title="13"> <span class="dv">388</span>:   <span class="dv">21</span> <span class="dv">96</span>           adiw    r28, <span class="bn">0x01</span>   ; <span class="dv">1</span></a>
<a class="sourceLine" id="cb116-14" title="14">        FtDeactivateInterface();</a>
<a class="sourceLine" id="cb116-15" title="15">        <span class="cf">return</span> num_bytes_sent;</a>
<a class="sourceLine" id="cb116-16" title="16">    }</a>
<a class="sourceLine" id="cb116-17" title="17">    <span class="co">// </span><span class="al">TODO</span><span class="co">: rename `byte_sent` as `byte_sent_OK` or `byte_was_sent`</span></a>
<a class="sourceLine" id="cb116-18" title="18">    <span class="dt">bool</span> byte_sent = true; <span class="dt">bool</span> finished = false;</a>
<a class="sourceLine" id="cb116-19" title="19">    <span class="cf">while</span> (byte_sent &amp;&amp; !finished)</a>
<a class="sourceLine" id="cb116-20" title="20"> 38a:   ce <span class="dv">15</span>           cp  r28, r14</a>
<a class="sourceLine" id="cb116-21" title="21"> 38c:   df <span class="dv">05</span>           cpc r29, r15</a>
<a class="sourceLine" id="cb116-22" title="22"> 38e:   <span class="dv">90</span> f3           brcs    .-<span class="dv">28</span>        ; <span class="bn">0x374</span> &lt;UsbWrite+<span class="bn">0x4a</span>&gt;</a>
<a class="sourceLine" id="cb116-23" title="23">    {</a>
<a class="sourceLine" id="cb116-24" title="24">        byte_sent = FtWrite(write_buffer++);</a>
<a class="sourceLine" id="cb116-25" title="25">        <span class="cf">if</span> (byte_sent) num_bytes_sent++;</a>
<a class="sourceLine" id="cb116-26" title="26">        finished = (num_bytes_sent &gt;= nbytes);</a>
<a class="sourceLine" id="cb116-27" title="27">    }</a>
<a class="sourceLine" id="cb116-28" title="28">    FtDeactivateInterface();</a>
<a class="sourceLine" id="cb116-29" title="29"> <span class="dv">390</span>:   e0 <span class="dv">91</span> <span class="dv">14</span> <span class="dv">01</span>     lds r30, <span class="bn">0x0114</span> ; <span class="bn">0x800114</span> &lt;FtDeactivateInterface&gt;</a>
<a class="sourceLine" id="cb116-30" title="30"> <span class="dv">394</span>:   f0 <span class="dv">91</span> <span class="dv">15</span> <span class="dv">01</span>     lds r31, <span class="bn">0x0115</span> ; <span class="bn">0x800115</span> &lt;FtDeactivateInterface+<span class="bn">0x1</span>&gt;</a>
<a class="sourceLine" id="cb116-31" title="31"> <span class="dv">398</span>:   <span class="dv">09</span> <span class="dv">95</span>           icall</a>
<a class="sourceLine" id="cb116-32" title="32">    <span class="cf">return</span> num_bytes_sent;</a>
<a class="sourceLine" id="cb116-33" title="33">}</a>
<a class="sourceLine" id="cb116-34" title="34"> 39a:   ce <span class="dv">01</span>           movw    r24, r28</a>
<a class="sourceLine" id="cb116-35" title="35"> 39c:   df <span class="dv">91</span>           pop r29</a>
<a class="sourceLine" id="cb116-36" title="36"> 39e:   cf <span class="dv">91</span>           pop r28</a>
<a class="sourceLine" id="cb116-37" title="37"> 3a0:   1f <span class="dv">91</span>           pop r17</a>
<a class="sourceLine" id="cb116-38" title="38"> 3a2:   0f <span class="dv">91</span>           pop r16</a>
<a class="sourceLine" id="cb116-39" title="39"> 3a4:   ff <span class="dv">90</span>           pop r15</a>
<a class="sourceLine" id="cb116-40" title="40"> 3a6:   ef <span class="dv">90</span>           pop r14</a>
<a class="sourceLine" id="cb116-41" title="41"> 3a8:   <span class="dv">08</span> <span class="dv">95</span>           ret</a></code></pre></div>
<ul>
<li>looking at <code>FtWrite</code>:</li>
</ul>
<div class="sourceCode" id="cb117"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb117-1" title="1"><span class="dt">bool</span> (*FtWrite)(<span class="dt">uint8_t</span> *write_buffer) = FtWrite_Implementation;</a></code></pre></div>
<ul>
<li>the dissasembly for <code>FtWrite_Implementation</code>:</li>
</ul>
<div class="sourceCode" id="cb118"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb118-1" title="1">000001be &lt;FtWrite_Implementation&gt;:</a>
<a class="sourceLine" id="cb118-2" title="2"> 1be:   cf <span class="dv">93</span>           push    r28</a>
<a class="sourceLine" id="cb118-3" title="3"> 1c0:   df <span class="dv">93</span>           push    r29</a>
<a class="sourceLine" id="cb118-4" title="4"> 1c2:   ec <span class="dv">01</span>           movw    r28, r24</a>
<a class="sourceLine" id="cb118-5" title="5"> 1c4:   e0 <span class="dv">91</span> <span class="dv">12</span> <span class="dv">01</span>     lds r30, <span class="bn">0x0112</span> ; <span class="bn">0x800112</span> &lt;FtPushData&gt;</a>
<a class="sourceLine" id="cb118-6" title="6"> 1c8:   f0 <span class="dv">91</span> <span class="dv">13</span> <span class="dv">01</span>     lds r31, <span class="bn">0x0113</span> ; <span class="bn">0x800113</span> &lt;FtPushData+<span class="bn">0x1</span>&gt;</a>
<a class="sourceLine" id="cb118-7" title="7"> 1cc:   <span class="dv">09</span> <span class="dv">95</span>           icall</a>
<a class="sourceLine" id="cb118-8" title="8"> 1ce:   e0 <span class="dv">91</span> <span class="dv">06</span> <span class="dv">01</span>     lds r30, <span class="bn">0x0106</span> ; <span class="bn">0x800106</span> &lt;FtWriteData&gt;</a>
<a class="sourceLine" id="cb118-9" title="9"> 1d2:   f0 <span class="dv">91</span> <span class="dv">07</span> <span class="dv">01</span>     lds r31, <span class="bn">0x0107</span> ; <span class="bn">0x800107</span> &lt;FtWriteData+<span class="bn">0x1</span>&gt;</a></code></pre></div>
<ul>
<li>here is where the value of the byte in the <code>write_buffer</code> gets passed to <code>FtWriteData</code>:</li>
</ul>
<div class="sourceCode" id="cb119"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb119-1" title="1"> 1d6:   <span class="dv">88</span> <span class="dv">81</span>           ld  r24, Y</a>
<a class="sourceLine" id="cb119-2" title="2"> 1d8:   <span class="dv">09</span> <span class="dv">95</span>           icall</a></code></pre></div>
<ul>
<li>what is register <code>Y</code>?</li>
<li><code>YL</code> is <code>r28</code>, <code>YH</code> is <code>r29</code></li>
<li>the input argument, the pointer <code>write_buffer</code>, is in <code>r24</code></li>
<li>so copy this to <code>r28</code></li>
<li>but how could the pointer, which is an address, fit is <code>r24</code>?</li>
</ul>
<div class="sourceCode" id="cb120"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb120-1" title="1"> 1da:   e0 <span class="dv">91</span> 0e <span class="dv">01</span>     lds r30, <span class="bn">0x010E</span> ; <span class="bn">0x80010e</span> &lt;FtPullData&gt;</a>
<a class="sourceLine" id="cb120-2" title="2"> 1de:   f0 <span class="dv">91</span> 0f <span class="dv">01</span>     lds r31, <span class="bn">0x010F</span> ; <span class="bn">0x80010f</span> &lt;FtPullData+<span class="bn">0x1</span>&gt;</a>
<a class="sourceLine" id="cb120-3" title="3"> <span class="fl">1e2</span>:   <span class="dv">09</span> <span class="dv">95</span>           icall</a>
<a class="sourceLine" id="cb120-4" title="4"> <span class="fl">1e4</span>:   e0 <span class="dv">91</span> <span class="dv">08</span> <span class="dv">01</span>     lds r30, <span class="bn">0x0108</span> ; <span class="bn">0x800108</span> &lt;FtIsBusOk&gt;</a>
<a class="sourceLine" id="cb120-5" title="5"> <span class="fl">1e8</span>:   f0 <span class="dv">91</span> <span class="dv">09</span> <span class="dv">01</span>     lds r31, <span class="bn">0x0109</span> ; <span class="bn">0x800109</span> &lt;FtIsBusOk+<span class="bn">0x1</span>&gt;</a>
<a class="sourceLine" id="cb120-6" title="6"> 1ec:   <span class="dv">09</span> <span class="dv">95</span>           icall</a>
<a class="sourceLine" id="cb120-7" title="7"> 1ee:   df <span class="dv">91</span>           pop r29</a>
<a class="sourceLine" id="cb120-8" title="8"> 1f0:   cf <span class="dv">91</span>           pop r28</a>
<a class="sourceLine" id="cb120-9" title="9"> 1f2:   <span class="dv">08</span> <span class="dv">95</span>           ret</a></code></pre></div>
<h3 id="view-disassembly-in-gdb">view disassembly in <code>gdb</code></h3>
<ul>
<li><code>gdb</code> will not run .elf files, so this is <em>not useful</em> for figuring out how <code>avr-gcc</code> is turning C into assembly instructions</li>
<li>[-] view the disassembly from gcc using the <code>gdb</code> command <code>layout</code>:</li>
</ul>
<div class="sourceCode" id="cb121"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb121-1" title="1"><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="bu">help</span> layout</a>
<a class="sourceLine" id="cb121-2" title="2"><span class="ex">Change</span> the layout of windows.</a>
<a class="sourceLine" id="cb121-3" title="3"><span class="ex">Usage</span>: layout prev <span class="kw">|</span> <span class="ex">next</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">layout_name</span><span class="op">&gt;</span> </a>
<a class="sourceLine" id="cb121-4" title="4"><span class="ex">Layout</span> names are:</a>
<a class="sourceLine" id="cb121-5" title="5">   <span class="ex">src</span>   : Displays source and command windows.</a>
<a class="sourceLine" id="cb121-6" title="6">   <span class="ex">asm</span>   : Displays disassembly and command windows.</a>
<a class="sourceLine" id="cb121-7" title="7">   <span class="fu">split</span> : Displays source, disassembly and command windows.</a>
<a class="sourceLine" id="cb121-8" title="8">   <span class="ex">regs</span>  : Displays register window. If existing layout</a>
<a class="sourceLine" id="cb121-9" title="9">           <span class="ex">is</span> source/command or assembly/command, the </a>
<a class="sourceLine" id="cb121-10" title="10">           <span class="ex">register</span> window is displayed. If the</a>
<a class="sourceLine" id="cb121-11" title="11">           <span class="ex">source/assembly/command</span> (split) <span class="ex">is</span> displayed, </a>
<a class="sourceLine" id="cb121-12" title="12">           <span class="ex">the</span> register window is displayed with </a>
<a class="sourceLine" id="cb121-13" title="13">           <span class="ex">the</span> window that has current logical focus.</a></code></pre></div>
<p>Use <code>layout split</code> to view source and assembly at the same time. Use the up/down arrow keys to move through the source code. The source and assembly windows stay in sync. Adding a breakpoint places a <code>b+</code> next to the line number for both the source and assembly windows.</p>
<h1 id="usb-host-application">USB Host Application</h1>
<h2 id="new-python-application">New Python application</h2>
<p>Moving forward, the USB Host is a Python 3 application.</p>
<p>See work here: <code>/cygdrive/c/chromation-dropbox/Dropbox/sales/spect-py3-examples/</code></p>
<p>Clean these notes: - Python 3 <code>pyserial</code> works - my error in the past was because I did not know how byte arrays worked in Python 3, nothing to do with <code>pyserial</code> - see short snippets here: <a href="https://www.mkyong.com/python/python-3-convert-string-to-bytes/" class="uri">https://www.mkyong.com/python/python-3-convert-string-to-bytes/</a> - D2XX calls still work with <code>Load VCP</code> enabled - that means people have a choice - and the right choice on Python is <code>Load VCP</code> because: - <code>pyserial</code> does not have a d2xx api - the serial commands work just as well - whatever you need to do in D2XX you can do treating the device as a generic COM Port - I can leave my LabVIEW code using the D2XX API and use VCP when programming in Python with <code>pyserial</code> - <code>Load VCP</code> cannot access all the USB Description Strings that D2XX can access - <code>Product Description</code> is not visible - <code>Manufacturer</code> is not visible - but <code>Serial Number</code> is visible - There is a COM port variable named <code>manufacturer</code> but this actually comes from the <code>.inf</code> file installed with the USB driver - FTDI wants you to change this - this doc shows where the fields are in <code>FT_Prog</code>: <a href="https://www.ftdichip.com/Support/Documents/AppNotes/AN_124_User_Guide_For_FT_PROG.pdf" class="uri">https://www.ftdichip.com/Support/Documents/AppNotes/AN_124_User_Guide_For_FT_PROG.pdf</a> - this doc explains what you’re supposed to change: <a href="https://www.ftdichip.com/Support/Documents/TechnicalNotes/TN_102_OEM_Technical_Support_Requirements_for_FTDI_Products.pdf" class="uri">https://www.ftdichip.com/Support/Documents/TechnicalNotes/TN_102_OEM_Technical_Support_Requirements_for_FTDI_Products.pdf</a> - but this would void the security certificate:</p>
<pre><code>    &gt; It is important to note that the device drivers in this example are
    &gt; shown in Figures 2 and 3 as “Not digitally signed”. Any time there are
    &gt; edits performed on any of the device driver files, it will invalidate
    &gt; the WHQL signature. Re-certification by the OEM is possible. Refer to
    &gt; the AN_101_WHQL_Certified_Driver_Process(FT_000063).

    - and that would sketch out customers
    - and since no one gives a fuck anyway, just leave it as is
    - `manufacturer` shows up as FTDI, not a big deal
    - this is just `eval kit hardware` -- if it *were* a consumer product,
      then we&#39;d want to change this and do it right, paying for the security
      certificate mojo:
        &lt;https://www.ftdichip.com/Support/Documents/AppNotes/AN_101_Submitting_Modified_FTDI_Drivers_for_Windows_Hardware_Certification.pdf&gt;
- I leave the `Product Description` as-is so that my LabVIEW code does not
  have to change: it still gets `ChromationSpect-0643-01`
- but now I put CHROMATION123456 in FTDI `serial_number`
- when `pyserial` scans the USB ports, it can `grep` (awesome!) for the
  serial number and return a `port` object
- I can tell that `port` object to open up without ever having to use the
  `COM` string explicitly
- this *should* make the find-and-open code cross-platform
- other change in `FT_Prog` is the manufacturer
- change manufacturer from `FTDI` to `CH`
    - does not impact `Load VCP` users, e.g., what you can see from
      `pyserial`
    - does not impact my LabVIEW code since I never look at the manufacturer
      field
    - but it helps with the 44 character limit:
    - Product Description + manufacturer + serial number cannot exceed 44
      characters
    - serial number is supposed to be 16 characters</code></pre>
<p>CHROMATION123456 - very happy with script examples</p>
<pre><code>- serial commands are encapsulated in functions
- functions are all very short thanks to generators and list comprehensions
- even the final plotting code is relatively short, as plotting code goes</code></pre>
<ul>
<li>up until 3AM figuring out a snappy live updating matplotlib
<ul>
<li>snag here with globals to revisit later</li>
</ul></li>
</ul>
<h2 id="lissweep">LisSweep</h2>
<ul>
<li>send this command to get a frame of data:</li>
<li><code>cmd_send_lis_frame</code></li>
<li>this is defined as 0x01 in <code>Spi-Commands.h</code> in the <code>mBrd/src</code></li>
</ul>
<h2 id="eval-kit-example-python-interface">2017 eval kit <code>Example Python Interface</code></h2>
<h3 id="use-legacy-python-environment">Use legacy Python environment</h3>
<ul>
<li>the <code>s.write()</code> calls in this example code requires my legacy Python environment:
<ul>
<li>Python2.7</li>
<li>OS: Windows</li>
</ul></li>
<li>invoke this legacy Python environment from PowerShell:</li>
</ul>
<div class="sourceCode" id="cb124"><pre class="sourceCode powershell"><code class="sourceCode powershell"><a class="sourceLine" id="cb124-1" title="1"><span class="fu">PS</span>&gt; &amp;<span class="va">$python2_os_Windows</span></a></code></pre></div>
<h3 id="needs-py27-to-write-unicode">needs py27 to write unicode</h3>
<ul>
<li>this calls <code>python.exe</code> in my Windows installation of <code>py27</code>: &gt; <code>C:\Anaconda3\envs\py27\python.exe</code></li>
<li>all other calls work as expected on <code>py3</code> on Windows</li>
</ul>
<h3 id="needs-windows-to-acces-the-com-port">needs Windows to acces the <code>COM</code> port</h3>
<ul>
<li><code>Windows</code> is required to use the <code>COM</code> port to identify the serial port.</li>
<li>a <code>POSIX</code> OS complains that <code>COM</code> is not a file or directory</li>
<li>here is the error when attempting to open <code>Cygwin</code> (a POSIX OS) &gt; File “/usr/lib/python3.6/site-packages/serial/serialposix.py”, line 268, in &gt; open</li>
</ul>
<div class="sourceCode" id="cb125"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb125-1" title="1"><span class="cf">raise</span> SerialException(</a>
<a class="sourceLine" id="cb125-2" title="2">    msg.errno,</a>
<a class="sourceLine" id="cb125-3" title="3">    <span class="st">&quot;could not open port </span><span class="sc">{}</span><span class="st">: </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="va">self</span>._port, msg)</a>
<a class="sourceLine" id="cb125-4" title="4">    )</a></code></pre></div>
<blockquote>
<p>serial.serialutil.SerialException: [Errno 2] could not open port COM6: [Errno 2] no such file or directory: ‘COM6’</p>
</blockquote>
<h3 id="configure-the-ft221xa-for-vcp">Configure the FT221XA for VCP</h3>
<ul>
<li>set the FT221XA to use the COM port:
<ul>
<li>run <code>Device Manager</code></li>
<li>Find <code>Usb Serial Converter</code></li>
<li>right-clik, select <code>Properties</code></li>
<li>click on the <code>Advanced</code> tab</li>
<li>check the box <code>Load VCP</code></li>
<li>this uses <code>VCP</code> instead of <code>D2XX</code></li>
</ul></li>
</ul>
<h3 id="run-at-the-python-repl">Run at the Python REPL</h3>
<ul>
<li>copy the following Python lines into the clipboard with Vim:
<ul>
<li><code>V</code> to select by line, highlight all lines</li>
<li><code>"+y</code> yank into the clipboard</li>
</ul></li>
<li>I added <code>^M</code> to the end of each line of script
<ul>
<li>when this is pasted into the <em>Python REPL</em> it behaves as if pressing <code>&lt;CR&gt;</code> at the end of the line</li>
<li>I added these <code>&lt;CR&gt;</code> keypresses in Vim using <code>i_Ctrl-B&lt;CR&gt;</code></li>
</ul></li>
<li>paste into the <em>Python REPL</em> in <em>PowerShell</em> with <code>Alt-Space e p</code></li>
</ul>
<h4 id="open-serial-port">open serial port</h4>
<div class="sourceCode" id="cb126"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb126-1" title="1"><span class="im">import</span> serial</a>
<a class="sourceLine" id="cb126-2" title="2">s<span class="op">=</span>serial.Serial()</a>
<a class="sourceLine" id="cb126-3" title="3">s.baudrate <span class="op">=</span> <span class="dv">9600</span></a>
<a class="sourceLine" id="cb126-4" title="4">s.port <span class="op">=</span> <span class="st">&#39;COM12&#39;</span></a>
<a class="sourceLine" id="cb126-5" title="5">s.<span class="bu">open</span>()</a></code></pre></div>
<ul>
<li>note that <code>pyserial</code> has improved handling of Windows port names since the last time someone used the Chromation <code>Example Python Interface</code>
<ul>
<li><code>port</code> takes the Windows <code>COM</code> port number as a string</li>
<li><code>port</code> no longer takes an <code>int</code></li>
</ul></li>
</ul>
<h4 id="write-a-byte">write a byte</h4>
<div class="sourceCode" id="cb127"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb127-1" title="1">s.write(<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>)</a></code></pre></div>
<h4 id="earhart-command-sequence-to-get-a-frame">Earhart command sequence to get a frame</h4>
<div class="sourceCode" id="cb128"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb128-1" title="1">s.write(<span class="st">&#39;</span><span class="ch">\x00\x04</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb128-2" title="2">s.write(<span class="st">&#39;</span><span class="ch">\x00\x80</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb128-3" title="3">s.write(<span class="st">&#39;</span><span class="ch">\x00\x05</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb128-4" title="4">s.write(<span class="st">&#39;</span><span class="ch">\x01\xF4</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb128-5" title="5">s.inWaiting()</a></code></pre></div>
<ul>
<li>expect the response <code>4L</code> meaning there are four bytes waiting in the input buffer</li>
</ul>
<h2 id="dev-kit-redesign">Dev kit redesign</h2>
<ul>
<li><em>2019-05-10: revisiting this now: everything below is addressed</em></li>
<li>TODO: update this with redesign</li>
<li>old 2018-08-16 notes start here:</li>
<li>PCBs for dev kit will change</li>
<li>spi-master-simulant and spi-slave will be simpler</li>
<li>spectrometer breakout board will have optimized form factor for optics/alignment/mechanical-design</li>
</ul>
<h3 id="notes-from-2018-08-16-meeting-with-nadia">Notes from 2018-08-16 meeting with Nadia</h3>
<ul>
<li>revisit this in the future when we are making decision about ordering the dev kit:
<ul>
<li>compare lead time tradeoff with design time tradeoff</li>
<li>keep in mind we want to have some minimum redesign, so there will be lead time for an initial test run no matter what</li>
<li>so a redesign to eliminate the reduce the lead time is always a net positive</li>
</ul></li>
<li>high-level goal:
<ul>
<li>reduce lead time and cost before placing dev kit order</li>
<li>reach out to support@macrofab.com with lead time questions</li>
</ul></li>
<li>goal: eliminate all through-hole parts
<ul>
<li>move FT221X to a custom smt design with USB connector</li>
<li>eliminate switches:
<ul>
<li>for SPI communication, just connect boards</li>
<li>for programming, just connect programmer
<ul>
<li>make a breakout board to go from programming header to ribbon cable</li>
</ul></li>
</ul></li>
</ul></li>
<li>goal: eliminate cable termination step
<ul>
<li>switch from 10-pin ribbon cable to 10-pin FFC</li>
<li>also necessary to eliminate through-hole parts</li>
</ul></li>
<li>look for smt test points
<ul>
<li>if smt test loops do not exist we can get creative</li>
</ul></li>
</ul>
<h1 id="repo-links">Repo links</h1>
<p>Link to this repo: https://bitbucket.org/rainbots/lis-770i/src/master/</p>
<p>Clone this repo:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb129-1" title="1"><span class="fu">git</span> clone https://rainbots@bitbucket.org/rainbots/lis-770i.git</a></code></pre></div>
</body>
</html>
