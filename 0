# About LisSweep
## Goal of this writeup
- identify the code that communicates with the monochromator and the
  spectrometer to start a new project with minimal dependencies
- keep track of my progress
- write lists of manual tests
## Files
- the new sweep program for the LIS-770i is here:
- `C:\chromation-dropbox\Dropbox\labview programs\LabVIEW 2012\2018\LisSweep`
- `/cygdrive/c/chromation-dropbox/Dropbox/labview programs/LabVIEW 2012/2018/LisSweep/LisSweep.lvproj`
- Open the sweep program from Windows PowerShell:
```powershell
LisSweep
```
- Open the lib from Windows PowerShell:
```powershell
lib_2018
```
- Alias created in the profile like this:
```powershell
new-item alias:LisSweep -value "C:\chromation-dropbox\Dropbox\labview programs\LabVIEW 2012\2018\LisSweep\LisSweep.lvproj"
```
## Status
- [x] create LisSweep.lvproj
- [x] create lib-2018.lvproj
    - [x] create UsbFt.lvlib
    - [x] create Mono.lvlib
- [x] dev UsbFt VIs:
    - UsbFtDeviceIsAvailable.vi
    - UsbFtOpenDevice.vi
    - UsbFtCloseDevice.vi
- [x] add `use_stub` inputs to run application without the hardware
    - wrap all `D2XX` functions in a case statement
    - if `use_stub` is False, call the `D2XX` function
    - if `use_stub` is True, run the stub instead
    - the stub is empty if a return value is not needed
        - example: test code for `UsbFtCloseDevice.vi` does nothing
    - stub return values for the happy path
        - example: test code `UsbFtOpenDevice.vi` returns a dummy
          handle
    - this is only to allow development away from the hardware
    - this is not a full testing framework: there is no control over what values
      to return from the stub and no ability to check those values
- [x] create `use_stub` datatype in the application .lvlib to hold the
  `use_stub` control for each piece of hardware:
    - `use_stub.monoc`
    - `use_stub.spect`
- [x] dev Mono VIs:
    - MonoSendCmd.vi
- [x] add `FTD2XXX.dll:FT_SetDataCharacteristics` to `UsbFt.lvlib:UsbFtOpenDevice.vi`

## About the D2XX API: list of FTDI functions defined by the .dll
- all of the functions are listed here:
- `https://www.ftdichip.com/Support/Documents/ProgramGuides/D2XX_Programmer's_Guide(FT_000071).pdf`
- use `Connectivity\Libraries & Executables\Call Library Function Node` to use a
  `.dll` function in a LabVIEW VI
    - make sure the `Calling convention` is `stdcall (WINAPI)` and not `C`
        - using `C` results in LabVIEW error code 1517
    - after entering `FTD2XX.dll` under `Library name`, the `Function name`
      becomes a drop-down for selecting which function to call
    - LabVIEW generates the `Function prototype` as you add `Parameters` using
      the LabVIEW drop-down options
- the only low-level USB dependency in the project is `FTD2XX.dll`
- these .dll calls are wrapped in VIs defined in `UsbFt.lvlib`
- the VIs defined in `UsbFt.lvlib` are used in `Mono.lvlib`
## About the D2XX API: the handle is an application global
From trying to use the D2XX API today, it seems all of the functions intend the
handle of an open device as the input. The handle has to be stored in at the
application level. Instead of tracking if the device is opened or closed, the
handle must have a value, so just use the handle. When I fail to open a device,
I write `0` to the handle. This is treated as an invalid handle. Instead of
checking if the device is opened or closed, just pass the invalid handle. And
the program should not run if the device cannot open, so throw an error when
open fails and the application error handler immediately exits.

The monochromator handle is called `MonochHandle`.
The spectrometer handle is called `SpectHandle`.

## About developing without access to the monochromator
- [x] add a layer of abstraction between the D2XX calls and the application
    - this is why UsbFt.lvlib was created
    - example: `UsbFtCloseDevice.vi` just calls `FT_Close_Device.vi`, but I
      wrapped it in a VI to add the `use_stub` input and case structure
- [x] add a `use_stub` input to swap out the D2XX calls for stubs to mock the
  values the D2XX functions return
# Dev Notes
## Status messages and Error messages
Place the `Error Catch.vi` before the `Status Update Fixed.vi`. Wire the
`append` input True on both. This results in the desired behavior that *ERROR:*
messages are displayed in the log. The *ERROR* message is clobbered if the order
of the two VIs is reversed. I replaced `Status Update.vi` with `Status Update
Fixed.vi` in the entire application. The fix is to append status messages to the
log, even when there is an error.

The `Application Template` does not have this fixed behavior.

## Close USB Devices
Always attempt to close USB devices, even if there is an error. I removed the
error terminals from the `UsbFtCloseDevice.vi` because the behavior in the case
of an incoming error is not any different.

## LisSweep main.vi: state `OpenSpect`
- dependencies:
    - `UsbFt.lvlib:UsbFtNextAvailableDeviceName`
    - `UsbFt.lvlib:UsbFtOpenDevice.vi`
```test
Happy path:
[x] OpenSpect_opens_communication_with_the_next_available_device
[x] OpenSpect_happy_path_is_when_next_available_device_is_a_spectrometer
[x] OpenSpect_updates_the_GUI_with_the_name_of_the_device_it_opens
[x] OpenSpect_gets_the_spectrometer_ft_handle
[x] OpenSpect_logs_the_spectrometer_is_opened
[x] OpenSpect_does_not_throw_an_error_if_D2XX_is_stubbed
Sad paths:
[x] OpenSpect_logs_the_device_name_it_opens_if_the_device_is_not_a_spectrometer
[x] OpenSpect_logs_the_ft_handle_if_the_device_is_not_a_spectrometer
[x] OpenSpect_catches_the_error_no_available_devices_to_open
[x] OpenSpect_throws_an_error_if_next_available_device_is_not_a_spectrometer
```
## LisSweep main.vi: state `OpenMonoc`
- dependencies:
    - `UsbFt.lvlib:UsbFtOpenDevice.vi`
    - `Test.lvlib:StartsWith.vi`
```test
[x] OpenMonoc_opens_communication_with_the_monochromator
  - device name is `USB <-> Serial`
[x] OpenMonoc_gets_the_monochromator_ft_handle
[x] OpenMonoc_catches_error_monochromator_is_not_available
[x] OpenMonoc_logs_the_monochromator_is_opened
[x] OpenMonoc_does_not_throw_an_error_if_D2XX_is_stubbed
```
### UsbFt.lvlib:UsbFtNextAvailableDeviceName
- Get the name of the next available FTDI device.
#### Context
- monochromator and spectrometer are the only connected FTDI devices
- monochromator is already opened for communication
- the spectrometer is the next available device
#### Rationale
- I think this is the best approach in this context because the user does not
  have to do anything and it is minimal coding effort
##### Other Options
- provide a ring drop-down for the user to select the spectrometer
    - open whatever the user has selected
    - best for the user
    - but it adds noise to the UI
    - annoying to program:
        - populate the ring drop-down
        - read the selected value
- provide an empty box for the user to enter the spectrometer name
    - annoying for user to find out the device name and enter it
#### tests
```test
[x] UsbFtNextAvailableDeviceName_generates_a_list_of_available_device_names
[x] UsbFtNextAvailableDeviceName_leaves_empty_string_placeholder_if_unavailable
[x] UsbFtNextAvailableDeviceName_returns_first_non_empty_string
[x] UsbFtNextAvailableDeviceName_stubbed_returns "stubbed name Next Device"
```
### UsbFt.lvlib:UsbFtOpenDevice
#### manually tested
```test
Happy path:
[x] UsbFtOpenDevice_opens_the_USB_FT_device_if_it_is_available
[x] UsbFtOpenDevice_takes_dev_name_and_returns_ft_handle
    - Input `dev_name` is the USB String Description of the device to open.
    - Example: the monochromator name is "USB <-> Serial".
    - Output the FTDI Handle for D2XX functions to access the USB device.
[x] UsbFtOpenDevice_returns_a_status_message_for_logging

Sad paths:
[x] UsbFtOpenDevice_returns_ft_handle_0_if_called_with_an_incoming_error
[x] UsbFtOpenDevice_returns_ft_handle_0_if_the_dev_name_is_an_empty_string
[x] UsbFtOpenDevice_throws_an_error_if_the_USB_FT_device_is_not_available
[x] UsbFtOpenDevice_throws_an_error_if_dev_name_is_an_empty_string

Serial communication settings:
[x] UsbFtOpenDevice_uses_8_bits_and_1_stop_bit_and_parity_none
[x] UsbFtOpenDevice_uses_baud_rate_9600
    - these settings work for the spectrometer and monochromator:
    - word length: 8 bits
    - stop bits: 1
    - parity: none
    - baud rate: 9600
```
### Can check if a device is available but not if a device is open
- is there a D2XX function to test if a device is open without having to store
  this as a state?
    - no, but the functionality is there to see if the device is available
    - instead of an `IsOpen` this is an `IsAvailable`
    - walk a list of USB String Descriptions to see if the matching device name
      is listed
### UsbFt.lvlib:UsbFtDeviceIsAvailable
#### manually tested
```test
[x] UsbFtDeviceIsAvailable_returns_true_if_dev_name_is_available
[x] UsbFtDeviceIsAvailable_returns_false_if_dev_name_is_not_available
```

## LisSweep main.vi: states `CloseMonoc` and `CloseSpect`
- dependencies:
    - `UsbFt.lvlib:UsbFtCloseDevice.vi`
```test
- [x] CloseMonoc_closes_communication_with_the_monochromator
- [x] CloseMonoc_takes_a_handle
```
### UsbFt.lvlib:UsbFtCloseDevice
```test
- [x] UsbFtCloseDevice_closes_communication_with_the_USB_FT_device
```

## LisSweep main.vi: state `TestMonoc`
### Monochromator command examples
- `Mono.lvlib:MonoCmdMenu.vi`
- shows how to change wavelength, change grating, and change filter

## LisSweep main.vi: state `InitMonoc`
### Load the monochromator grating and filter and go to the first wavelength
### manually tested
```tests
[x] InitMonoc_loads_the_500nm_blaze_grating
[x] InitMonoc_loads_the_blank_filter
[x] InitMonoc_goes_to_300nm
```
## LisSweep main.vi: state `InitSpect`
### Set the integration time and other LIS-770i parameters
### manually tested
```tests
[ ] InitSpect_sets_the_integration_time_to_whatever_the_user_picks
[ ] InitSpect_sets_all_pixel_rows_active
[ ] InitSpect_sets_the_gain_to_1x
[ ] InitSpect_sets_the_pixel_binning_to_whatever_the_user_picks
```
# Notes while understanding lvproj `LisInterface`
## plot frame
- this is the consumer state that requests a frame of data
- I am confused about the read
- `FTDI_Fun.lvlibp:Read bytes.vi` waits until the number of bytes waiting is
  greater than or equal to the number of bytes expected, then it reads that
  number of bytes that is waiting
- but the number of bytes waiting should depend on binning, right? no
- the command to the spectrometer is 0x01 whether it is 392 pixels or 784 pixels
- the `mBrd` reads 784 pixels from the LIS, regardless of pixel binning
- the `mBrd` responds with 2x784 bytes, regardless of pixel binning
- [ ] update the firmware to only readout the required number of bytes and only
  respond with the required number of bytes
- [ ] update the host applications to expect the number of bytes matching the
  pixel binning (2x392 or 2x784)
# Notes while understanding lvproj `Earhart Monochromator Response`
## `INIT` does not communicate with the monochromator
### states queued during `INIT`
- select nm range
    - no communication with monochromator yet
    - just updates variables
- scan devices
    - looks for a connected Chromation module
- auto-gen save path
- enable setup
- update meas settings
- display instructions
## Menu Selection `Run Sweep` opens communication
- the menu selection `Run Sweep` is an event
- this event queues `init sweep`
### states queued during `init sweep`
- disable setup
- open Earhart
- open monochr
    - uses `FTDI_Fun.lvlibp:Serial Open By USB Name.vi`
- check save path
- begin sweep
### states queued during `begin sweep`
- select nm range
    - `MonoFun.lvlibp:Load nmStartStop from UserSelection.vi`
    - `nm` is a custom struct datatype
    - in the application:
        - `nm` is a member of `sweep`
            - `sweep` includes the Earhart and its integration time
        - `sweep` is a member of `setup`
            - `setup` includes `save`: the save path and setup description
    - `Load nmStartStop from UserSelection.vi` takes a pointer to a `nm` struct
    - this VI just reads the values stored for `start` and `stop`
    - write `start` and `stop` to the `setup.sweep.nm` struct
    - `setup` is a custom struct datatype
- auto-gen save path
- init monochr
    - this is the first important block of code
- init Earhart
    - this just clears out any old data
- *nm sweep*
    - this is the actual wavelength sweep
    - *for loop*:
        - walk the array `nmArray` created in `init monochr`
- save data
- next sweep
    - the sweeps are broken into three ranges corresponding to the two low pass
      filters:
        - 300-450nm (no filter)
        - 400-750nm (400nm low pass filter)
        - 700-1100nm (700nm low pass filter)
    - `next sweep` sets the value of the wavelength range for the next sweep
    - queue `begin sweep` to begin the next sweep
## Dependencies in state `init monochr`
- send command `NO-ECHO`:
    - `MonoFun.lvlibp:FTDI SP2150 Command.vi`
- set grating:
    - `MonoFun.lvlibp:FTDI SP2150 Change Grating.vi`
- set filter wheel:
    - `MonoFun.lvlibp:FTDI SP2150 Go to Filter.vi`
- go to first wavelength:
    - `MonoFun.lvlibp:FTDI SP2150 Go to Wavelength.vi`
- create `nmArray`, an array of wavelengths to sweep:
    - `MonoFun.lvlibp:Make nm Array -- Wavelength Cluster.vi`
# Design LisSweep
## UI events
- value change of any spectrometer or monochromator control writes the new value
  to the USB device
- `get_dark`
    - true: start dark measurement
    - false: abort dark measurement
- `sweep_nm`
    - true: start sweep
    - false: abort sweep
- `update_plot`
    - for testing and dev
    - click to get and plot one frame

## measurement flow
- [x] show peak of the single measurement, but when an average is obtained, show
  the peak of the average measurement
    - in free run this is silly
    - but when the user clicks update only one set of measurements is collected,
      ending with updating the average measurement, so the peak readout freezes
      on the average
- [x] record user-selected integration time before collecting dark data
- [x] load light block filter
- [x] collect dark data
    - this is really looking at strange pixel behavior, not true dark data
    - there is no dark to measure since it is subtracted out in hardware
    - not sure what to do with this dark data for now, but it is important to
      have
- [x] turn "GetDark" into a VI, like how "Sweep" calls WavelengthSweep.vi
    - DarkExposureSweep.vi
    - outputs `dark_matrix`
    - takes:
        - `SpectHandle_ref`
        - `SpectRefs_ref`
            - accesses `int_time_ref`
                - to display the `int_time` during the measurement
                - to restore `user_int_time` after the sweep
        - `FrameRefs_ref`
        - `nmeas_ref`
            - to display the `nmeas` during the measurement
            - to restore `user_nmeas` after the sweep
        - `user_int_time_ref`
            - to restore `user_int_time` after the sweep
        - `user_nmeas_ref`
            - to restore `user_nmeas` after the sweep
    - WavelengthSweep.vi
    - outputs `raw_response_matrix`
    - takes:
        - `MonocHandle_ref`
        - `MonoRefs_ref`
        - `FrameRefs_ref`
        - `SpectHandle_ref`
            - to communicate with the spectrometer
- [x] left off here
- [x] set integration time for the sweeps by restoring the user-selection
- [x] set number of measurements to average at each wavelength
- sweep state starts here
- [x] load blank filter
- [x] sweep 300-399nm
- [x] load 400nm LPF
- [x] sweep 400-699nm
- [x] load 700nm LPF
- [x] sweep 700-1100nm
- [x] for each wavelength:
    - [x] collect an average frame:
        - SpectGetAvgFrame displays frames as they are acquired
        - SpectDisplayFrame displays average frame on the `average_frame`
          plot line
    - [x] after the measurement, check if the next wavelength is 400 or 700 and
      load the correct filter if it is
- [x] output a 2d array of averaged frames
    - nothing to concatenate here since I am not doing some weird overlap stitch
      of three smaller sweeps
- [ ] left off here
- [ ] save this 2d array to file:
- `C:\chromation-dropbox\Dropbox\ChromationData\spectrometer\UsbSpi-Bridge\cal\wavelength\meas\nm-sweep\300nm-1100nm.txt`
    - [ ] `BuildRawResponseMatrixPath.vi`
        - see `BuildDarkMatrixPath.vi`
        - learn `Open/Create/Replace File.vi`
            - used in `FileCreatePathIfNew.vi`
            - [ ] troubleshoot why user is not prompted to replace files
            - [ ] troubleshoot why user is not prompted to create files
        - take reference to the base_save_path
        - take reference to the Spectrometer name from `SpectRefs`
            - strip the 'ChromationSpect' prefix from the name
            - insert the name in the save path
        - append the rest of the path including the file name

- run the analysis program
    - source power already exists
    - a copy is in the cal folder for this spectrometer:
- `C:\chromation-dropbox\Dropbox\ChromationData\spectrometer\UsbSpi-Bridge\cal\wavelength\meas\source-pwr\300nm-1100nm.txt`
    - divide the spectrometer counts at each wavelength by the source power at
      that wavelength
    - save as the `response-matrix`:
- `C:\chromation-dropbox\Dropbox\ChromationData\spectrometer\UsbSpi-Bridge\cal\wavelength\analysis\response-matrix.txt`
    - plot the response-matrix as a heatmap
    - pull the other analysis data: map, fwhm, responsivity
    - save the other analysis data in the map file
    - generate a summary report from the analysis data
    - save the plots as .png files
## implement measurement flow as consumer state flow
### init gui
- disable and grey the monochromator controls
- disable and grey the spectrometer controls
- disable and grey the UI buttons to start the dark measurement and sweep
  wavelength
### OpenMonoc
- open communication with the USB driver
### OpenSpect
- open communication with the USB driver
- display the name of the spectrometer
- enable the spectrometer controls
- enable the UI buttons to start the dark measurement and sweep wavelength
### InitMonoc
- initialize values for blaze grating, filter wheel, and wavelength
- enable the monochromator controls
### LoadGrating
- load the 500nm blaze grating
### LoadFilterWheel
- load the light block
### GoToWavelength
- go to 300nm
### InitSpect
- populate the menu of integration times
### SpectIntTime
- read the integration time from the UI
- set the integration time on the spectrometer
- log the integration time reported by the spectrometer
### SpectCfg
- set the binning, gain, and rowselect on the spectrometer
- log the binning, gain, and rowselect values sent to the spectrometer
### PlotFrame
- get a frame
- update the plot and the peak pixel display
### GetDark
- [x] calculate number of measurements:
    - in: desired bandwidth
    - in: integration time
    - out: number of measurements
- [x] for each integration time:
    - `GetAndPlotNFrames`: collect a 2d array of measurements:
        - nmeas x npix
    - average the array to a 1 x npix:
        - sum each iteration in a while loop, then only save the final array --
          this is much less memory intensive
### SaveDark
- [ ] add header
    - [x] add column name header
    - [ ] add date, device name, device config
- there is no confirmation before creating a new file or overwriting a file.
- [ ] add confirmation
#### [x] format data
- [x] save the average dark for each integration time
    - prepend each average dark measurement with its integration time
    - save the prepended average dark measurements to file, each measurement on
      its own line
#### example data
```data
1.000	50.200	46.800	44.700	... 439.900
2.000	62.467	45.733	47.200	... 461.333
3.000	62.700	54.500	53.700	... 448.600
4.000	56.375	65.500	37.750	... 437.750
5.000	38.167	54.667	55.667	... 443.500
6.000	37.400	43.000	42.400	... 430.000
7.000	58.000	40.200	56.600	... 447.600
8.000	59.250	39.000	49.500	... 432.500
9.000	59.500	65.500	54.500	... 455.250
10.000	47.667	59.333	55.000	... 464.333
20.000	37.500	59.000	43.500	... 396.500
30.000	67.000	92.000	103.000	... 440.000
40.000	97.000	34.000	31.000	... 447.000
50.000	16.000	94.000	8.000	... 435.000
60.000	63.000	66.000	38.000	... 423.000
70.000	10.000	62.000	8.000	... 471.000
80.000	43.000	51.000	16.000	... 448.000
90.000	13.000	19.000	14.000	... 432.000
100.000	30.000	64.000	12.000	... 491.000
```
#### [x] generate the path
- base path:
- `C:\chromation-dropbox\Dropbox\ChromationData\spectrometer\cal\wavelength\meas`
    - append to base path:
        - spectrometer name
    - append rest of measurement path:
        - `\dark\dark-matrix.txt`
        - `\nm-sweep\300nm-450nm.txt`
        - `\source-pwr\300nm-450nm.txt``
- example dark-matrix.txt path:
- `/cygdrive/c/chromation-dropbox/Dropbox/ChromationData/spectrometer/cal/wavelength/meas/Stubbed Spectrometer/dark/dark-matrix.txt`
- [x] create the path if it does not exist
    - [x] throw error if path is a not a file path
    - [x] create all missing folders in the path
    - [ ] prompt user to confirm create new if folders in path do not exist
    - [ ] prompt user to confirm overwrite if path exists

## new spectrometer name convention
- all names are on the UsbSpi-Bridge PCB
    - this is where the `FT221XA` USB Bridge IC is located
- internal name (no serial number): `ChromationSpect-UsbSpi-Bridge`
- external name for customer eval: `ChromationSpect-0638-01`
- to get the number:
```powershell
cd C:\chromation-dropbox\Dropbox\python\serial_number_project
python '.\example.py' date=2018-10-25
```
- Example external serial number: `0638-01` means spectrometer 'A' calibrated on
  '2018-10-25':
    - `0638` encodes the date of the spectrometer wavelength calibration as the
      number of days since 2017-01-25
    - `01` is any number *from 1 to 26* to indicate which spectrometer if more
      than one is calibrated on the same day
- Calibration data is saved here:
- `C:\chromation-dropbox\Dropbox\ChromationData\spectrometer\{SpectName}\cal\wavelength\meas`
- the spectrometer USB device name is used in the path
- but the `ChromationSpect` prefix is stripped from the device name
- examples:
- Example: for spectrometer `ChromationSpect-UsbSpi-Bridge` the dark path is:
- `C:\chromation-dropbox\Dropbox\ChromationData\spectrometer\UsbSpi-Bridge\cal\wavelength\meas\dark`
- Example: for spectrometer `ChromationSpect-0638-01` the dark path is:
- `C:\chromation-dropbox\Dropbox\ChromationData\spectrometer\0638-01\cal\wavelength\meas\dark`
C:\chromation-dropbox\Dropbox\ChromationData\spectrometer\UsbSpi-Bridge\cal\wavelength\meas\dark
/cygdrive/c/chromation-dropbox/Dropbox/ChromationData/spectrometer/UsbSpi-Bridge/cal/wavelength/meas/dark


