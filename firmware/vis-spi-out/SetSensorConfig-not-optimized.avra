inline void SetSensorConfig(void)
{
 28a:	ef 92       	push	r14
 28c:	ff 92       	push	r15
 28e:	1f 93       	push	r17
 290:	cf 93       	push	r28
 292:	df 93       	push	r29
 294:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
 298:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
{ //! Return true if Queue is empty
    /** QueueIsEmpty behavior:\n 
      * - returns true if Queue is empty\n 
      * - returns false if Queue is not empty\n 
      * */
    if (pq->length == 0) return true;
 29c:	84 81       	ldd	r24, Z+4	; 0x04
 29e:	88 23       	and	r24, r24
 2a0:	e9 f3       	breq	.-6      	; 0x29c <SetSensorConfig+0x12>
 2a2:	84 81       	ldd	r24, Z+4	; 0x04
 2a4:	88 23       	and	r24, r24
 2a6:	89 f0       	breq	.+34     	; 0x2ca <SetSensorConfig+0x40>
      * - returns 0 if Queue is empty\n 
      * - hits end of buffer and wraps around if Queue is not empty\n 
      * */
    if (QueueIsEmpty(pq)) return 0;
    // wrap tail to beginning of buffer when it reaches the end of the buffer
    if (pq->tail >= pq->max_length) pq->tail = 0;
 2a8:	93 81       	ldd	r25, Z+3	; 0x03
 2aa:	85 81       	ldd	r24, Z+5	; 0x05
 2ac:	98 17       	cp	r25, r24
 2ae:	08 f0       	brcs	.+2      	; 0x2b2 <SetSensorConfig+0x28>
 2b0:	a5 c0       	rjmp	.+330    	; 0x3fc <SetSensorConfig+0x172>
    pq->length--;
 2b2:	84 81       	ldd	r24, Z+4	; 0x04
 2b4:	81 50       	subi	r24, 0x01	; 1
 2b6:	84 83       	std	Z+4, r24	; 0x04
    // Return the byte. Remove byte from Queue by advancing "tail".
    return pq->buffer[pq->tail++];
 2b8:	a0 81       	ld	r26, Z
 2ba:	b1 81       	ldd	r27, Z+1	; 0x01
 2bc:	83 81       	ldd	r24, Z+3	; 0x03
 2be:	91 e0       	ldi	r25, 0x01	; 1
 2c0:	98 0f       	add	r25, r24
 2c2:	93 83       	std	Z+3, r25	; 0x03
 2c4:	a8 0f       	add	r26, r24
 2c6:	b1 1d       	adc	r27, r1
 2c8:	8c 91       	ld	r24, X
      * - replies ERROR if active rows is invalid\n 
      * - replies OK if all config values are valid\n 
      * */
    // Get config values
    while (QueueIsEmpty(SpiFifo)); // 5 cycles
    binning = QueuePop(SpiFifo);
 2ca:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <binning>
{ //! Return true if Queue is empty
    /** QueueIsEmpty behavior:\n 
      * - returns true if Queue is empty\n 
      * - returns false if Queue is not empty\n 
      * */
    if (pq->length == 0) return true;
 2ce:	94 81       	ldd	r25, Z+4	; 0x04
 2d0:	99 23       	and	r25, r25
 2d2:	e9 f3       	breq	.-6      	; 0x2ce <SetSensorConfig+0x44>
 2d4:	94 81       	ldd	r25, Z+4	; 0x04
 2d6:	99 23       	and	r25, r25
 2d8:	89 f0       	breq	.+34     	; 0x2fc <SetSensorConfig+0x72>
      * - returns 0 if Queue is empty\n 
      * - hits end of buffer and wraps around if Queue is not empty\n 
      * */
    if (QueueIsEmpty(pq)) return 0;
    // wrap tail to beginning of buffer when it reaches the end of the buffer
    if (pq->tail >= pq->max_length) pq->tail = 0;
 2da:	23 81       	ldd	r18, Z+3	; 0x03
 2dc:	95 81       	ldd	r25, Z+5	; 0x05
 2de:	29 17       	cp	r18, r25
 2e0:	08 f0       	brcs	.+2      	; 0x2e4 <SetSensorConfig+0x5a>
 2e2:	8a c0       	rjmp	.+276    	; 0x3f8 <SetSensorConfig+0x16e>
    pq->length--;
 2e4:	94 81       	ldd	r25, Z+4	; 0x04
 2e6:	91 50       	subi	r25, 0x01	; 1
 2e8:	94 83       	std	Z+4, r25	; 0x04
    // Return the byte. Remove byte from Queue by advancing "tail".
    return pq->buffer[pq->tail++];
 2ea:	a0 81       	ld	r26, Z
 2ec:	b1 81       	ldd	r27, Z+1	; 0x01
 2ee:	93 81       	ldd	r25, Z+3	; 0x03
 2f0:	21 e0       	ldi	r18, 0x01	; 1
 2f2:	29 0f       	add	r18, r25
 2f4:	23 83       	std	Z+3, r18	; 0x03
 2f6:	a9 0f       	add	r26, r25
 2f8:	b1 1d       	adc	r27, r1
 2fa:	9c 91       	ld	r25, X
    while (QueueIsEmpty(SpiFifo)); // 5 cycles
    gain = QueuePop(SpiFifo);
 2fc:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <gain>
{ //! Return true if Queue is empty
    /** QueueIsEmpty behavior:\n 
      * - returns true if Queue is empty\n 
      * - returns false if Queue is not empty\n 
      * */
    if (pq->length == 0) return true;
 300:	24 81       	ldd	r18, Z+4	; 0x04
 302:	22 23       	and	r18, r18
 304:	e9 f3       	breq	.-6      	; 0x300 <SetSensorConfig+0x76>
 306:	24 81       	ldd	r18, Z+4	; 0x04
 308:	22 23       	and	r18, r18
 30a:	91 f0       	breq	.+36     	; 0x330 <SetSensorConfig+0xa6>
      * - returns 0 if Queue is empty\n 
      * - hits end of buffer and wraps around if Queue is not empty\n 
      * */
    if (QueueIsEmpty(pq)) return 0;
    // wrap tail to beginning of buffer when it reaches the end of the buffer
    if (pq->tail >= pq->max_length) pq->tail = 0;
 30c:	33 81       	ldd	r19, Z+3	; 0x03
 30e:	25 81       	ldd	r18, Z+5	; 0x05
 310:	32 17       	cp	r19, r18
 312:	08 f0       	brcs	.+2      	; 0x316 <SetSensorConfig+0x8c>
 314:	6f c0       	rjmp	.+222    	; 0x3f4 <SetSensorConfig+0x16a>
    pq->length--;
 316:	24 81       	ldd	r18, Z+4	; 0x04
 318:	21 50       	subi	r18, 0x01	; 1
 31a:	24 83       	std	Z+4, r18	; 0x04
    // Return the byte. Remove byte from Queue by advancing "tail".
    return pq->buffer[pq->tail++];
 31c:	20 81       	ld	r18, Z
 31e:	31 81       	ldd	r19, Z+1	; 0x01
 320:	43 81       	ldd	r20, Z+3	; 0x03
 322:	51 e0       	ldi	r21, 0x01	; 1
 324:	54 0f       	add	r21, r20
 326:	53 83       	std	Z+3, r21	; 0x03
 328:	f9 01       	movw	r30, r18
 32a:	e4 0f       	add	r30, r20
 32c:	f1 1d       	adc	r31, r1
 32e:	20 81       	ld	r18, Z
    while (QueueIsEmpty(SpiFifo)); // 5 cycles
    active_rows = QueuePop(SpiFifo);
 330:	20 93 34 01 	sts	0x0134, r18	; 0x800134 <active_rows>
    // Reply with error if any config value is invalid
    // TODO: replace with LisConfigIsValid(binning, gain, active_rows)
    if (
 334:	30 91 17 01 	lds	r19, 0x0117	; 0x800117 <BINNING_OFF>
 338:	38 17       	cp	r19, r24
 33a:	09 f4       	brne	.+2      	; 0x33e <SetSensorConfig+0xb4>
 33c:	61 c0       	rjmp	.+194    	; 0x400 <__LOCK_REGION_LENGTH__>
            ((binning != BINNING_OFF) && (binning != BINNING_ON))
 33e:	30 91 16 01 	lds	r19, 0x0116	; 0x800116 <BINNING_ON>
 342:	38 17       	cp	r19, r24
 344:	09 f4       	brne	.+2      	; 0x348 <SetSensorConfig+0xbe>
 346:	5c c0       	rjmp	.+184    	; 0x400 <__LOCK_REGION_LENGTH__>
        ||  ((gain != GAIN_1X) && (gain != GAIN_2X5) && (gain != GAIN_4X) && (gain != GAIN_5X))
        ||  ((active_rows & 0xE0) != 0x00)
       )
    {
        SpiSlaveTxByte(ERROR);
 348:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <ERROR>
      * - waits until SPI transfer is done\n 
      * - drives DataReady HIGH immediately after SPI transfer
      *   finishes\n 
      * - enables SPI ISR after transfer\n 
      * */
    *Spi_SPDR = input_byte;
 34c:	e0 90 1f 01 	lds	r14, 0x011F	; 0x80011f <Spi_SPDR>
 350:	f0 90 20 01 	lds	r15, 0x0120	; 0x800120 <Spi_SPDR+0x1>
 354:	e7 01       	movw	r28, r14
 356:	88 83       	st	Y, r24
      * - Check the flag by calling `_SpiTransferIsDone()`\n 
      * - Clear `SPIF` manually by calling
      *   `ClearSpiInterruptFlag()`\n 
      * */
    // Disable the "transfer complete" interrupt
    ClearBit(Spi_SPCR, Spi_InterruptEnable);
 358:	a0 91 21 01 	lds	r26, 0x0121	; 0x800121 <Spi_SPCR>
 35c:	b0 91 22 01 	lds	r27, 0x0122	; 0x800122 <Spi_SPCR+0x1>
inline void ClearBit(register_address reg_addr, bit_index bit)
{
    /** ClearBit behavior:\n 
      * - clears bit in register\n 
      * */
    *reg_addr &= ~(1<<bit);
 360:	9c 91       	ld	r25, X
 362:	10 91 1b 01 	lds	r17, 0x011B	; 0x80011b <Spi_InterruptEnable>
 366:	21 e0       	ldi	r18, 0x01	; 1
 368:	30 e0       	ldi	r19, 0x00	; 0
 36a:	a9 01       	movw	r20, r18
 36c:	01 2e       	mov	r0, r17
 36e:	01 c0       	rjmp	.+2      	; 0x372 <SetSensorConfig+0xe8>
 370:	44 0f       	add	r20, r20
 372:	0a 94       	dec	r0
 374:	ea f7       	brpl	.-6      	; 0x370 <SetSensorConfig+0xe6>
 376:	84 2f       	mov	r24, r20
 378:	80 95       	com	r24
 37a:	89 23       	and	r24, r25
 37c:	8c 93       	st	X, r24
      * - SPI Master waits for **Data Ready** LOW before reading
      *   a byte from the SPI Slave.\n
      * - SPI Slave drives **Data Ready** HIGH after each byte of
      *   SPI transfer.
      * */
    ClearBit(Spi_port, Spi_DataReady);
 37e:	40 91 23 01 	lds	r20, 0x0123	; 0x800123 <Spi_port>
 382:	50 91 24 01 	lds	r21, 0x0124	; 0x800124 <Spi_port+0x1>
 386:	fa 01       	movw	r30, r20
 388:	80 81       	ld	r24, Z
 38a:	b9 01       	movw	r22, r18
 38c:	00 90 1c 01 	lds	r0, 0x011C	; 0x80011c <Spi_DataReady>
 390:	02 c0       	rjmp	.+4      	; 0x396 <SetSensorConfig+0x10c>
 392:	66 0f       	add	r22, r22
 394:	77 1f       	adc	r23, r23
 396:	0a 94       	dec	r0
 398:	e2 f7       	brpl	.-8      	; 0x392 <SetSensorConfig+0x108>
 39a:	96 2f       	mov	r25, r22
 39c:	90 95       	com	r25
 39e:	89 23       	and	r24, r25
 3a0:	80 83       	st	Z, r24
 3a2:	e0 91 1d 01 	lds	r30, 0x011D	; 0x80011d <Spi_SPSR>
 3a6:	f0 91 1e 01 	lds	r31, 0x011E	; 0x80011e <Spi_SPSR+0x1>
 3aa:	00 90 1a 01 	lds	r0, 0x011A	; 0x80011a <Spi_InterruptFlag>
 3ae:	02 c0       	rjmp	.+4      	; 0x3b4 <SetSensorConfig+0x12a>
 3b0:	22 0f       	add	r18, r18
 3b2:	33 1f       	adc	r19, r19
 3b4:	0a 94       	dec	r0
 3b6:	e2 f7       	brpl	.-8      	; 0x3b0 <SetSensorConfig+0x126>
}
// Read bits
inline bool BitIsSet(register_address reg_addr, bit_index bit)
{
    return *reg_addr & 1<<bit;
 3b8:	80 81       	ld	r24, Z
    // out	0x2c, r24	; 44
    _SignalDataReady();
    // ---Expected Assembly---
    // cbi	0x05, 1	; 5
    // Wait for a byte from the SPI Master.
    while ( !_SpiTransferIsDone() ); // Check SPI interrupt flag
 3ba:	90 e0       	ldi	r25, 0x00	; 0
 3bc:	82 23       	and	r24, r18
 3be:	93 23       	and	r25, r19
 3c0:	89 2b       	or	r24, r25
 3c2:	d1 f3       	breq	.-12     	; 0x3b8 <SetSensorConfig+0x12e>
inline void SetBit(register_address reg_addr, bit_index bit)
{
    /** SetBit behavior:\n 
      * - sets bit in register\n 
      * */
    *reg_addr |= 1<<bit;
 3c4:	ea 01       	movw	r28, r20
 3c6:	88 81       	ld	r24, Y
 3c8:	68 2b       	or	r22, r24
 3ca:	68 83       	st	Y, r22
     *   - alternatively, SPIF is cleared by first reading the
     *     SPI status register, then accessing the SPI data
     *     register\n 
     * */
    // Global interrupt disable
    cli(); // cli
 3cc:	f8 94       	cli
    // This is three instructions because SPCR is outside the
    // address range for using `cbi`.
}
inline uint8_t ReadSpiStatusRegister(void)
{
    return *Spi_SPSR;
 3ce:	80 81       	ld	r24, Z
    // ---Expected Assembly---
    // in	r24, 0x2d	; 45
}
inline uint8_t ReadSpiDataRegister(void)
{
    return *Spi_SPDR;
 3d0:	f7 01       	movw	r30, r14
 3d2:	80 81       	ld	r24, Z
 3d4:	2c 91       	ld	r18, X
 3d6:	81 e0       	ldi	r24, 0x01	; 1
 3d8:	90 e0       	ldi	r25, 0x00	; 0
 3da:	01 c0       	rjmp	.+2      	; 0x3de <SetSensorConfig+0x154>
 3dc:	88 0f       	add	r24, r24
 3de:	1a 95       	dec	r17
 3e0:	ea f7       	brpl	.-6      	; 0x3dc <SetSensorConfig+0x152>
 3e2:	82 2b       	or	r24, r18
 3e4:	8c 93       	st	X, r24
    // out 0x2c, r24
    // This is three instructions because SPCR is outside the
    // address range for using `sbi`.
    //
    // Global interrupt enable
    sei(); // sei
 3e6:	78 94       	sei
        return;
    }
    /* LisWriteConfig(binning, gain, active_rows); */
    SpiSlaveTxByte(OK);
}
 3e8:	df 91       	pop	r29
 3ea:	cf 91       	pop	r28
 3ec:	1f 91       	pop	r17
 3ee:	ff 90       	pop	r15
 3f0:	ef 90       	pop	r14
 3f2:	08 95       	ret
      * - returns 0 if Queue is empty\n 
      * - hits end of buffer and wraps around if Queue is not empty\n 
      * */
    if (QueueIsEmpty(pq)) return 0;
    // wrap tail to beginning of buffer when it reaches the end of the buffer
    if (pq->tail >= pq->max_length) pq->tail = 0;
 3f4:	13 82       	std	Z+3, r1	; 0x03
 3f6:	8f cf       	rjmp	.-226    	; 0x316 <SetSensorConfig+0x8c>
 3f8:	13 82       	std	Z+3, r1	; 0x03
 3fa:	74 cf       	rjmp	.-280    	; 0x2e4 <SetSensorConfig+0x5a>
 3fc:	13 82       	std	Z+3, r1	; 0x03
 3fe:	59 cf       	rjmp	.-334    	; 0x2b2 <SetSensorConfig+0x28>
    active_rows = QueuePop(SpiFifo);
    // Reply with error if any config value is invalid
    // TODO: replace with LisConfigIsValid(binning, gain, active_rows)
    if (
            ((binning != BINNING_OFF) && (binning != BINNING_ON))
        ||  ((gain != GAIN_1X) && (gain != GAIN_2X5) && (gain != GAIN_4X) && (gain != GAIN_5X))
 400:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <GAIN_1X>
 404:	89 17       	cp	r24, r25
 406:	61 f0       	breq	.+24     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
 408:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <GAIN_2X5>
 40c:	89 17       	cp	r24, r25
 40e:	41 f0       	breq	.+16     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
 410:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <GAIN_4X>
 414:	89 17       	cp	r24, r25
 416:	21 f0       	breq	.+8      	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
 418:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <GAIN_5X>
 41c:	89 13       	cpse	r24, r25
 41e:	94 cf       	rjmp	.-216    	; 0x348 <SetSensorConfig+0xbe>
        ||  ((active_rows & 0xE0) != 0x00)
 420:	20 7e       	andi	r18, 0xE0	; 224
 422:	09 f0       	breq	.+2      	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
 424:	91 cf       	rjmp	.-222    	; 0x348 <SetSensorConfig+0xbe>
    {
        SpiSlaveTxByte(ERROR);
        return;
    }
    /* LisWriteConfig(binning, gain, active_rows); */
    SpiSlaveTxByte(OK);
 426:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <OK>
      * - waits until SPI transfer is done\n 
      * - drives DataReady HIGH immediately after SPI transfer
      *   finishes\n 
      * - enables SPI ISR after transfer\n 
      * */
    *Spi_SPDR = input_byte;
 42a:	e0 90 1f 01 	lds	r14, 0x011F	; 0x80011f <Spi_SPDR>
 42e:	f0 90 20 01 	lds	r15, 0x0120	; 0x800120 <Spi_SPDR+0x1>
 432:	e7 01       	movw	r28, r14
 434:	88 83       	st	Y, r24
      * - Check the flag by calling `_SpiTransferIsDone()`\n 
      * - Clear `SPIF` manually by calling
      *   `ClearSpiInterruptFlag()`\n 
      * */
    // Disable the "transfer complete" interrupt
    ClearBit(Spi_SPCR, Spi_InterruptEnable);
 436:	a0 91 21 01 	lds	r26, 0x0121	; 0x800121 <Spi_SPCR>
 43a:	b0 91 22 01 	lds	r27, 0x0122	; 0x800122 <Spi_SPCR+0x1>
inline void ClearBit(register_address reg_addr, bit_index bit)
{
    /** ClearBit behavior:\n 
      * - clears bit in register\n 
      * */
    *reg_addr &= ~(1<<bit);
 43e:	9c 91       	ld	r25, X
 440:	10 91 1b 01 	lds	r17, 0x011B	; 0x80011b <Spi_InterruptEnable>
 444:	21 e0       	ldi	r18, 0x01	; 1
 446:	30 e0       	ldi	r19, 0x00	; 0
 448:	a9 01       	movw	r20, r18
 44a:	01 2e       	mov	r0, r17
 44c:	01 c0       	rjmp	.+2      	; 0x450 <__LOCK_REGION_LENGTH__+0x50>
 44e:	44 0f       	add	r20, r20
 450:	0a 94       	dec	r0
 452:	ea f7       	brpl	.-6      	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
 454:	84 2f       	mov	r24, r20
 456:	80 95       	com	r24
 458:	89 23       	and	r24, r25
 45a:	8c 93       	st	X, r24
      * - SPI Master waits for **Data Ready** LOW before reading
      *   a byte from the SPI Slave.\n
      * - SPI Slave drives **Data Ready** HIGH after each byte of
      *   SPI transfer.
      * */
    ClearBit(Spi_port, Spi_DataReady);
 45c:	40 91 23 01 	lds	r20, 0x0123	; 0x800123 <Spi_port>
 460:	50 91 24 01 	lds	r21, 0x0124	; 0x800124 <Spi_port+0x1>
 464:	fa 01       	movw	r30, r20
 466:	80 81       	ld	r24, Z
 468:	b9 01       	movw	r22, r18
 46a:	00 90 1c 01 	lds	r0, 0x011C	; 0x80011c <Spi_DataReady>
 46e:	02 c0       	rjmp	.+4      	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
 470:	66 0f       	add	r22, r22
 472:	77 1f       	adc	r23, r23
 474:	0a 94       	dec	r0
 476:	e2 f7       	brpl	.-8      	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
 478:	96 2f       	mov	r25, r22
 47a:	90 95       	com	r25
 47c:	89 23       	and	r24, r25
 47e:	80 83       	st	Z, r24
 480:	e0 91 1d 01 	lds	r30, 0x011D	; 0x80011d <Spi_SPSR>
 484:	f0 91 1e 01 	lds	r31, 0x011E	; 0x80011e <Spi_SPSR+0x1>
 488:	00 90 1a 01 	lds	r0, 0x011A	; 0x80011a <Spi_InterruptFlag>
 48c:	02 c0       	rjmp	.+4      	; 0x492 <__LOCK_REGION_LENGTH__+0x92>
 48e:	22 0f       	add	r18, r18
 490:	33 1f       	adc	r19, r19
 492:	0a 94       	dec	r0
 494:	e2 f7       	brpl	.-8      	; 0x48e <__LOCK_REGION_LENGTH__+0x8e>
}
// Read bits
inline bool BitIsSet(register_address reg_addr, bit_index bit)
{
    return *reg_addr & 1<<bit;
 496:	80 81       	ld	r24, Z
    // out	0x2c, r24	; 44
    _SignalDataReady();
    // ---Expected Assembly---
    // cbi	0x05, 1	; 5
    // Wait for a byte from the SPI Master.
    while ( !_SpiTransferIsDone() ); // Check SPI interrupt flag
 498:	90 e0       	ldi	r25, 0x00	; 0
 49a:	82 23       	and	r24, r18
 49c:	93 23       	and	r25, r19
 49e:	89 2b       	or	r24, r25
 4a0:	d1 f3       	breq	.-12     	; 0x496 <__LOCK_REGION_LENGTH__+0x96>
 4a2:	90 cf       	rjmp	.-224    	; 0x3c4 <SetSensorConfig+0x13a>
