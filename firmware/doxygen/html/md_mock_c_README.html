<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>firmware: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Chromation_colored.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">firmware
   &#160;<span id="projectnumber">v0.1.2</span>
   </div>
   <div id="projectbrief">Chromation Spectrometer Dev-Kit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Mock functions for C unit tests.</p>
<h1><a class="anchor" id="autotoc_md45"></a>
What are unit tests and what is a mock?</h1>
<p>A unit test checks that a particular function does a particular thing under a particular condition. Mocks enable unit tests to say "here is a list of expected calls and the arguments they should be called with under this scenario, tell me if my code is producing the same list".</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Table of Contents</h2>
<ul>
<li><a href="README.md#mock-c-repository-contents">mock-c repository contents</a></li>
<li><a href="README.md#integrating-mock-c-in-your-project">Integrating mock-c in your project</a></li>
<li><a href="README.md#example-recipe-for-a-unit-test-application">Example recipe for a unit test application</a></li>
<li><a href="README.md#about-mock-c">About mock-c</a></li>
<li><a href="README.md#avoid-mocking-as-much-as-possible">Avoid mocking as much as possible</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md47"></a>
mock-c repository contents</h1>
<div class="fragment"><div class="line">.</div>
<div class="line">├── build/</div>
<div class="line">├── code/</div>
<div class="line">└── tests/</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md48"></a>
mock-c tests folder</h2>
<p><code>tests/</code> contains the unit tests for testing <b>mock-c</b>. Ignore <code>tests/</code> unless you are changing <code>mock-c</code>.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
mock-c code folder</h2>
<p><code>code/</code> contains:</p>
<ul>
<li>the <b>mock-c</b> source code:</li>
</ul>
<div class="fragment"><div class="line">Mock.c           Mock.h</div>
<div class="line">RecordedArg.c    RecordedArg.h</div>
<div class="line">RecordedCall.c   RecordedCall.h</div>
<div class="line">ReturnValues.c   ReturnValues.h</div>
</div><!-- fragment --><p>I'm disappointed every time I start poking around in here. I implemented stuff in <b>mock-c</b> as I needed it and never went back to clean out the old stuff. It does what I need for now, but it needs a haircut.</p>
<ul>
<li>a modified version of <em>ThrowTheSwitch</em>'s <a href="https://github.com/ThrowTheSwitch/Unity">Unity Test</a> source code:</li>
</ul>
<div class="fragment"><div class="line">unity.c          unity.h</div>
<div class="line">                 unity_internals.h</div>
</div><!-- fragment --><p>My modifications are very minor.</p>
<ul>
<li>and two extra files that are not necessary to use <b>mock-c</b> but help me get <b>mock-c</b> running on a new computer:<ul>
<li><code>Makefile</code><ul>
<li>run <code>make lib-tags</code> inside the <code>code</code> folder to build a tags file with ctags to tag-jump and auto-complete using symbols from <em>system headers</em>, in particular the system header <code>glib.h</code> and all the headers it includes</li>
<li>run <code>make</code> inside the <code>code</code> folder to test if GLib is installed</li>
</ul>
</li>
<li><code><a class="el" href="test-glib-install_8c_source.html">test-glib-install.c</a></code><ul>
<li>this is 11 lines of code that prints a "Congratulations" if GLib is installed</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md50"></a>
mock-c build folder</h2>
<p><code>build/</code> contains the <b>mock-c</b> object files that unit tests are linked with. The object files are not in this repository; your project compiles them. And your project links with these object files when it builds its test runner application.</p>
<h1><a class="anchor" id="autotoc_md51"></a>
Integrating mock-c in your project</h1>
<div class="fragment"><div class="line">$ cd my-project</div>
<div class="line">$ git clone https://github.com/sustainablelab/mock-c.git</div>
</div><!-- fragment --><p>Here is an example project structure:</p>
<div class="fragment"><div class="line">. &lt;------------------- My project</div>
<div class="line">├── project-code/ &lt;--- My project&#39;s top-level firmware folder</div>
<div class="line">│   ├── build/</div>
<div class="line">│   ├── code/</div>
<div class="line">│   ├── tests/</div>
<div class="line">│   └── Makefile &lt;---- My build script tells the linker to look in ../mock-c/build/</div>
<div class="line">│</div>
<div class="line">└── mock-c/ &lt;--------- this repository</div>
<div class="line">    ├── build/ &lt;------ My build script builds these .o files</div>
<div class="line">    │   ├─── Mock.o</div>
<div class="line">    │   ├─── RecordedArg.o</div>
<div class="line">    │   ├─── RecordedCall.o</div>
<div class="line">    │   ├─── ReturnValues.o</div>
<div class="line">    │   └─── unity.o</div>
<div class="line">    │</div>
<div class="line">    ├── code/</div>
<div class="line">    └── tests/</div>
</div><!-- fragment --><p>Here are build examples using:</p>
<ul>
<li><code>make</code> and <code>gcc</code> as the build tools</li>
<li>the above file structure<ul>
<li>i.e., where <b>mock-c</b> is cloned, relative to your build script</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md52"></a>
Compiling mock-c</h2>
<p>Your project's build script (<code>Makefile</code>) builds the <code>mock-c</code> object files like this:</p>
<div class="fragment"><div class="line">CFLAGS := -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include</div>
<div class="line"> </div>
<div class="line">../mock-c/build/%.o: ../mock-c/code/%.c ../mock-c/code/%.h ../mock-c/code/unity_internals.h</div>
<div class="line">    gcc -c $&lt; -o $@ $(CFLAGS)</div>
</div><!-- fragment --><p><em>The context is that your test runner executable links with mock-c object files (I'll show a recipe for that later). The recipe above tells <code>make</code> how to create those files in the <code>../mock-c/build/</code> folder if they don't exist (and they won't exist when you first clone this repository).</em></p>
<p>I explain how to read this recipe so you can achieve the same goal with build tools other than <code>make</code> and <code>gcc</code>.</p>
<h3>Reading Makefile recipes</h3>
<div class="fragment"><div class="line">target: pre-requisites</div>
<div class="line">    action</div>
</div><!-- fragment --><ul>
<li><code>target</code> is whatever needs to get made</li>
<li><code>pre-requisites</code> are a list of files<ul>
<li><code>make</code> rebuilds <code>target</code> if it is older than any of the <code>pre-requisites</code></li>
</ul>
</li>
<li><code>action</code> is whatever needs to get done (e.g., compile a <code>.c</code> into a <code>.o</code>)</li>
</ul>
<p>*<code>action</code> uses symbols <code>$&lt;</code> and <code>$@</code>*</p>
<div class="fragment"><div class="line">target: pre-requisites</div>
<div class="line">    gcc -c $&lt; -o $@ $(CFLAGS)</div>
<div class="line">    └──────────┬────────────┘</div>
<div class="line">               │</div>
<div class="line">            action</div>
</div><!-- fragment --><ul>
<li><code>$&lt;</code> &ndash; the <b>first</b> file in the list of <code>pre-requisites</code></li>
<li><code>$^</code> &ndash; <b>all</b> the files in the list of <code>pre-requisites</code></li>
<li><code>$@</code> &ndash; the <code>target</code></li>
</ul>
<p>*<code>target</code> and <code>pre-requisites</code> use symbol <code>%</code>*</p>
<div class="fragment"><div class="line">  target───┐  pre-requisites ──┐</div>
<div class="line">           │                   │</div>
<div class="line">           │  ┌────────────────┴─────┐</div>
<div class="line">../build/%.o: ../code/%.c ../code/%.h</div>
</div><!-- fragment --><p>The <code>%</code> captures the <b>stem</b>, thereby generalizing this for all of the <code>../mock-c/build/</code> object files.</p>
<p>For example, if <code>../mock-c/build/Mock.o</code> does not exist, <code>make</code> finds the above recipe because it matches the pattern <code>../mock-c/build/%.o</code>.</p>
<p>In this example, the <b>stem</b> is <code>Mock</code>, so when make needs to create <code>Mock.o</code>, it expands the recipe into this:</p>
<div class="fragment"><div class="line">../mock-c/build/Mock.o: ../mock-c/code/Mock.c ../mock-c/code/Mock.h ../mock-c/code/unity_internals.h</div>
<div class="line">    gcc -c ../mock-c/code/Mock.c -o ../mock-c/build/Mock.o -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include</div>
</div><!-- fragment --><p>The <code>CFLAGS</code> are in addition to whatever compiler flags your build script already has. The example only shows the compiler flags necessary to compile <b>mock-c</b>:</p>
<div class="fragment"><div class="line">CFLAGS := -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include</div>
</div><!-- fragment --><p>The <code>-Ipath</code> flag tells the compiler where to search for header files, so the above tells the compiler where to find your computer's <code>glib</code> headers. I detail how to install <b>GLib</b> and how to determine these flags <a href="README.md#glib">later</a>. The <code>-Ipath</code> flags in the example above show the default POSIX install path for <b>GLib</b>.</p>
<p>The <b>mock-c</b> source code has <code>#include &lt;glib.h&gt;</code>, but this repository does not include <b>GLib</b> source code and does not include pre-compiled <b>GLib</b> libraries. I treat <code>glib.h</code> as a system header, so these <code>-I</code> flags are necessary for the compiler to find the <b>GLib</b> headers on your system.</p>
<h2><a class="anchor" id="autotoc_md53"></a>
Linking mock-c</h2>
<p>Unit test code will <code>#include &lt;mock-c.h&gt;</code>. Tell the compiler where to search for this header file:</p>
<div class="fragment"><div class="line">-I../mock-c/code</div>
</div><!-- fragment --><p>The test runner executable links with the <b>mock-c</b> object files. Tell the linker where to search for these object files:</p>
<div class="fragment"><div class="line">-L../mock-c/build</div>
</div><!-- fragment --><p>The <b>mock-c</b> object files refer to symbols in the <b>GLib</b> libraries. Tell the linker which libraries to search to find definitions of the <b>GLib</b> symbols:</p>
<div class="fragment"><div class="line">-lglib-2.0 -lintl</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md54"></a>
Example recipe for a unit test application</h2>
<p>Putting that all together, here is my project's recipe for writing test results to a markdown file:</p>
<div class="fragment"><div class="line">CFLAGS := -I../mock-c/code \</div>
<div class="line">    -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include \</div>
<div class="line">    -g -Wall -Wextra -pedantic</div>
<div class="line">LFLAGS := -lglib-2.0 -lintl</div>
<div class="line"> </div>
<div class="line">build/test_runner.md: build/test_runner.exe</div>
<div class="line">    $&lt; &gt; $@</div>
<div class="line"> </div>
<div class="line">build/test_runner.exe: tests/test_runner.c test_Blah1.c test_Blah2.c \</div>
<div class="line">                        ../mock-c/build/unity.o \</div>
<div class="line">                        ../mock-c/build/Mock.o ../mock-c/build/ReturnValues.o \</div>
<div class="line">                        ../mock-c/build/RecordedArg.o ../mock-c/build/RecordedCall.o</div>
<div class="line">    gcc $(CFLAGS) $^ -o $@ $(LFLAGS)</div>
<div class="line"> </div>
<div class="line">../mock-c/build/%.o: ../mock-c/code/%.c ../mock-c/code/%.h ../mock-c/code/unity_internals.h</div>
<div class="line">    gcc -c $&lt; -o $@ $(CFLAGS)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md55"></a>
Example usage in a test</h1>
<p>TODO(sustainablelab): Document how to use this thing</p>
<h1><a class="anchor" id="autotoc_md56"></a>
About mock-c</h1>
<p><b>mock-c</b> is entirely in C, no C++. I'd like to make it dependency-free one day, but for now it requires <b>GLib</b>.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
mock-c is built on top of these libraries</h2>
<ul>
<li><a href="https://github.com/ThrowTheSwitch/Unity">Unity Test</a> by ThrowTheSwitch<ul>
<li>a three-file library targeting unit tests for embedded systems</li>
</ul>
</li>
<li><a href="https://developer.gnome.org/glib/unstable/">GLib</a> from GNOME.org<ul>
<li>this is a <b>big</b> library that gives C "modern" types</li>
<li>I'm using it for strings and lists (doubly-linked lists):<ul>
<li><a href="https://developer.gnome.org/glib/unstable/glib-Strings.html">GString</a></li>
<li><a href="https://developer.gnome.org/glib/unstable/glib-Doubly-Linked-Lists.html">GList</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md58"></a>
Unity Test</h2>
<p>Unity Test is just three source files:</p>
<ul>
<li><code><a class="el" href="unity_8c_source.html">code/unity.c</a></code></li>
<li><code><a class="el" href="unity_8h_source.html">code/unity.h</a></code></li>
<li><code><a class="el" href="unity__internals_8h_source.html">code/unity_internals.h</a></code></li>
</ul>
<p>There is nothing to install, no linker flags to add to the build recipe.</p>
<h3>Slightly modified Unity Test</h3>
<p>I modified <b>Unity Test</b> to make the setup and teardown functions into function pointers. That is the version of <b>Unity Test</b> included in this repository.</p>
<p>TODO(sustainablelab): Show my specific changes to Unity Test</p>
<h3>Unity Test License</h3>
<p>The original <a class="el" href="md_mock_c_LICENSE_Unity_Test.html">**Unity Test** license</a> is included in this repository, as required by the standard MIT license.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
GLib</h2>
<ol type="1">
<li><p class="startli">Install <code>GLib</code>.</p>
<p class="startli">Either download a tarball from here:</p>
<p class="startli"><a href="https://developer.gnome.org/glib/">https://developer.gnome.org/glib/</a></p>
<p class="startli">Or use your package manager. For example, here is the installation using the command-line version of Cygwin's package manager:</p>
</li>
</ol>
<div class="fragment"><div class="line">$ apt-cyg install libglib2.0-devel libglib2.0-doc</div>
</div><!-- fragment --><ol type="1">
<li><p class="startli">Determine the compiler and linker flags to add to your build recipe.</p>
<p class="startli">This is explained here:</p>
<p class="startli"><a href="https://developer.gnome.org/glib/2.66/glib-compiling.html">https://developer.gnome.org/glib/2.66/glib-compiling.html</a></p>
<p class="startli">TLDR, do this:</p>
</li>
</ol>
<div class="fragment"><div class="line">$ pkg-config --libs glib-2.0</div>
<div class="line">-lglib-2.0 -lintl</div>
<div class="line"> </div>
<div class="line">$ pkg-config --cflags glib-2.0</div>
<div class="line">-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include</div>
</div><!-- fragment --><ol type="1">
<li><p class="startli">Test that <code>glib</code> is installed.</p>
<p class="startli"><em>Create a file to compile that depends on glib:</em></p>
</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// code/test-glib-install.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;glib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    GString *msg = g_string_new(<span class="stringliteral">&quot;Congratulations! GLib is installed.&quot;</span>);</div>
<div class="line">    puts(msg-&gt;str);</div>
<div class="line">    g_string_free(msg, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>Create a makefile:</em></p>
<div class="fragment"><div class="line">CFLAGS := -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include</div>
<div class="line">LFLAGS := -lglib-2.0 -lintl</div>
<div class="line"> </div>
<div class="line">../build/test-glib-install.exe: test-glib-install.c</div>
<div class="line">    gcc $(CFLAGS) $&lt; -o $@ $(LFLAGS)</div>
<div class="line">    ../build/test-glib-install.exe</div>
</div><!-- fragment --><ul>
<li>The CFLAGS are necessary for the compiler to find <code>glib.h</code> and the files that get included by <code>glib.h</code><ul>
<li>in the above example,. the <code>GString</code> datatype is defined in <code>gstring.h</code></li>
<li>the <code>-I</code> flags tell the compiler which directories to search for header files</li>
</ul>
</li>
<li>The LFLAGS are necessary for the linker to find the definitions of the <code>glib</code> symbols<ul>
<li>in the above example, the definitions for functions <code>g_string_new</code> and <code>g_string_free</code> are in pre-compiled libraries</li>
<li>the <code>-l</code> flags tell the linker which libraries to search when linking</li>
</ul>
</li>
</ul>
<p><em>Build:</em></p>
<div class="fragment"><div class="line">$ make</div>
<div class="line">../build/test-glib-install.exe</div>
<div class="line">Congratulations! GLib is installed.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md60"></a>
Building up the Makefile for unit tests</h2>
<p><code>unity.o</code> builds quickly. If there are no other object files to link, then there is no need for conditional builds. So the Makefile would boil down to one recipe:</p>
<div class="fragment"><div class="line">../build/test_runner.exe: test_runner.c ../code/unity.c ../code/unity.h ../code/unity_internals.h</div>
<div class="line">    gcc $(CFLAGS) test_runner.c ../code/unity.c -o $@ $(LFLAGS)</div>
</div><!-- fragment --><p>But once there are several object files to link, the build goes much faster if the object files do not have to rebuild every time (based on my experience using <code>gcc</code> in Cygwin).</p>
<p>So the <code>make</code> recipe splits into two recipes:</p>
<div class="fragment"><div class="line">../build/test_runner.exe: test_runner.c ../build/unity.o</div>
<div class="line">    gcc $(CFLAGS) $^ -o $@ $(LFLAGS)</div>
<div class="line"> </div>
<div class="line">../build/unity.o: ../code/unity.c ../code/unity.h ../code/unity_internals.h</div>
<div class="line">    gcc -c $&lt; -o $@ $(LFLAGS)</div>
</div><!-- fragment --><p><em>I explained earlier <a href="README.md#reading-makefile-recipes">what the cryptic symbols mean</a>.</em></p>
<p>The first recipe says:</p>
<ul>
<li><code>test_runner.exe</code> depends on <code>test_runner.c</code> and on the pre-compiled object file <code>../build/unity.o</code></li>
</ul>
<p>The idea is that the <code>test_runner.c</code> file is changing as tests are edited, but the source files in the compilation unit for <code>unity.o</code> are not going to change often.</p>
<p>Therefore, there is no point rebuilding <code>unity.o</code> every time <code>test_runner.exe</code> is built. <code>unity.o</code> is only rebuilt if any of the <code>unity</code> source files change. And if that happens, <code>make</code> detects that <code>unity.o</code> is out-of-date and rebuilds <code>unity.o</code> before building <code>test_runner.exe</code>.</p>
<p>This is captured in the second recipe:</p>
<ul>
<li>build <code>unity.o</code> by compiling <code><a class="el" href="unity_8c_source.html">unity.c</a></code></li>
<li>the trigger to rebuild <code>unity.o</code> is to check if <code><a class="el" href="unity_8c_source.html">unity.c</a></code> or either of its header files change.</li>
</ul>
<p>The point of splitting into two recipes is that there are several object files, not just <code>unity.o</code>. To handle any object file, the second recipe turns into this:</p>
<div class="fragment"><div class="line">../build/%.o: ../code/%.c ../code/unity.h ../code/unity_internals.h</div>
<div class="line">    gcc -c $&lt; -o $@ $(CFLAGS)</div>
</div><!-- fragment --><p>The idea is that <code>test_runner.exe</code> is built by linking <code>test_runner.o</code> with <em>many</em> object files, not just <code>unity.o</code>. This revised recipe is generalized for making a <code>foo.o</code> in the <code>build</code> folder from any <code>foo.c</code> in the <code>code</code> folder. If changes to a header file should trigger a rebuild, those header files get added to the list of prerequisites.</p>
<p>Finally, here is the actual make recipe for the unit tests that test <code>mock-c</code>. There are several object files to link with and the "main" source code is divided into several files.</p>
<div class="fragment"><div class="line">../build/test_runner.exe: test_runner.c ExampleCalls.c test_ExampleCalls.c \</div>
<div class="line">                        test_Mock.c test_ReturnValues.c \</div>
<div class="line">                        test_RecordedArg.c test_RecordedCall.c \</div>
<div class="line">                        ../build/unity.o \</div>
<div class="line">                        ../build/Mock.o ../build/ReturnValues.o \</div>
<div class="line">                        ../build/RecordedArg.o ../build/RecordedCall.o</div>
<div class="line">    gcc $(CFLAGS) $^ -o $@ $(LFLAGS)</div>
<div class="line"> </div>
<div class="line">../build/%.o: ../code/%.c ../code/%.h ../code/unity_internals.h</div>
<div class="line">    gcc -c $&lt; -o $@ $(CFLAGS)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md61"></a>
More explanation about what this is</h1>
<p>To "mock" a function is to stub it with a <b>fake</b> version that records when (in the call order) it was called and what arguments it was called with.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
TDD terminology</h2>
<p>TDD (Test Driven Development) is a rabbit-hole, so instead of expecting you to look this stuff up and reconcile contradictory definitions, I will just say what I mean when I use these words <em>stub</em>, <em>fake</em>, and <em>mock</em>:</p>
<ul>
<li>A <em>stub</em> replaces a function with a dummy version that still compiles but has zero functionality. This is what I use 99% of the time. The common use case is testing a function that calls functions that wait on the embedded hardware.</li>
<li>A <em>fake</em> is a <em>stub</em> that adds fake functionality for the purposes of the test, for example giving the unit test control over the value returned by the function so that the unit test can test a scenario where the function returns a particular value. The return value is "faked".</li>
<li>A <em>mock</em> is where the fake functionality is to record how the function was called. And maybe it does other fake functionality too, like the return value thing. This kind of fake gets a special name simply because <b>it's more difficult to implement this particular fake functionality</b>.</li>
</ul>
<p>TLDR: Mocking is for the <em>small</em> subset of unit tests where the goal is to check whether the function under test is calling other functions and calling them with the correct arguments.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Reinventing wheels</h2>
<p>How do you implement mocking? People do lots of complicated things to mock functions. Everything I found was too complicated for me to get it working. So I came up with my own way.</p>
<p>The mocks record themselves in a global list setup by the test suite (the test suite is the application that calls all the unit tests). This global list is erased before each unit test.</p>
<p>When the function under test calls fake functions, the fake function writes its name and its arguments to the global list. The test is to compare the expected list of calls against what was recorded in the global list and identify where something unexpected happened.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Avoid mocking as much as possible</h2>
<p>In practice, the source code definition of the function under test gets bracketed with macros that rename functions with a <code>Fake</code> suffix. <b>Those macros add noise to the source code.</b></p>
<p>It's possible to eliminate these macros using function pointers, and that is exactly how <b>mock-c</b> started out. But when speed matters, the function pointer approach adds extra operations to load the function. Speed matters in embedded systems. I think it's a mistake to sacrifice speed in support of 100% unit test coverage (i.e., if every function used a function pointer because every function was mocked because that's the only way to true 100% test coverage). Furthermore, in my particular case writing C for 8-bit AVR microcontrollers, the function pointer approach prevented <b>avr-gcc</b> from choosing the optimal assembly instructions.</p>
<p><b>Mocking also generates a lot of extra code (i.e, project code that is not running on the target)</b>. This extra code takes time to maintain. When the function's argument types change, the definition of the fake needs to change, and all the tests that are checking the arguments needs to change. The main benefit of TDD is that it <em>lowers</em> the barrier to changing code. So if hitting 100% test coverage means I'm more hesitant to change the code (because of this enormous ripple effect throughout the tests), then it defeats the main reason for doing TDD in the first place. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
