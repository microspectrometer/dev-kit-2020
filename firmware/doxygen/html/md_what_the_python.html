<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>firmware: Goal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Chromation_colored.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">firmware
   &#160;<span id="projectnumber">v0.1.2</span>
   </div>
   <div id="projectbrief">Chromation Spectrometer Dev-Kit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Goal </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md208"></a>
Context</h1>
<p>I add sensor S13131 to the firmware by creating builds dependent on the definition of compiler flag <code>sensor</code>:</p>
<ul>
<li><code>sensor=LIS</code> defines macro <code>LIS</code></li>
<li><code>sensor=S13131</code> defines macro <code>S13131</code></li>
</ul>
<p>I must use different <code>vis-spi-out</code> builds for S13131 and LIS. The <code>vis-spi-out</code> code is full of macro conditionals to decide which version of the code to build.</p>
<p>I want to use the same <code>usb-bridge</code> build, regardless of the sensor. The motivation is to avoid having to re-flash the <code>usb-bridge</code> when switching sensors. The usb-bridge has <em>nothing to do</em> with the sensor, so in theory this should be no problem.</p>
<p>Can I do this?</p>
<h1><a class="anchor" id="autotoc_md209"></a>
Issue</h1>
<p>The issue is that there are two commands, GetSensorConfig and SetSensorConfig which do not apply to S13131.</p>
<p>I handle this on <code>vis-spi-out</code> by a macro that conditionally includes these commands only if the compiler defines <code>LIS</code>. Therefore, when <code>sensor=S13131</code>, the compiler omits these commands from the switch-case block. So the response to an unknown command is the switch block's default case. <code><a class="el" href="vis-spi-out_8c.html">vis-spi-out.c</a></code> has no default case in the switch block, so <code>vis-spi-out</code> does nothing if it receives an unknown command ID.</p>
<p><em>TODO: <code><a class="el" href="usb-bridge_8c.html" title="FT_Prog Hardware Settings">usb-bridge.c</a></code> has a default cause that just says <code>break</code> &ndash; so I have the same behavior expressed two different ways, which is not cool. Either do the same in <code>vis-spi-out</code> or erase the <code>default</code> case in <code>usb-bridge</code>.</em></p>
<h1><a class="anchor" id="autotoc_md210"></a>
Question</h1>
<p><code><a class="el" href="usb-bridge_8c.html" title="FT_Prog Hardware Settings">usb-bridge.c</a></code> also does <em>nothing</em> if it receives an unknown command ID.</p>
<p><b>How does <code>microspeclib</code> magically determine the command is invalid?</b></p>
<h1><a class="anchor" id="autotoc_md211"></a>
Answer</h1>
<p>My bad: I only changed the command ID in the "command" protocol. I forgot to change the command ID in the "bridge" protocol.</p>
<p><code>microspeclib</code> was catching this before sending any command out.</p>
<p>Once I fixed that, then the unknown command simply timeouts.</p>
<h2><a class="anchor" id="autotoc_md212"></a>
Experiment</h2>
<p>Here is my experiment:</p>
<ul>
<li>I change the command ID of the SetBridgeLED command:<ul>
<li><em>was:</em> protocol.command.2</li>
<li><em>change to:</em> protocol.command.22</li>
</ul>
</li>
<li>Try sending the SetBridgeLED command:</li>
</ul>
<div class="fragment"><div class="line">&gt;&gt;&gt; kit = usp.Devkit()</div>
<div class="line">&gt;&gt;&gt; kit.setBridgeLED(led_setting=1)</div>
<div class="line">2021-03-11 17:17:43,649:stream.py:receiveReply:100: Command ID not recognized: 22</div>
<div class="line">...</div>
</div><!-- fragment --><p>That line, "Command ID not recognized" prints over and over about 150 times (the exact amount varies). But it starts printing this instantly, so it has nothing to do with the timeout.</p>
<p>As the next section shows, <code>microspeclib</code> determines this is an invalid command before sending <em>anything</em> to the devkit, so my experiment is flawed. I naively changed the command ID only in the <code>protocol.command</code>. My mistake is that I did not also change the command ID in <code>protocol.bridge</code>.</p>
<h3>Follow the chain</h3>
<p>Start by finding the file that throws the error message.</p>
<div class="fragment"><div class="line">:find stream.py</div>
</div><!-- fragment --><p>Here it is: <code>microspec/src/microspeclib/internal/stream.py</code></p>
<p>Now look up the definition of <code>receiveReply</code>.</p>
<p><code>receiveReply()</code> takes <code>command_id</code> (22) and attempts to create a <code>bridge_klass</code> and a <code>sensor_klass</code> to interpret the firmware response:</p>
<div class="fragment"><div class="line"># internal/stream.py:receiveReply</div>
<div class="line">    def receiveReply(self, command_id):</div>
<div class="line">        ...</div>
<div class="line">        bridge_klass = getBridgeReplyByID(command_id)</div>
<div class="line">        ...</div>
<div class="line">        if not bridge_klass:</div>
<div class="line">          log.error(&quot;Command ID not recognized: %s&quot;, command_id)</div>
<div class="line">          return None</div>
</div><!-- fragment --><p>I am clearly following the branch shown above.</p>
<p>TODO(sustainablelab): Handle <code>None</code> reply in <code>microspec.commands.py</code>. Put in a useful message, like:</p>
<blockquote class="doxtable">
<p>Reply is None, but expected blah. See microspec.json. Maybe blah command command ID in protocol "command" does not match blah command command ID in protocol "bridge". </p>
</blockquote>
<p>This is the response I get now:</p>
<div class="fragment"><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div>
<div class="line">  File &quot;c:\cygwin64\home\mike\.local\lib\python3.7\site-packages\microspec\src\microspec\commands</div>
<div class="line">.py&quot;, line 327, in setBridgeLED</div>
<div class="line">    status = status_dict.get(_reply.status)</div>
<div class="line">AttributeError: &#39;NoneType&#39; object has no attribute &#39;status&#39;</div>
<div class="line"> </div>
<div class="line">&#39;NoneType&#39; object has no attribute &#39;status&#39;</div>
</div><!-- fragment --><p><code>getBridgeReplyByID</code> is defined in <code>datatypes/bridge.py</code>. It looks up the command ID using: <code>CHROMASPEC_SERIAL_ID.get()</code></p>
<div class="fragment"><div class="line"># datatypes/bridge.py:getBridgeReplyByID</div>
<div class="line">    def getBridgeReplyByID(cid):</div>
<div class="line">        ...</div>
<div class="line">        com = CHROMASPEC_SERIAL_ID.get(cid)</div>
<div class="line">        ...</div>
<div class="line">        return com</div>
</div><!-- fragment --><p>*<code>get()</code> is a Python built-in method for dictionaries. It returns the value for a given key. So the command ID (22) is being used as the key for the dictionary. And the value is stored in <code>com</code>. When <code>get</code> uses a missing key, it returns <code>None</code> instead of raising a <code>KeyError</code>.*</p>
<p>That dictionary, <code>CHROMASPEC_SERIAL_ID</code>, is defined by <code>enclassJsonFile()</code>:</p>
<div class="fragment"><div class="line"># datatypes/bridge.py</div>
<div class="line">CHROMASPEC_SERIAL_ID, CHROMASPEC_SERIAL_NAME = enclassJsonFile(&quot;microspec.json&quot;, &quot;bridge&quot;)</div>
</div><!-- fragment --><p><code>enclassJsonFile()</code> opens <code>microspec.json</code> and looks up the <code>protocol</code>. Default is <code>protocol="command"</code>. In the above example <code>protocol="bridge"</code>.</p>
<div class="fragment"><div class="line"># internal/jsonparse.py:enclassJsonFile</div>
<div class="line">def enclassJsonFile(filename, protocol=&quot;command&quot;):</div>
<div class="line">  log.info(&quot;filename=%s protocol=%s&quot;, filename, protocol)</div>
<div class="line">  with open(findConfig(filename)) as f:</div>
<div class="line">    j      = json.load(f)</div>
<div class="line">    p      = j[&quot;protocol&quot;][protocol]</div>
<div class="line">    byID   = {}</div>
<div class="line">    byName = {}</div>
<div class="line">    log.debug(&quot;raw json=%s&quot;, j)</div>
<div class="line">    log.debug(&quot;raw json protocol section=%s&quot;, p)</div>
<div class="line">    for k, v in p.items():</div>
<div class="line">      log.debug(&quot;k=%s v=%s&quot;, k, v)</div>
<div class="line">      c = cfactory(protocol, int(k), protocol.capitalize()+p[k][&quot;name&quot;], </div>
<div class="line">                   p[k][&quot;variables&quot;], p[k][&quot;sizes&quot;], p[k].get(&quot;repeat&quot;,None))</div>
<div class="line">      byID[c.command_id] = c</div>
<div class="line">      byName[c.name] = c</div>
<div class="line">  log.info(&quot;return %s, %s&quot;, byID, byName)</div>
<div class="line">  return byID, byName</div>
</div><!-- fragment --><p>The important player above is <code>cfactory</code>. This is a shortened name for <code>MicroSpecPayloadClassFactory</code>:</p>
<div class="fragment"><div class="line"># internal/payload.py:MicroSpecPayloadClassFactory</div>
<div class="line">def MicroSpecPayloadClassFactory(protocol, command_id, name, variables, sizes, repeat=None):</div>
<div class="line">  log.info(&quot;protocol=%s command_id=%d name=%s variables=%s sizes=%s repeat=%s&quot;, </div>
<div class="line">           protocol, command_id, name, variables, sizes, repeat)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md213"></a>
Simple timeout is no good</h1>
<p>A timeout to an unrecognized command is problematic when the unrecognized command contains arguments and those arguments alias to other commands.</p>
<p>For example, I send <code>kit.setBridgeLED(led_setting=usp.GREEN)</code>. This sends <code>kit.setBridgeLED(led_num=0, led_setting=1)</code> which translates to three bytes: <code>{0x02,0x00,0x01}</code>.</p>
<p>If I change the command ID from to 2 to 22 (0x16), I'm sending: <code>{0x16,0x00,0x01}</code>. The first byte is unrecognized, but <code>microspeclib</code> sends all three.</p>
<p>The Python UI timeouts.</p>
<p>Meanwhile, the firmware on <code>usb-bridge</code>:</p>
<ul>
<li>ignores <code>0x16</code></li>
<li>treats <code>0x00</code> as <code>Null</code></li>
<li>treats <code>0x01</code> as the <code>GetBridgeLED</code> command</li>
</ul>
<p>Now <code>usb-bridge</code> is waiting for <code>led_num</code>.</p>
<p>Now I send <code>kit.getBridgeLED()</code> which sends <code>kit.getBridgeLED(0)</code> which sends <code>{0x01, 0x00}</code>.</p>
<p>So <code>usb-bridge</code>:</p>
<ul>
<li>treats <code>0x01</code> as the led number<ul>
<li>there is no LED 1, only LED 0 on the bridge, so <code>usb-bridge</code> returns an ERROR</li>
</ul>
</li>
<li>treats <code>0x00</code> as the <code>Null</code> command<ul>
<li>there is no response to the <code>Null</code> command, so no other bytes are sent back</li>
</ul>
</li>
</ul>
<p>This is what the UI shows for that whole sequence:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; kit.setBridgeLED(led_setting=1)</div>
<div class="line">Traceback (most recent call last):</div>
<div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div>
<div class="line">  File &quot;c:\cygwin64\home\mike\.local\lib\python3.7\site-packages\microspec\src\microspec\commands</div>
<div class="line">.py&quot;, line 327, in setBridgeLED</div>
<div class="line">    status = status_dict.get(_reply.status)</div>
<div class="line">AttributeError: &#39;NoneType&#39; object has no attribute &#39;status&#39;</div>
<div class="line"> </div>
<div class="line">&#39;NoneType&#39; object has no attribute &#39;status&#39;</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; kit.getBridgeLED()</div>
<div class="line">getBridgeLED_response(status=&#39;ERROR&#39;, led_setting=None)</div>
</div><!-- fragment --><p>The bottom line is the firmware gets into a weird state if it simply ignores unrecognized commands that have arguments. There is nothing to be done about that. The Python host has already sent all those arguments.</p>
<p>The thing to fix here is that the Python host needs to <em>know</em> when the firmware is in a weird state. If the host knows, then it can kick the firmware back into a good state with <code>kit.flush()</code>.</p>
<p>If the host assumes a timeout is a weird state, then the host can send <code>kit.null()</code> to flush the serial line. A <code>null</code> is needed for each expected argument.</p>
<p>This is doable, the trouble is 1) recognizing the timeout and 2) waiting long enough for all the responses to come back before flushing the serial line (otherwise there are old responses from the dev-kit sitting in the read buffer).</p>
<p>The question is do I just code dummy responses to GetSensorConfig/SetSensorConfig and call it a day, or do I deal with the fact we never coded dealing with invalid commands.</p>
<p>This is where the Python class factory magic sucks. If I was adding a new command, that's fine. That's great. That's when this is wonderful. But instead I'm adding a core functionality that was left out, so I really have to understand what Sean did.</p>
<p>Actually, looking at <em>my own documentation</em> it looks like we abandoned the idea of an <code>INVALID_COMMAND</code> code and instead decided to return an <code>ERROR</code> code if the command is not recognized.</p>
<p>So I all I have to do is return ERROR if the command is not recognized?</p>
<p>OK, so I added this to usb-bridge. It added 2 bytes to the .elf. Fantastic.</p>
<p>And now, as expected, the host doesn't have to wait for a timeout. An invalid command immediately gets an ERROR. But a flush() doesn't fix the problem. The null sent with flush acts as the argument to the misinterpreted command (the argument to the invalid command that gets interpreted as a command).</p>
<p>This is the price I pay for not having a proper packet structure for the data.</p>
<p>Maybe after an ERROR, I should have the firmware ignore any further received bytes until a Null is sent? The problem with this scheme is that an argument could very well have the same value as the Null command.</p>
<p>Best thing I can come up with is to have Python respond to an ERROR by sending kit.null() N times, where N is the largest number of arguments we have. Follow this by <code>kit.serial.read_until()</code>. That waits until bytes are available, until a timeout occurs, or until a newline is received.</p>
<p>So one thing I could do is add a "packet over" byte. Then <code>read_until()</code> could have something to look for.</p>
<p>Nah, that will have weird corner case bugs.</p>
<p>Better to write my own version of <code>read_until</code>().</p>
<p>hardcode timeout to 0.1s using the Timeout class in serialutil.py</p>
<p>In micropsec.commands add this:</p>
<p>if response to a command is ERROR, send N null commands, then do a <code>read_until_timeout</code> that just reads the read buffer until the timer expires.</p>
<p>Hah, so I set this up, then realized I didn't need it. I left it in the microspec.commands code, but I just don't call it yet. Instead, I implemented what I specifically need now:</p>
<p><code>usb-bridge</code> checks if <code>vis-spi-out</code> returns ERROR to getSensorConfig. In this case <code>usb-bridge</code> returns PADDING for the other bytes, and <code>microspec</code> issues a warning that the dev-kit firmware didn't recognize the command, probably because there's a different detector in the kit.</p>
<p>[ ] Apply this same fix to SetSensorConfig. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
