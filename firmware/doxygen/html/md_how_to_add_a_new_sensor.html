<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>firmware: how-to-add-a-new-sensor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Chromation_colored.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">firmware
   &#160;<span id="projectnumber">v0.1.2</span>
   </div>
   <div id="projectbrief">Chromation Spectrometer Dev-Kit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">how-to-add-a-new-sensor </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Steps to add a new sensor to the dev-kit codebase.</p>
<p><em>Instead of maintaining separate projects for the LIS and S13131, there is a single firmware folder. When make is invoked, the optional <code>sensor=</code> argument controls which version of the firmware is built.</em></p>
<h1><a class="anchor" id="autotoc_md18"></a>
Hardware changes</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
Match the ZIF pins</h2>
<p>Designing the sensor breakout board, map the ZIF pins to match as close as possible.</p>
<p><em>If the sensors are very different, the <code>vis-spi-out</code> board needs to change as well.</em></p>
<h3>S13131-512 signals are similar to the LIS-770i</h3>
<p>We are lucky with the LIS-770i and S13131-512. They have very similar functionality in the analog and digital pins. No change is required to the <code>vis-spi-out</code> PCB.</p>
<h3>Six signals on LIS-770i have perfect matches on S13131</h3>
<p>For the six signals that have perfect matches, I route the six S13131 signals to those same six ZIF pins:</p>
<ul>
<li>Power and Ground are the same</li>
<li>VIDEO is the same</li>
<li>CLK is the same</li>
<li>RST on LIS-770i is ST on S13131</li>
<li>SYNC on LIS-770i is EOS on S13131</li>
</ul>
<h3>Remaining signals that don't match are not needed</h3>
<p>For the remainder, we just get lucky:</p>
<ul>
<li>analog pins:<ul>
<li>The VREF pin is particular to the LIS-770i, but the <code>vis-spi-out</code> analog front end expects a VREF, so I make my own VREF on the S13131 breakout board.</li>
<li>The Vcp pin on S13131 just needs an external capacitor for the internal voltage boost circuit. Vcp does not connect to the ZIF.</li>
</ul>
</li>
<li>digital pins:<ul>
<li>The PIXSELECT pin is particular to the LIS-770i, so this ZIF pin is left as NC (not-connected) on the S13131 breakout board.</li>
<li>the TRIG pin on S13131 does not help us because it is just CLK inverse; the same microcontroller that generates CLK also does readout, so it's simpler to look at CLK internally than it is to trigger off of the TRIG signal</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md20"></a>
Describe exposure</h2>
<p>Look at the datasheet and describe the relationship between the CLK signal and the microcontroller output that controls exposure time.</p>
<h3>S13131 exposure signals</h3>
<ul>
<li>ST idles LOW</li>
<li>ST goes HIGH to start exposure<ul>
<li>Bring ST HIGH some time prior to a CLK rising edge (easiest is to bring ST HIGH just after a CLK falling edge)</li>
<li>Integration time officially starts on the 3rd CLK rising edge with ST HIGH<ul>
<li>the time period from that 3rd rising edge to the 4th rising edge marks the first cycle of exposure time</li>
</ul>
</li>
</ul>
</li>
<li>ST goes LOW to end exposure<ul>
<li>Bring ST LOW some time prior to a CLK rising edge (against, easiest is to do this just after a CLK falling edge)</li>
<li>Integration time officially stops on the 9th CLK rising edge with ST LOW</li>
</ul>
</li>
</ul>
<p>This implies that the <b>minimum</b> integration time is <b>9 clocks</b>. At 50kHz, each clock is 20µs, so <b>minimum</b> integration time is 180µs.</p>
<p>Example showing minimum exposure time:</p>
<div class="fragment"><div class="line">  ┌─── Count all rising edges of CLK starting with first ST HIGH</div>
<div class="line">  │ ┌─ Count rising edges of CLK where ST is LOW</div>
<div class="line">  ↓ ↓</div>
<div class="line"> (x,y)</div>
<div class="line">Exposure clocks -------&gt; 1,0   2,0   3,0   4,1   5,2   6,3   7,4   8,5   9,6   10,7  11,8  12,9</div>
<div class="line">        ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐</div>
<div class="line"> CLK    │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │</div>
<div class="line">      ──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └</div>
<div class="line">                          ↑           ↑     ↑  ↑                                            ↑</div>
<div class="line">     ST HIGH clocked-in: ─┘           │     │  │                                            │</div>
<div class="line">                     exposure START: ─┘     │  │                            exposure STOP: ─┘</div>
<div class="line">                        ST LOW clocked-in: ─┘  │                   on 9th CLK rising-edge</div>
<div class="line">                                               │                              with ST LOW</div>
<div class="line">                        ┌─────────────────┐    │</div>
<div class="line"> ST       IDLE LOW      │                 │    ↓</div>
<div class="line">      ──────────────────┘                 └─────────────────────────────────────────────────────</div>
<div class="line">                        ↑                 ↑</div>
<div class="line">                        │                 │</div>
<div class="line">    Wait for CLK LOW    │                 │ </div>
<div class="line">      to pull ST HIGH: ─┘                 │</div>
<div class="line">                       Wait for CLK LOW   │</div>
<div class="line">                         to pull ST LOW: ─┘</div>
</div><!-- fragment --><p>In general, integration time is:</p>
<ul>
<li>The number of full clocks where ST is HIGH (ignoring high time prior to the third CLK rising edge that clocks in ST HIGH and ignoring high time after the last CLK rising edge that clocks in ST HIGH)</li>
<li>Plus, nine clock cycles</li>
<li>-&gt; Integration time is <b>ST HIGH plus six clocks</b></li>
<li>-&gt; Minimum <b>ST HIGH</b> time is two clocks (three rising edges)</li>
<li>-&gt; Minimum integration time is nine clocks (nine rising edges)</li>
</ul>
<h2><a class="anchor" id="autotoc_md21"></a>
Describe readout</h2>
<p>Look at the datasheet and describe the relationship between:</p>
<ul>
<li>the CLK signal and the microcontroller I/O involved in readout</li>
<li>the CLK signal and the VIDEO signal:<ul>
<li>want to know when the microcontroller should trigger a conversion on the ADC</li>
<li>want to know if we have enough time to do the ADC conversion before the next pixel is ready</li>
<li>want to know when the first pixel is ready for readout</li>
<li>want to know when readout of all pixels is done</li>
</ul>
</li>
</ul>
<h3>ADC conversion</h3>
<ul>
<li>ADC pin CONV goes high for about 4.5µs<ul>
<li>I think this is the time for the sample and hold</li>
<li>target time is 4.66µs</li>
<li>a blocking delay loop delays for a total of 45 10MHz ticks</li>
<li>that is 4.5µs</li>
<li>plus there's some small overhead for the loop</li>
</ul>
</li>
<li>ADC pin CONV goes low to enable SDO to shift out bits<ul>
<li>I think the successive approximation happens as the bits are being shifted out</li>
</ul>
</li>
<li>two dummy bytes are written to the UART SPI module to clock out the 16 bits of the ADC reading</li>
</ul>
<p>So the whole ADC sample-convert-and-readout is:</p>
<ul>
<li>about 5µs for sample-and-hold</li>
<li>plus 16 clocks of the 5MHz UART SPI clock for convert and readout</li>
</ul>
<p>5MHz is a 0.2µs period, so 16 periods is 3.2µs. The total time then is about 8.2µs.</p>
<p>Since CLK is 50kHz, one clock period is 20µs, so the time from the CLK falling edge to the next CLK rising edge is 10µs. And even if the ADC conversion took longer, it would be OK because nothing sensitive is happening on the CLK rising edge. As long as the SPI clock stops (i.e., the ADC readout is done) by the next CLK falling edge (and it definitely is), then there is no issue with the readout of the previous pixel interfering with the sampling of the next pixel.</p>
<h3>S13131 readout signals</h3>
<h4>Use CLK instead of TRIG</h4>
<ul>
<li>TRIG makes sense in a logic circuit (high-speed application)</li>
<li>TRIG is just extra work in a program (that's us)<ul>
<li>microcontroller generates CLK</li>
<li>microcontroller can detect and respond to a CLK falling edge by polling</li>
<li>this is much faster than using a pin interrupt to catch rising edges of TRIG (because of ISR overhead)</li>
</ul>
</li>
</ul>
<h4>Sample a pixel</h4>
<ul>
<li>Sample pixel voltage on the falling edge of CLK<ul>
<li>Sample on rising edges of TRIG</li>
<li>TRIG is the inverse of CLK</li>
</ul>
</li>
<li>CLK falling edge marks VIDEO valid<ul>
<li>VIDEO is guaranteed to be stable at this point</li>
</ul>
</li>
<li>VIDEO shifts to next pixel on CLK rising edge<ul>
<li>CLK rising edge marks VIDEO invalid</li>
</ul>
</li>
</ul>
<h4>Start readout</h4>
<ul>
<li>Define TRIG rising edge 1:<ul>
<li>Count 1 is the first TRIG rising edge with ST LOW</li>
</ul>
</li>
<li>Sample first pixel on TRIG rising edge 14</li>
<li>Translate this to CLK falling edges:<ul>
<li>Start counting CLK falling edges with ST LOW (after ST LOW has been "clocked in" with a CLK rising edge)</li>
<li>Sample first pixel on 14th CLK falling edge</li>
</ul>
</li>
</ul>
<h4>Finish readout EOS tabled</h4>
<p>The microcontroller has no problem counting from 1 to 512 to tell when the pixel readout finishes. And there is no concern that the S13131 might clock out some other number of pixels.</p>
<p>The main reason to check an End-of-scan signal is to verify that the microcontroller starts its pixel count at the correct clock edge.</p>
<p>Eventually, I will check EOS and code CaptureFrame to send an error message if the EOS signal came at an unexpected clock edge. But I table that functionality for now. So EOS is wired up and set up in firmware as an input pin, but I'm not doing anything with it.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Describe relationship between exposure and readout</h2>
<p>For example, on the LIS and S13131, readout must start when the exposure finishes. In other words, there is no option to expose and then wait some arbitrary time before reading out the pixel data. The internal logic in the detector is designed to immediately clock out the pixel voltages some fixed number of clocks after exposure ends.</p>
<h3>S13131 relationship between exposure and readout</h3>
<p>Exposure ends on the 9th CLK rising edge with ST LOW. Sample first pixel on the 14th CLK falling edge with ST LOW.</p>
<p>Therefore, readout always starts 13.5 clocks after ST LOW.</p>
<h3>Example expose and readout</h3>
<p>Here is an example showing ST HIGH for 3 clocks (4 CLK rising edges). This corresponds to an integration time of 10 clocks (200 µs).</p>
<div class="fragment"><div class="line">   Pixel count ---------------------------------------------------------------------------------------------------------------------&gt; 001---002-││511---512---</div>
<div class="line">                                                                                                                                      ┌──┌──┌──┌││┌──┌──┌──┌──</div>
<div class="line">                                                                                                                                      ↓  │--│  ││││  │--│  │--</div>
<div class="line">14th TRIG rising-edge (CLK falling-edge) with ST LOW: ────────────────────────────────────────────────────────────────────────────────┐  │--│  ││││  │--│  │--</div>
<div class="line">First TRIG rising-edge (CLK falling-edge) with ST LOW: ─┐                                                                             │  │--│  ││││  │--│  │--</div>
<div class="line">                                                        ↓                                                                             ↓  │--│  ││││  │--│  │--</div>
<div class="line">   Clocks waiting for readout to start ---------------&gt; 1     2     3     4     5     6     7     8     9     10    11    12    13    14 │--│  ││││  │--│  │--</div>
<div class="line">   Exposure clocks --------&gt; 1,0   2,0   3,0   4,0   5,1   6,2   7,3   8,4   9,5   10,6  11,7  12,8  13,9     ↓     ↓     ↓     ↓     ↓  ↓  ↓  ↓││↓  ↓  ↓  ↓  </div>
<div class="line">           ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌││┐  ┌──┐  ┌──</div>
<div class="line">    CLK    │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │  ││││  │  │  │  </div>
<div class="line">         ──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘││└──┘  └──┘  </div>
<div class="line">                             ↑           ↑           ↑  ↑                                            ↑</div>
<div class="line">        ST HIGH clocked-in: ─┘           │           │  │                                            │</div>
<div class="line">                        exposure START: ─┘           │  │                            exposure STOP: ─┘</div>
<div class="line">                                 ST LOW clocked-in: ─┘  │                   on 9th CLK rising-edge</div>
<div class="line">                                                        │                              with ST LOW</div>
<div class="line">                           ┌───────────────────────┐    │</div>
<div class="line">    ST       IDLE LOW      │                       │    ↓</div>
<div class="line">         ──────────────────┘                       └────────────────────────────────────────────────────────</div>
<div class="line">                           ↑                       ↑</div>
<div class="line">                           │                       │</div>
<div class="line">       Wait for CLK LOW    │    Wait for CLK LOW   │</div>
<div class="line">         to pull ST HIGH: ─┘      to pull ST LOW: ─┘</div>
</div><!-- fragment --><p><b>Always wait for CLK LOW as the cue to change ST.</b></p>
<p>It doesn't <em>really</em> matter if ST changes states just after a CLK LOW or a CLK HIGH. But it's more robust to code transitioning just after a CLK LOW.</p>
<p>This guarantees ST does not change until well-past the minimum hold time after CLK goes HIGH. The CLK frequency has to increase a lot before that gets dicy. There is no danger of CLK going too fast given the speed limit imposed by the ADC conversion rate.</p>
<p>(Transitioning ST just after CLK goes HIGH, on the other hand, ties the code to the MCU clock frequency &ndash; now I'd have to look closely at the number of MCU clock cycles consumed between detecting CLK HIGH and changing ST to make sure I'm not changing ST too soon.)</p>
<ul>
<li>"Pixel count"<ul>
<li>indicates when pixels are ready for sampling</li>
<li><code>number</code> indicates VIDEO is valid<ul>
<li>number is the literal pixel number being sampled by the ADC</li>
<li>sample-and-hold begins on the clock falling edge</li>
</ul>
</li>
<li><code>---</code> indicates VIDEO is invalid:<ul>
<li>ADC needs to finish sampling previous pixel by this time</li>
<li>ADC is not sampling next pixel yet</li>
<li>invalid period begins on the clock rising edge</li>
</ul>
</li>
</ul>
</li>
<li>"Exposure clocks"<ul>
<li>counts the number of CLK rising edges</li>
<li>two numbers separated by a comma:<ul>
<li>first number counts rising clock edges with <code>ST</code> HIGH<ul>
<li>on 3rd edge, integration time starts</li>
</ul>
</li>
<li>second number counts rising clock edges with <code>ST</code> LOW<ul>
<li>on 9th edge, integration time ends</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>"Clocks waiting for readout to start"<ul>
<li>counts the number of CLK falling edges</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md23"></a>
Firmware changes</h1>
<p>In the following I use the generic <code>sensor</code> in place of the actual sensor.</p>
<p><em>For the S13131 work, <code>sensor</code> is <code>S13131</code>.</em></p>
<h2><a class="anchor" id="autotoc_md24"></a>
lib/src/sensor.h</h2>
<p>Define <code>sensor_</code> types for registers addresses, pin numbers, and bit numbers.</p>
<p><em>Example:</em></p>
<div class="fragment"><div class="line"><span class="comment">// sensor_ ──────────────────────┐</span></div>
<div class="line"><span class="comment">//                               ↓</span></div>
<div class="line"><span class="keyword">typedef</span> uint8_t <span class="keyword">volatile</span> * <span class="keyword">const</span> s13131_ptr; <span class="comment">// reg address type</span></div>
</div><!-- fragment --><p>TODO(mike): <code>_ptr</code> is a poor choice of name, change this to <code>_reg</code></p>
<p>Name the registers, pins, and bit numbers. Declare registers, pins, and bit numbers as <code>extern</code>.</p>
<p><em>Example:</em></p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> s13131_ptr S13131_ddr;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
vis-spi-out/src/sensor-Hardware.h</h2>
<p>*<code>vis-spi-out</code> is the PCB design. This is where the hardware is. The hardware definitions, therefore, happen here.*</p>
<p><code><a class="el" href="vis-spi-out_8c.html">vis-spi-out.c</a></code> uses the sensor lib by including <code>Hardware.h</code>.</p>
<p><em>Sensor-related hardware values need to be defined in the compilation unit with <code><a class="el" href="vis-spi-out_8c.html">vis-spi-out.c</a></code>.</em></p>
<p>Include the <code>sensor-Hardware.h</code> file in <code><a class="el" href="vis-spi-out_2src_2Hardware_8h.html" title="vis-spi-out.c includes this file to pick up the -Hardware.h headers and AVR macros.">vis-spi-out/src/Hardware.h</a></code>.</p>
<p><em>Example:</em></p>
<div class="fragment"><div class="line"><span class="comment">// vis-spi-out/src/Hardware.h</span></div>
<div class="line"><span class="preprocessor"># include &quot;<a class="code" href="S13131-Hardware_8h.html">S13131-Hardware.h</a>&quot;</span></div>
<div class="ttc" id="aS13131-Hardware_8h_html"><div class="ttname"><a href="S13131-Hardware_8h.html">S13131-Hardware.h</a></div><div class="ttdoc">S13131 uses general purpose I/O pins and a PWM pin to communicate with the Hamamatu S13131-512 CMOS i...</div></div>
</div><!-- fragment --><p>In <code><a class="el" href="S13131-Hardware_8h.html" title="S13131 uses general purpose I/O pins and a PWM pin to communicate with the Hamamatu S13131-512 CMOS i...">S13131-Hardware.h</a></code>:</p>
<ul>
<li>assign registers, pins, and bits to actual hardware I/O values defined in AVR header <code>iom328p.h</code><ul>
<li>use types defined in <code>lib/src/sensor.h</code></li>
<li>use register, pin, and bit names declared in <code>lib/src/sensor.h</code></li>
</ul>
</li>
</ul>
<p><em>Example:</em></p>
<div class="fragment"><div class="line">s13131_ptr S13131_ddr    = &amp;DDRD;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md26"></a>
lib/test/sensor-HardwareFake.h</h2>
<p>*<code>lib/test/</code> is a test environment that fakes testing on the actual PCB. For testing purposes, this is where the hardware is. The hardware definitions, therefore, happen here.*</p>
<p><em>The hardware definitions are fake. The I/O register addresses are assigned to arbitrary addresses by the operating system. The read/write behavior of data in these fake I/O registers is the same, but the registers don't do anything (e.g., the fake DDRD register doesn't control the data-direction of an actual pin). The fake registers are just dummy memory on the computer running the test.</em></p>
<p><code>test_runner.c</code> includes fakes for the hardware values by including <code><a class="el" href="HardwareFake_8h_source.html">lib/test/HardwareFake.h</a></code></p>
<p><em>Example:</em></p>
<div class="fragment"><div class="line"><span class="comment">// vis-spi-out/test/test_runner.c</span></div>
<div class="line"><span class="preprocessor">#include &quot;HardwareFake.h&quot;</span></div>
</div><!-- fragment --><p>Include <code>lib/test/sensor-HardwareFake.h</code> in <code><a class="el" href="HardwareFake_8h_source.html">lib/test/HardwareFake.h</a></code></p>
<p><em>Example:</em></p>
<div class="fragment"><div class="line"><span class="comment">// lib/test/HardwareFake.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;S13131-HardwareFake.h&quot;</span></div>
</div><!-- fragment --><p>In <code>lib/test/sensor-HardwareFake.h</code>:</p>
<ul>
<li>allocate static memory for fake versions of the hardware registers</li>
<li>assign registers to these fakes</li>
<li>assign pins and bits to fake hardware i/o values</li>
</ul>
<p><em>Example:</em></p>
<div class="fragment"><div class="line"><span class="keyword">static</span> uint8_t <span class="keyword">volatile</span> fake_ddr;</div>
<div class="line">s13131_ptr S13131_ddr = &amp;fake_ddr;</div>
<div class="line">s13131_pin S13131_Clk = 5; <span class="comment">// PWM</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
lib/test/HardwareFake.h</h2>
<p>Include <code>sensor-HardwareFake.h</code>.</p>
<p><em>Example:</em></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;S13131-HardwareFake.h&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28"></a>
LisConfigs.h</h2>
<p>The LIS-770i has a header to define the user-programmable values for its internal registers. The Configs define the allowed values. Manually check this list matches the values in the JSON file.</p>
<p>The S13131 has no configurable registers, so there is no Configs file.</p>
<p>The vis-spi-out application for the LIS and the test runner for LIS unit tests include the LisConfigs header.</p>
<p><em>Examples:</em></p>
<div class="fragment"><div class="line"><span class="comment">// vis-spi-out/src/vis-spi-out.c</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="LisConfigs_8h.html">LisConfigs.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// vis-spi-out/test/test_runner.c</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="LisConfigs_8h.html">LisConfigs.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// lib/test/test_runner.c</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="LisConfigs_8h.html">LisConfigs.h</a>&quot;</span></div>
<div class="ttc" id="aLisConfigs_8h_html"><div class="ttname"><a href="LisConfigs_8h.html">LisConfigs.h</a></div><div class="ttdoc">See LisConfig.h for context.</div></div>
</div><!-- fragment --><p>LisConfigs includes "LisConfig.h" (note no "s"). This file defines LIS CONFIG datatypes and declares all the variable names that are defined in "LisConfigs.h".</p>
<p>Why two files?</p>
<p>The compilation unit with <code>main()</code> includes <code><a class="el" href="LisConfigs_8h.html" title="See LisConfig.h for context.">LisConfigs.h</a></code>.</p>
<p>Files that might end up outside the <code>main</code> compilation unit avoid a multiple definition linker error by including <code><a class="el" href="LisConfig_8h.html" title="LIS-770i configuration">LisConfig.h</a></code> <em>instead of</em> <code><a class="el" href="LisConfigs_8h.html" title="See LisConfig.h for context.">LisConfigs.h</a></code>. This is just to make the code testable. For the final AVR elf, make sure that any file that includes <code><a class="el" href="LisConfig_8h.html" title="LIS-770i configuration">LisConfig.h</a></code> is in the same compilation unit as the <code>main</code> C file.</p>
<p>For example, <code><a class="el" href="LisConfigs_8h.html" title="See LisConfig.h for context.">LisConfigs.h</a></code> defines:</p>
<ul>
<li><code>BINNING_ON=0x01</code></li>
<li><code>GAIN_1X=0x01</code></li>
<li><code>ALL_ROWS_ACTIVE=0x1F</code></li>
</ul>
<p>And when files that only include <code><a class="el" href="LisConfig_8h.html" title="LIS-770i configuration">LisConfig.h</a></code> are in the <code>main</code> compilation unit, the assembly is correct like this:</p>
<div class="fragment"><div class="line">binning = BINNING_ON;</div>
<div class="line"> 1cc:   81 e0           ldi r24, 0x01   ; 1</div>
<div class="line"> 1ce:   80 93 1a 01     sts 0x011A, r24 ; 0x80011a &lt;binning&gt;</div>
<div class="line">gain = GAIN_1X;</div>
<div class="line"> 1d2:   80 93 34 01     sts 0x0134, r24 ; 0x800134 &lt;gain&gt;</div>
<div class="line">active_rows = ALL_ROWS_ACTIVE;</div>
<div class="line"> 1d6:   8f e1           ldi r24, 0x1F   ; 31</div>
<div class="line"> 1d8:   80 93 33 01     sts 0x0133, r24 ; 0x800133 &lt;active_rows&gt;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29"></a>
Build changes</h1>
<h2><a class="anchor" id="autotoc_md30"></a>
Review of the Makefile flow</h2>
<p>There are three Makefiles at the top-level:</p>
<ul>
<li><code>uservars.mk</code> sets paths to pre-compiled dependencies from Microchip (formerly Atmel)<ul>
<li>this is pulled out into its own file to make it clear where the user has to go to set this path</li>
</ul>
</li>
<li><code>common.mk</code> has all the actual build recipes</li>
<li><code>Makefile</code> is just a bunch of help docs</li>
</ul>
<p>The "entry-point" for <code>make</code> happens in the sub-folders for the two PCBs: <code>firmware/vis-spi-out/</code> and <code>firmware/usb-bridge/</code>.</p>
<p>Users enter either <code>vis-spi-out</code> or <code>usb-bridge</code> (depending on which firmware they are building) and run the <code>Makefile</code> <b>in that folder</b>.</p>
<p>The <code>vis-spi-out/Makefile</code> and <code>usb-bridge/Makefile</code>:</p>
<ul>
<li>set a bunch of build variables used in <code>common.mk</code></li>
<li>end with <code>include ../common.mk</code><ul>
<li>the make target (e.g., build for AVR, build unit tests for the host computer, program the flash memory, etc.) finds its recipe in <code>../common.mk</code><ul>
<li>e.g., <code>make flash</code> has recipe <code>flash:</code> in <code>../common.mk</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The point of this setup is that <code>../common.mk</code> runs with the definitions from the board's <code>Makefile</code>. For example, <code>vis-spi-out/Makefile</code> sets <code>$(board-name)</code> equal to <code>vis-spi-out</code>.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
make sensor=</h2>
<p>The <code>vis-spi-out/Makefile</code> set a variable named <code>sensor</code>.</p>
<p>Identify the <code>sensor</code> when invoking make:</p>
<div class="fragment"><div class="line">$ make print-vars sensor=S13131</div>
<div class="line"> </div>
<div class="line">sensor:</div>
<div class="line">- S13131</div>
<div class="line">...</div>
</div><!-- fragment --><p>If <code>sensor</code> is left out, the default value is <code>sensor=LIS</code>:</p>
<div class="fragment"><div class="line">$ make print-vars</div>
<div class="line"> </div>
<div class="line">sensor:</div>
<div class="line">- LIS</div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
Default value for sensor</h2>
<p>Set <code>LIS</code> as the default sensor in <code>vis-spi-out/Makefile</code>:</p>
<div class="fragment"><div class="line"># Name which sensor is attached to the vis-spi-out PCB</div>
<div class="line">sensor ?= LIS</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
A macro is defined by sensor=</h2>
<p>Modify the build recipes to use <code>sensor</code> to define a macro:</p>
<div class="fragment"><div class="line">-D$(sensor)</div>
</div><!-- fragment --><p><em>Example:</em></p>
<p>If <code>sensor</code> is <code>LIS</code>, then the above line becomes:</p>
<div class="fragment"><div class="line">-DLIS</div>
</div><!-- fragment --><p>That gets used in a recipe like this:</p>
<div class="fragment"><div class="line">build/${board-name}.o: src/${board-name}.c src/Hardware.h ${Hardware} ${lib_headers} ../lib/src/StatusCode.h ../lib/src/StatusCodes.h ../lib/src/LisConfig.h ../lib/src/LisConfigs.h</div>
<div class="line">    ${compiler} -D$(sensor) $(CFLAGS) -c $&lt; -o $@</div>
<div class="line">                 ↑</div>
<div class="line">                 |</div>
<div class="line">-DLIS ───────────┘</div>
</div><!-- fragment --><p>Now the macro <code>LIS</code> is "defined" when the compiler parses the source code.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Source code is bracketed with ifdef sensor macros</h2>
<p>Source code checks if the <code></code> macro is defined to decide which code to include.</p>
<p><em>Example:</em></p>
<div class="fragment"><div class="line"><span class="comment">// vis-spi-out/src/Hardware.h</span></div>
<div class="line"><span class="preprocessor">#ifdef LIS</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="Lis-Hardware_8h.html">Lis-Hardware.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#ifdef S13131</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="S13131-Hardware_8h.html">S13131-Hardware.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="aLis-Hardware_8h_html"><div class="ttname"><a href="Lis-Hardware_8h.html">Lis-Hardware.h</a></div><div class="ttdoc">Lis uses general purpose I/O pins and a PWM pin to communicate with the Dynamax LIS-770i linear photo...</div></div>
</div><!-- fragment --><p>If the build is invoked with <code>make flash sensor=S13131</code> then the build ignores the LIS-770i code and uses the S13131 code. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
